/*
    http://www.JSON.org/json2.js
    2011-02-23

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.


    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.
*/

/*jslint evil: true, strict: false, regexp: false */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

var JSON;
if (!JSON) {
    JSON = {};
}

(function () {
    "use strict";

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf()) ?
                this.getUTCFullYear()     + '-' +
                f(this.getUTCMonth() + 1) + '-' +
                f(this.getUTCDate())      + 'T' +
                f(this.getUTCHours())     + ':' +
                f(this.getUTCMinutes())   + ':' +
                f(this.getUTCSeconds())   + 'Z' : null;
        };

        String.prototype.toJSON      =
            Number.prototype.toJSON  =
            Boolean.prototype.toJSON = function (key) {
                return this.valueOf();
            };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string' ? c :
                '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0 ? '{}' : gap ?
                '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
                '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function' ?
                    walk({'': j}, '') : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
}());
((typeof define === "function" && define.amd && function (m) { define(m); }) ||
 (typeof module === "object" && function (m) { module.exports = m(); }) ||
 function (m) { this.bane = m(); }
)(function () {
    "use strict";
    var slice = Array.prototype.slice;

    function handleError(event, error, errbacks) {
        var i, l = errbacks.length;
        if (l > 0) {
            for (i = 0; i < l; ++i) { errbacks[i](event, error); }
            return;
        }
        setTimeout(function () {
            error.message = event + " listener threw error: " + error.message;
            throw error;
        }, 0);
    }

    function assertFunction(fn) {
        if (typeof fn !== "function") {
            throw new TypeError("Listener is not function");
        }
        return fn;
    }

    /**
     * @signature var emitter = bane.createEmitter([object]);
     * 
     * Create a new event emitter. If an object is passed, it will be modified
     * by adding the event emitter methods (see below).
     */
    function createEventEmitter(object) {
        object = object || {};
        var listeners = {};
        var supervisors = [];
        var errbacks = [];

        function notifyListener(event, listener, args) {
            try {
                listener.listener.apply(listener.thisp || object, args);
            } catch (e) {
                handleError(event, e, errbacks);
            }
        }

        object.on = function (event, listener, thisp) {
            if (typeof event === "function") {
                return supervisors.push({ listener: event, thisp: listener });
            }
            (listeners[event] = listeners[event] || []).push({
                listener: assertFunction(listener),
                thisp: thisp
            });
        };

        object.off = function (event, listener) {
            var fns = listeners[event] || [], i, l;
            for (i = 0, l = fns.length; i < l; ++i) {
                if (fns[i].listener === listener) {
                    fns.splice(i, 1);
                    return;
                }
            }
        };

        object.once = function (event, listener, thisp) {
            var wrapper = function () {
                object.off(event, wrapper);
                listener.apply(this, arguments);
            };

            object.on(event, wrapper, thisp);
        };

        object.bind = function (object, events) {
            var prop, i, l;
            if (!events) {
                for (prop in object) {
                    if (object.hasOwnProperty(prop) &&
                            typeof object[prop] === "function") {
                        this.on(prop, object[prop], object);
                    }
                }
            } else {
                for (i = 0, l = events.length; i < l; ++i) {
                    if (typeof object[events[i]] === "function") {
                        this.on(events[i], object[events[i]], object);
                    } else {
                        throw new Error("No such method " + events[i]);
                    }
                }
            }
            return object;
        };

        object.emit = function (event) {
            var toNotify = (listeners[event] || []).slice();
            var args = slice.call(arguments, 1), i, l;

            for (i = 0, l = toNotify.length; i < l; i++) {
                notifyListener(event, toNotify[i], args);
            }

            toNotify = supervisors || [];
            args = slice.call(arguments);
            for (i = 0, l = toNotify.length; i < l; ++i) {
                notifyListener(event, toNotify[i], args);
            }
        };

        object.errback = function (listener) {
            errbacks.push(assertFunction(listener));
        };

        return object;
    }

    return { createEventEmitter: createEventEmitter };
});
var Faye=(typeof Faye==='object')?Faye:{};if(typeof window!=='undefined')window.Faye=Faye;Faye.extend=function(a,b,d){if(!b)return a;for(var f in b){if(!b.hasOwnProperty(f))continue;if(a.hasOwnProperty(f)&&d===false)continue;if(a[f]!==b[f])a[f]=b[f]}return a};Faye.extend(Faye,{VERSION:'0.8.8',BAYEUX_VERSION:'1.0',ID_LENGTH:160,JSONP_CALLBACK:'jsonpcallback',CONNECTION_TYPES:['long-polling','cross-origin-long-polling','callback-polling','websocket','eventsource','in-process'],MANDATORY_CONNECTION_TYPES:['long-polling','callback-polling','in-process'],ENV:(function(){return this})(),random:function(a){a=a||this.ID_LENGTH;if(a>32){var b=Math.ceil(a/32),d='';while(b--)d+=this.random(32);var f=d.split(''),g='';while(f.length>0)g+=f.pop();return g}var h=Math.pow(2,a)-1,i=h.toString(36).length,d=Math.floor(Math.random()*h).toString(36);while(d.length<i)d='0'+d;return d},clientIdFromMessages:function(a){var b=[].concat(a)[0];return b&&b.clientId},copyObject:function(a){var b,d,f;if(a instanceof Array){b=[];d=a.length;while(d--)b[d]=Faye.copyObject(a[d]);return b}else if(typeof a==='object'){b=(a===null)?null:{};for(f in a)b[f]=Faye.copyObject(a[f]);return b}else{return a}},commonElement:function(a,b){for(var d=0,f=a.length;d<f;d++){if(this.indexOf(b,a[d])!==-1)return a[d]}return null},indexOf:function(a,b){if(a.indexOf)return a.indexOf(b);for(var d=0,f=a.length;d<f;d++){if(a[d]===b)return d}return-1},map:function(a,b,d){if(a.map)return a.map(b,d);var f=[];if(a instanceof Array){for(var g=0,h=a.length;g<h;g++){f.push(b.call(d||null,a[g],g))}}else{for(var i in a){if(!a.hasOwnProperty(i))continue;f.push(b.call(d||null,i,a[i]))}}return f},filter:function(a,b,d){var f=[];for(var g=0,h=a.length;g<h;g++){if(b.call(d||null,a[g],g))f.push(a[g])}return f},asyncEach:function(a,b,d,f){var g=a.length,h=-1,i=0,k=false;var j=function(){i-=1;h+=1;if(h===g)return d&&d.call(f);b(a[h],n)};var l=function(){if(k)return;k=true;while(i>0)j();k=false};var n=function(){i+=1;l()};n()},toJSON:function(a){if(this.stringify)return this.stringify(a,function(key,value){return(this[key]instanceof Array)?this[key]:value});return JSON.stringify(a)},logger:function(a){if(typeof console!=='undefined')console.log(a)},timestamp:function(){var b=new Date(),d=b.getFullYear(),f=b.getMonth()+1,g=b.getDate(),h=b.getHours(),i=b.getMinutes(),k=b.getSeconds();var j=function(a){return a<10?'0'+a:String(a)};return j(d)+'-'+j(f)+'-'+j(g)+' '+j(h)+':'+j(i)+':'+j(k)}});Faye.Class=function(a,b){if(typeof a!=='function'){b=a;a=Object}var d=function(){if(!this.initialize)return this;return this.initialize.apply(this,arguments)||this};var f=function(){};f.prototype=a.prototype;d.prototype=new f();Faye.extend(d.prototype,b);return d};Faye.Namespace=Faye.Class({initialize:function(){this._e={}},exists:function(a){return this._e.hasOwnProperty(a)},generate:function(){var a=Faye.random();while(this._e.hasOwnProperty(a))a=Faye.random();return this._e[a]=a},release:function(a){delete this._e[a]}});Faye.Error=Faye.Class({initialize:function(a,b,d){this.code=a;this.params=Array.prototype.slice.call(b);this.message=d},toString:function(){return this.code+':'+this.params.join(',')+':'+this.message}});Faye.Error.parse=function(a){a=a||'';if(!Faye.Grammar.ERROR.test(a))return new this(null,[],a);var b=a.split(':'),d=parseInt(b[0]),f=b[1].split(','),a=b[2];return new this(d,f,a)};Faye.Error.versionMismatch=function(){return new this(300,arguments,"Version mismatch").toString()};Faye.Error.conntypeMismatch=function(){return new this(301,arguments,"Connection types not supported").toString()};Faye.Error.extMismatch=function(){return new this(302,arguments,"Extension mismatch").toString()};Faye.Error.badRequest=function(){return new this(400,arguments,"Bad request").toString()};Faye.Error.clientUnknown=function(){return new this(401,arguments,"Unknown client").toString()};Faye.Error.parameterMissing=function(){return new this(402,arguments,"Missing required parameter").toString()};Faye.Error.channelForbidden=function(){return new this(403,arguments,"Forbidden channel").toString()};Faye.Error.channelUnknown=function(){return new this(404,arguments,"Unknown channel").toString()};Faye.Error.channelInvalid=function(){return new this(405,arguments,"Invalid channel").toString()};Faye.Error.extUnknown=function(){return new this(406,arguments,"Unknown extension").toString()};Faye.Error.publishFailed=function(){return new this(407,arguments,"Failed to publish").toString()};Faye.Error.serverError=function(){return new this(500,arguments,"Internal server error").toString()};Faye.Deferrable={callback:function(a,b){if(!a)return;if(this._w==='succeeded')return a.apply(b,this._j);this._k=this._k||[];this._k.push([a,b])},timeout:function(a,b){var d=this;var f=Faye.ENV.setTimeout(function(){d.setDeferredStatus('failed',b)},a*1000);this._x=f},errback:function(a,b){if(!a)return;if(this._w==='failed')return a.apply(b,this._j);this._l=this._l||[];this._l.push([a,b])},setDeferredStatus:function(){if(this._x)Faye.ENV.clearTimeout(this._x);var a=Array.prototype.slice.call(arguments),b=a.shift(),d;this._w=b;this._j=a;if(b==='succeeded')d=this._k;else if(b==='failed')d=this._l;if(!d)return;var f;while(f=d.shift())f[0].apply(f[1],this._j)}};Faye.Publisher={countListeners:function(a){if(!this._3||!this._3[a])return 0;return this._3[a].length},bind:function(a,b,d){this._3=this._3||{};var f=this._3[a]=this._3[a]||[];f.push([b,d])},unbind:function(a,b,d){if(!this._3||!this._3[a])return;if(!b){delete this._3[a];return}var f=this._3[a],g=f.length;while(g--){if(b!==f[g][0])continue;if(d&&f[g][1]!==d)continue;f.splice(g,1)}},trigger:function(){var a=Array.prototype.slice.call(arguments),b=a.shift();if(!this._3||!this._3[b])return;var d=this._3[b].slice(),f;for(var g=0,h=d.length;g<h;g++){f=d[g];f[0].apply(f[1],a)}}};Faye.Timeouts={addTimeout:function(a,b,d,f){this._5=this._5||{};if(this._5.hasOwnProperty(a))return;var g=this;this._5[a]=Faye.ENV.setTimeout(function(){delete g._5[a];d.call(f)},1000*b)},removeTimeout:function(a){this._5=this._5||{};var b=this._5[a];if(!b)return;clearTimeout(b);delete this._5[a]}};Faye.Logging={LOG_LEVELS:{error:3,warn:2,info:1,debug:0},logLevel:'error',log:function(a,b){if(!Faye.logger)return;var d=Faye.Logging.LOG_LEVELS;if(d[Faye.Logging.logLevel]>d[b])return;var a=Array.prototype.slice.apply(a),f=' ['+b.toUpperCase()+'] [Faye',g=this.className,h=a.shift().replace(/\?/g,function(){try{return Faye.toJSON(a.shift())}catch(e){return'[Object]'}});for(var i in Faye){if(g)continue;if(typeof Faye[i]!=='function')continue;if(this instanceof Faye[i])g=i}if(g)f+='.'+g;f+='] ';Faye.logger(Faye.timestamp()+f+h)}};(function(){for(var d in Faye.Logging.LOG_LEVELS)(function(a,b){Faye.Logging[a]=function(){this.log(arguments,a)}})(d,Faye.Logging.LOG_LEVELS[d])})();Faye.Grammar={LOWALPHA:/^[a-z]$/,UPALPHA:/^[A-Z]$/,ALPHA:/^([a-z]|[A-Z])$/,DIGIT:/^[0-9]$/,ALPHANUM:/^(([a-z]|[A-Z])|[0-9])$/,MARK:/^(\-|\_|\!|\~|\(|\)|\$|\@)$/,STRING:/^(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)| |\/|\*|\.))*$/,TOKEN:/^(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)))+$/,INTEGER:/^([0-9])+$/,CHANNEL_SEGMENT:/^(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)))+$/,CHANNEL_SEGMENTS:/^(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)))+(\/(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)))+)*$/,CHANNEL_NAME:/^\/(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)))+(\/(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)))+)*$/,WILD_CARD:/^\*{1,2}$/,CHANNEL_PATTERN:/^(\/(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)))+)*\/\*{1,2}$/,VERSION_ELEMENT:/^(([a-z]|[A-Z])|[0-9])(((([a-z]|[A-Z])|[0-9])|\-|\_))*$/,VERSION:/^([0-9])+(\.(([a-z]|[A-Z])|[0-9])(((([a-z]|[A-Z])|[0-9])|\-|\_))*)*$/,CLIENT_ID:/^((([a-z]|[A-Z])|[0-9]))+$/,ID:/^((([a-z]|[A-Z])|[0-9]))+$/,ERROR_MESSAGE:/^(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)| |\/|\*|\.))*$/,ERROR_ARGS:/^(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)| |\/|\*|\.))*(,(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)| |\/|\*|\.))*)*$/,ERROR_CODE:/^[0-9][0-9][0-9]$/,ERROR:/^([0-9][0-9][0-9]:(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)| |\/|\*|\.))*(,(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)| |\/|\*|\.))*)*:(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)| |\/|\*|\.))*|[0-9][0-9][0-9]::(((([a-z]|[A-Z])|[0-9])|(\-|\_|\!|\~|\(|\)|\$|\@)| |\/|\*|\.))*)$/};Faye.Extensible={addExtension:function(a){this._6=this._6||[];this._6.push(a);if(a.added)a.added(this)},removeExtension:function(a){if(!this._6)return;var b=this._6.length;while(b--){if(this._6[b]!==a)continue;this._6.splice(b,1);if(a.removed)a.removed(this)}},pipeThroughExtensions:function(d,f,g,h){this.debug('Passing through ? extensions: ?',d,f);if(!this._6)return g.call(h,f);var i=this._6.slice();var k=function(a){if(!a)return g.call(h,a);var b=i.shift();if(!b)return g.call(h,a);if(b[d])b[d](a,k);else k(a)};k(f)}};Faye.extend(Faye.Extensible,Faye.Logging);Faye.Channel=Faye.Class({initialize:function(a){this.id=this.name=a},push:function(a){this.trigger('message',a)},isUnused:function(){return this.countListeners('message')===0}});Faye.extend(Faye.Channel.prototype,Faye.Publisher);Faye.extend(Faye.Channel,{HANDSHAKE:'/meta/handshake',CONNECT:'/meta/connect',SUBSCRIBE:'/meta/subscribe',UNSUBSCRIBE:'/meta/unsubscribe',DISCONNECT:'/meta/disconnect',META:'meta',SERVICE:'service',expand:function(a){var b=this.parse(a),d=['/**',a];var f=b.slice();f[f.length-1]='*';d.push(this.unparse(f));for(var g=1,h=b.length;g<h;g++){f=b.slice(0,g);f.push('**');d.push(this.unparse(f))}return d},isValid:function(a){return Faye.Grammar.CHANNEL_NAME.test(a)||Faye.Grammar.CHANNEL_PATTERN.test(a)},parse:function(a){if(!this.isValid(a))return null;return a.split('/').slice(1)},unparse:function(a){return'/'+a.join('/')},isMeta:function(a){var b=this.parse(a);return b?(b[0]===this.META):null},isService:function(a){var b=this.parse(a);return b?(b[0]===this.SERVICE):null},isSubscribable:function(a){if(!this.isValid(a))return null;return!this.isMeta(a)&&!this.isService(a)},Set:Faye.Class({initialize:function(){this._2={}},getKeys:function(){var a=[];for(var b in this._2)a.push(b);return a},remove:function(a){delete this._2[a]},hasSubscription:function(a){return this._2.hasOwnProperty(a)},subscribe:function(a,b,d){if(!b)return;var f;for(var g=0,h=a.length;g<h;g++){f=a[g];var i=this._2[f]=this._2[f]||new Faye.Channel(f);i.bind('message',b,d)}},unsubscribe:function(a,b,d){var f=this._2[a];if(!f)return false;f.unbind('message',b,d);if(f.isUnused()){this.remove(a);return true}else{return false}},distributeMessage:function(a){var b=Faye.Channel.expand(a.channel);for(var d=0,f=b.length;d<f;d++){var g=this._2[b[d]];if(g)g.trigger('message',a.data)}}})});Faye.Publication=Faye.Class(Faye.Deferrable);Faye.Subscription=Faye.Class({initialize:function(a,b,d,f){this._7=a;this._2=b;this._m=d;this._n=f;this._y=false},cancel:function(){if(this._y)return;this._7.unsubscribe(this._2,this._m,this._n);this._y=true},unsubscribe:function(){this.cancel()}});Faye.extend(Faye.Subscription.prototype,Faye.Deferrable);Faye.Client=Faye.Class({UNCONNECTED:1,CONNECTING:2,CONNECTED:3,DISCONNECTED:4,HANDSHAKE:'handshake',RETRY:'retry',NONE:'none',CONNECTION_TIMEOUT:60.0,DEFAULT_RETRY:5.0,DEFAULT_ENDPOINT:'/bayeux',INTERVAL:0.0,initialize:function(a,b){this.info('New client created for ?',a);this._f=b||{};this.endpoint=a||this.DEFAULT_ENDPOINT;this.endpoints=this._f.endpoints||{};this.transports={};this._E=Faye.CookieJar&&new Faye.CookieJar();this._z={};this._o=[];this.retry=this._f.retry||this.DEFAULT_RETRY;this._A(Faye.MANDATORY_CONNECTION_TYPES);this._1=this.UNCONNECTED;this._2=new Faye.Channel.Set();this._g=0;this._p={};this._8={reconnect:this.RETRY,interval:1000*(this._f.interval||this.INTERVAL),timeout:1000*(this._f.timeout||this.CONNECTION_TIMEOUT)};if(Faye.Event)Faye.Event.on(Faye.ENV,'beforeunload',function(){if(Faye.indexOf(this._o,'autodisconnect')<0)this.disconnect()},this)},disable:function(a){this._o.push(a)},setHeader:function(a,b){this._z[a]=b},getClientId:function(){return this._0},getState:function(){switch(this._1){case this.UNCONNECTED:return'UNCONNECTED';case this.CONNECTING:return'CONNECTING';case this.CONNECTED:return'CONNECTED';case this.DISCONNECTED:return'DISCONNECTED'}},handshake:function(f,g){if(this._8.reconnect===this.NONE)return;if(this._1!==this.UNCONNECTED)return;this._1=this.CONNECTING;var h=this;this.info('Initiating handshake with ?',this.endpoint);this._9({channel:Faye.Channel.HANDSHAKE,version:Faye.BAYEUX_VERSION,supportedConnectionTypes:[this._a.connectionType]},function(b){if(b.successful){this._1=this.CONNECTED;this._0=b.clientId;var d=Faye.filter(b.supportedConnectionTypes,function(a){return Faye.indexOf(this._o,a)<0},this);this._A(d);this.info('Handshake successful: ?',this._0);this.subscribe(this._2.getKeys(),true);if(f)f.call(g)}else{this.info('Handshake unsuccessful');Faye.ENV.setTimeout(function(){h.handshake(f,g)},this._8.interval);this._1=this.UNCONNECTED}},this)},connect:function(a,b){if(this._8.reconnect===this.NONE)return;if(this._1===this.DISCONNECTED)return;if(this._1===this.UNCONNECTED)return this.handshake(function(){this.connect(a,b)},this);this.callback(a,b);if(this._1!==this.CONNECTED)return;this.info('Calling deferred actions for ?',this._0);this.setDeferredStatus('succeeded');this.setDeferredStatus('deferred');if(this._q)return;this._q=true;this.info('Initiating connection for ?',this._0);this._9({channel:Faye.Channel.CONNECT,clientId:this._0,connectionType:this._a.connectionType},this._B,this)},disconnect:function(){if(this._1!==this.CONNECTED)return;this._1=this.DISCONNECTED;this.info('Disconnecting ?',this._0);this._9({channel:Faye.Channel.DISCONNECT,clientId:this._0},function(a){if(a.successful)this._a.close()},this);this.info('Clearing channel listeners for ?',this._0);this._2=new Faye.Channel.Set()},subscribe:function(d,f,g){if(d instanceof Array)return Faye.map(d,function(c){return this.subscribe(c,f,g)},this);var h=new Faye.Subscription(this,d,f,g),i=(f===true),k=this._2.hasSubscription(d);if(k&&!i){this._2.subscribe([d],f,g);h.setDeferredStatus('succeeded');return h}this.connect(function(){this.info('Client ? attempting to subscribe to ?',this._0,d);if(!i)this._2.subscribe([d],f,g);this._9({channel:Faye.Channel.SUBSCRIBE,clientId:this._0,subscription:d},function(a){if(!a.successful){h.setDeferredStatus('failed',Faye.Error.parse(a.error));return this._2.unsubscribe(d,f,g)}var b=[].concat(a.subscription);this.info('Subscription acknowledged for ? to ?',this._0,b);h.setDeferredStatus('succeeded')},this)},this);return h},unsubscribe:function(d,f,g){if(d instanceof Array)return Faye.map(d,function(c){return this.unsubscribe(c,f,g)},this);var h=this._2.unsubscribe(d,f,g);if(!h)return;this.connect(function(){this.info('Client ? attempting to unsubscribe from ?',this._0,d);this._9({channel:Faye.Channel.UNSUBSCRIBE,clientId:this._0,subscription:d},function(a){if(!a.successful)return;var b=[].concat(a.subscription);this.info('Unsubscription acknowledged for ? from ?',this._0,b)},this)},this)},publish:function(b,d){var f=new Faye.Publication();this.connect(function(){this.info('Client ? queueing published message to ?: ?',this._0,b,d);this._9({channel:b,data:d,clientId:this._0},function(a){if(a.successful)f.setDeferredStatus('succeeded');else f.setDeferredStatus('failed',Faye.Error.parse(a.error))},this)},this);return f},receiveMessage:function(d){this.pipeThroughExtensions('incoming',d,function(a){if(!a)return;if(a.advice)this._F(a.advice);this._G(a);if(a.successful===undefined)return;var b=this._p[a.id];if(!b)return;delete this._p[a.id];b[0].call(b[1],a)},this)},_A:function(b){Faye.Transport.get(this,b,function(a){this.debug('Selected ? transport for ?',a.connectionType,a.endpoint);this._a=a;this._a.cookies=this._E;this._a.headers=this._z;a.bind('down',function(){if(this._b!==undefined&&!this._b)return;this._b=false;this.trigger('transport:down')},this);a.bind('up',function(){if(this._b!==undefined&&this._b)return;this._b=true;this.trigger('transport:up')},this)},this)},_9:function(b,d,f){b.id=this._H();if(d)this._p[b.id]=[d,f];this.pipeThroughExtensions('outgoing',b,function(a){if(!a)return;this._a.send(a,this._8.timeout/1000)},this)},_H:function(){this._g+=1;if(this._g>=Math.pow(2,32))this._g=0;return this._g.toString(36)},_F:function(a){Faye.extend(this._8,a);if(this._8.reconnect===this.HANDSHAKE&&this._1!==this.DISCONNECTED){this._1=this.UNCONNECTED;this._0=null;this._B()}},_G:function(a){if(!a.channel||a.data===undefined)return;this.info('Client ? calling listeners for ? with ?',this._0,a.channel,a.data);this._2.distributeMessage(a)},_I:function(){if(!this._q)return;this._q=null;this.info('Closed connection for ?',this._0)},_B:function(){this._I();var a=this;Faye.ENV.setTimeout(function(){a.connect()},this._8.interval)}});Faye.extend(Faye.Client.prototype,Faye.Deferrable);Faye.extend(Faye.Client.prototype,Faye.Publisher);Faye.extend(Faye.Client.prototype,Faye.Logging);Faye.extend(Faye.Client.prototype,Faye.Extensible);Faye.Transport=Faye.extend(Faye.Class({MAX_DELAY:0.0,batching:true,initialize:function(a,b){this._7=a;this.endpoint=b;this._c=[]},close:function(){},send:function(a,b){this.debug('Client ? sending message to ?: ?',this._7._0,this.endpoint,a);if(!this.batching)return this.request([a],b);this._c.push(a);this._J=b;if(a.channel===Faye.Channel.HANDSHAKE)return this.addTimeout('publish',0.01,this.flush,this);if(a.channel===Faye.Channel.CONNECT)this._r=a;if(this.shouldFlush&&this.shouldFlush(this._c))return this.flush();this.addTimeout('publish',this.MAX_DELAY,this.flush,this)},flush:function(){this.removeTimeout('publish');if(this._c.length>1&&this._r)this._r.advice={timeout:0};this.request(this._c,this._J);this._r=null;this._c=[]},receive:function(a){this.debug('Client ? received from ?: ?',this._7._0,this.endpoint,a);for(var b=0,d=a.length;b<d;b++){this._7.receiveMessage(a[b])}},retry:function(a,b){var d=false,f=this._7.retry*1000,g=this;return function(){if(d)return;d=true;Faye.ENV.setTimeout(function(){g.request(a,b)},f)}}}),{MAX_URL_LENGTH:2048,get:function(k,j,l,n){var o=k.endpoint;if(j===undefined)j=this.supportedConnectionTypes();Faye.asyncEach(this._s,function(d,f){var g=d[0],h=d[1],i=k.endpoints[g]||o;if(Faye.indexOf(j,g)<0){h.isUsable(k,i,function(){});return f()}h.isUsable(k,i,function(a){if(!a)return f();var b=h.hasOwnProperty('create')?h.create(k,i):new h(k,i);l.call(n,b)})},function(){throw new Error('Could not find a usable connection type for '+o);})},register:function(a,b){this._s.push([a,b]);b.prototype.connectionType=a},_s:[],supportedConnectionTypes:function(){return Faye.map(this._s,function(a){return a[0]})}});Faye.extend(Faye.Transport.prototype,Faye.Logging);Faye.extend(Faye.Transport.prototype,Faye.Publisher);Faye.extend(Faye.Transport.prototype,Faye.Timeouts);Faye.Event={_h:[],on:function(a,b,d,f){var g=function(){d.call(f)};if(a.addEventListener)a.addEventListener(b,g,false);else a.attachEvent('on'+b,g);this._h.push({_i:a,_t:b,_m:d,_n:f,_C:g})},detach:function(a,b,d,f){var g=this._h.length,h;while(g--){h=this._h[g];if((a&&a!==h._i)||(b&&b!==h._t)||(d&&d!==h._m)||(f&&f!==h._n))continue;if(h._i.removeEventListener)h._i.removeEventListener(h._t,h._C,false);else h._i.detachEvent('on'+h._t,h._C);this._h.splice(g,1);h=null}}};Faye.Event.on(Faye.ENV,'unload',Faye.Event.detach,Faye.Event);Faye.URI=Faye.extend(Faye.Class({queryString:function(){var a=[];for(var b in this.params){if(!this.params.hasOwnProperty(b))continue;a.push(encodeURIComponent(b)+'='+encodeURIComponent(this.params[b]))}return a.join('&')},isSameOrigin:function(){var a=Faye.URI.parse(Faye.ENV.location.href);var b=(a.hostname!==this.hostname)||(a.port!==this.port)||(a.protocol!==this.protocol);return!b},toURL:function(){var a=this.queryString();return this.protocol+'//'+this.hostname+(this.port?':'+this.port:'')+this.pathname+(a?'?'+a:'')+this.hash}}),{parse:function(g,h){if(typeof g!=='string')return g;var i=new this(),k;var j=function(b,d,f){g=g.replace(d,function(a){i[b]=a;return''});if(i[b]===undefined)i[b]=f?Faye.ENV.location[b]:''};j('protocol',/^https?\:/,true);j('host',/^\/\/[^\/]+/,true);if(!/^\//.test(g))g=Faye.ENV.location.pathname.replace(/[^\/]*$/,'')+g;j('pathname',/^\/[^\?#]*/);j('search',/^\?[^#]*/);j('hash',/^#.*/);if(/^\/\//.test(i.host)){i.host=i.host.substr(2);k=i.host.split(':');i.hostname=k[0];i.port=k[1]||''}else{i.hostname=Faye.ENV.location.hostname;i.port=Faye.ENV.location.port}var l=i.search.replace(/^\?/,''),n=l?l.split('&'):[],o=n.length,m={};while(o--){k=n[o].split('=');m[decodeURIComponent(k[0]||'')]=decodeURIComponent(k[1]||'')}if(typeof h==='object')Faye.extend(m,h);i.params=m;return i}});if(!this.JSON){JSON={}}(function(){function l(a){return a<10?'0'+a:a}if(typeof Date.prototype.toJSON!=='function'){Date.prototype.toJSON=function(a){return this.getUTCFullYear()+'-'+l(this.getUTCMonth()+1)+'-'+l(this.getUTCDate())+'T'+l(this.getUTCHours())+':'+l(this.getUTCMinutes())+':'+l(this.getUTCSeconds())+'Z'};String.prototype.toJSON=Number.prototype.toJSON=Boolean.prototype.toJSON=function(a){return this.valueOf()}}var n=/[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,o=/[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,m,q,t={'\b':'\\b','\t':'\\t','\n':'\\n','\f':'\\f','\r':'\\r','"':'\\"','\\':'\\\\'},p;function s(d){o.lastIndex=0;return o.test(d)?'"'+d.replace(o,function(a){var b=t[a];return typeof b==='string'?b:'\\u'+('0000'+a.charCodeAt(0).toString(16)).slice(-4)})+'"':'"'+d+'"'}function r(a,b){var d,f,g,h,i=m,k,j=b[a];if(j&&typeof j==='object'&&typeof j.toJSON==='function'){j=j.toJSON(a)}if(typeof p==='function'){j=p.call(b,a,j)}switch(typeof j){case'string':return s(j);case'number':return isFinite(j)?String(j):'null';case'boolean':case'null':return String(j);case'object':if(!j){return'null'}m+=q;k=[];if(Object.prototype.toString.apply(j)==='[object Array]'){h=j.length;for(d=0;d<h;d+=1){k[d]=r(d,j)||'null'}g=k.length===0?'[]':m?'[\n'+m+k.join(',\n'+m)+'\n'+i+']':'['+k.join(',')+']';m=i;return g}if(p&&typeof p==='object'){h=p.length;for(d=0;d<h;d+=1){f=p[d];if(typeof f==='string'){g=r(f,j);if(g){k.push(s(f)+(m?': ':':')+g)}}}}else{for(f in j){if(Object.hasOwnProperty.call(j,f)){g=r(f,j);if(g){k.push(s(f)+(m?': ':':')+g)}}}}g=k.length===0?'{}':m?'{\n'+m+k.join(',\n'+m)+'\n'+i+'}':'{'+k.join(',')+'}';m=i;return g}}Faye.stringify=function(a,b,d){var f;m='';q='';if(typeof d==='number'){for(f=0;f<d;f+=1){q+=' '}}else if(typeof d==='string'){q=d}p=b;if(b&&typeof b!=='function'&&(typeof b!=='object'||typeof b.length!=='number')){throw new Error('JSON.stringify');}return r('',{'':a})};if(typeof JSON.stringify!=='function'){JSON.stringify=Faye.stringify}if(typeof JSON.parse!=='function'){JSON.parse=function(h,i){var k;function j(a,b){var d,f,g=a[b];if(g&&typeof g==='object'){for(d in g){if(Object.hasOwnProperty.call(g,d)){f=j(g,d);if(f!==undefined){g[d]=f}else{delete g[d]}}}}return i.call(a,b,g)}n.lastIndex=0;if(n.test(h)){h=h.replace(n,function(a){return'\\u'+('0000'+a.charCodeAt(0).toString(16)).slice(-4)})}if(/^[\],:{}\s]*$/.test(h.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,'@').replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,']').replace(/(?:^|:|,)(?:\s*\[)+/g,''))){k=eval('('+h+')');return typeof i==='function'?j({'':k},''):k}throw new SyntaxError('JSON.parse');}}}());Faye.Transport.WebSocket=Faye.extend(Faye.Class(Faye.Transport,{UNCONNECTED:1,CONNECTING:2,CONNECTED:3,batching:false,isUsable:function(a,b){this.callback(function(){a.call(b,true)});this.errback(function(){a.call(b,false)});this.connect()},request:function(b,d){if(b.length===0)return;this._d=this._d||{};for(var f=0,g=b.length;f<g;f++){this._d[b[f].id]=b[f]}this.callback(function(a){a.send(Faye.toJSON(b))});this.connect()},close:function(){if(this._D)return;this._D=true;if(this._4)this._4.close()},connect:function(){if(Faye.Transport.WebSocket._K)return;if(this._D)return;this._1=this._1||this.UNCONNECTED;if(this._1!==this.UNCONNECTED)return;this._1=this.CONNECTING;var g=Faye.Transport.WebSocket.getClass();if(!g)return this.setDeferredStatus('failed');this._4=new g(Faye.Transport.WebSocket.getSocketUrl(this.endpoint));var h=this;this._4.onopen=function(){h._1=h.CONNECTED;h._u=true;h.setDeferredStatus('succeeded',h._4);h.trigger('up')};this._4.onmessage=function(a){var b=[].concat(JSON.parse(a.data));for(var d=0,f=b.length;d<f;d++){delete h._d[b[d].id]}h.receive(b)};this._4.onclose=function(){var a=(h._1===h.CONNECTED);h.setDeferredStatus('deferred');h._1=h.UNCONNECTED;delete h._4;if(a)return h.resend();if(!h._u)return h.setDeferredStatus('failed');var b=h._7.retry*1000;Faye.ENV.setTimeout(function(){h.connect()},b);h.trigger('down')}},resend:function(){if(!this._d)return;var d=Faye.map(this._d,function(a,b){return b});this.request(d)}}),{getSocketUrl:function(a){if(Faye.URI)a=Faye.URI.parse(a).toURL();return a.replace(/^http(s?):/ig,'ws$1:')},getClass:function(){return(Faye.WebSocket&&Faye.WebSocket.Client)||Faye.ENV.WebSocket||Faye.ENV.MozWebSocket},isUsable:function(a,b,d,f){this.create(a,b).isUsable(d,f)},create:function(a,b){var d=a.transports.websocket=a.transports.websocket||{};d[b]=d[b]||new this(a,b);return d[b]}});Faye.extend(Faye.Transport.WebSocket.prototype,Faye.Deferrable);Faye.Transport.register('websocket',Faye.Transport.WebSocket);if(Faye.Event)Faye.Event.on(Faye.ENV,'beforeunload',function(){Faye.Transport.WebSocket._K=true});Faye.Transport.EventSource=Faye.extend(Faye.Class(Faye.Transport,{initialize:function(b,d){Faye.Transport.prototype.initialize.call(this,b,d);if(!Faye.ENV.EventSource)return this.setDeferredStatus('failed');this._L=new Faye.Transport.XHR(b,d);var f=new EventSource(d+'/'+b.getClientId()),g=this;f.onopen=function(){g._u=true;g.setDeferredStatus('succeeded');g.trigger('up')};f.onerror=function(){if(g._u){g.trigger('down')}else{g.setDeferredStatus('failed');f.close()}};f.onmessage=function(a){g.receive(JSON.parse(a.data));g.trigger('up')};this._4=f},isUsable:function(a,b){this.callback(function(){a.call(b,true)});this.errback(function(){a.call(b,false)})},request:function(a,b){this._L.request(a,b)},close:function(){this._4.close()}}),{isUsable:function(b,d,f,g){var h=b.getClientId();if(!h)return f.call(g,false);Faye.Transport.XHR.isUsable(b,d,function(a){if(!a)return f.call(g,false);this.create(b,d).isUsable(f,g)},this)},create:function(a,b){var d=a.transports.eventsource=a.transports.eventsource||{};d[b]=d[b]||new this(a,b);return d[b]}});Faye.extend(Faye.Transport.EventSource.prototype,Faye.Deferrable);Faye.Transport.register('eventsource',Faye.Transport.EventSource);Faye.Transport.XHR=Faye.extend(Faye.Class(Faye.Transport,{request:function(f,g){var h=this.retry(f,g),i=Faye.URI.parse(this.endpoint).pathname,k=this,j=Faye.ENV.ActiveXObject?new ActiveXObject("Microsoft.XMLHTTP"):new XMLHttpRequest();j.open('POST',i,true);j.setRequestHeader('Content-Type','application/json');j.setRequestHeader('Pragma','no-cache');j.setRequestHeader('X-Requested-With','XMLHttpRequest');var l=this.headers;for(var n in l){if(!l.hasOwnProperty(n))continue;j.setRequestHeader(n,l[n])}var o=function(){j.abort()};Faye.Event.on(Faye.ENV,'beforeunload',o);var m=function(){Faye.Event.detach(Faye.ENV,'beforeunload',o);j.onreadystatechange=function(){};j=null};j.onreadystatechange=function(){if(j.readyState!==4)return;var a=null,b=j.status,d=((b>=200&&b<300)||b===304||b===1223);if(!d){m();h();return k.trigger('down')}try{a=JSON.parse(j.responseText)}catch(e){}m();if(a){k.receive(a);k.trigger('up')}else{h();k.trigger('down')}};j.send(Faye.toJSON(f))}}),{isUsable:function(a,b,d,f){d.call(f,Faye.URI.parse(b).isSameOrigin())}});Faye.Transport.register('long-polling',Faye.Transport.XHR);Faye.Transport.CORS=Faye.extend(Faye.Class(Faye.Transport,{request:function(b,d){var f=Faye.ENV.XDomainRequest?XDomainRequest:XMLHttpRequest,g=new f(),h=this.retry(b,d),i=this;g.open('POST',this.endpoint,true);if(g.setRequestHeader)g.setRequestHeader('Pragma','no-cache');var k=function(){if(!g)return false;g.onload=g.onerror=g.ontimeout=g.onprogress=null;g=null;Faye.ENV.clearTimeout(l);return true};g.onload=function(){var a=null;try{a=JSON.parse(g.responseText)}catch(e){}k();if(a){i.receive(a);i.trigger('up')}else{h();i.trigger('down')}};var j=function(){k();h();i.trigger('down')};var l=Faye.ENV.setTimeout(j,1.5*1000*d);g.onerror=j;g.ontimeout=j;g.onprogress=function(){};g.send('message='+encodeURIComponent(Faye.toJSON(b)))}}),{isUsable:function(a,b,d,f){if(Faye.URI.parse(b).isSameOrigin())return d.call(f,false);if(Faye.ENV.XDomainRequest)return d.call(f,Faye.URI.parse(b).protocol===Faye.URI.parse(Faye.ENV.location).protocol);if(Faye.ENV.XMLHttpRequest){var g=new Faye.ENV.XMLHttpRequest();return d.call(f,g.withCredentials!==undefined)}return d.call(f,false)}});Faye.Transport.register('cross-origin-long-polling',Faye.Transport.CORS);Faye.Transport.JSONP=Faye.extend(Faye.Class(Faye.Transport,{shouldFlush:function(a){var b={message:Faye.toJSON(a),jsonp:'__jsonp'+Faye.Transport.JSONP._v+'__'};var d=Faye.URI.parse(this.endpoint,b).toURL();return d.length>=Faye.Transport.MAX_URL_LENGTH},request:function(b,d){var f={message:Faye.toJSON(b)},g=document.getElementsByTagName('head')[0],h=document.createElement('script'),i=Faye.Transport.JSONP.getCallbackName(),k=Faye.URI.parse(this.endpoint,f),j=this.retry(b,d),l=this;Faye.ENV[i]=function(a){o();l.receive(a);l.trigger('up')};var n=Faye.ENV.setTimeout(function(){o();j();l.trigger('down')},1.5*1000*d);var o=function(){if(!Faye.ENV[i])return false;Faye.ENV[i]=undefined;try{delete Faye.ENV[i]}catch(e){}Faye.ENV.clearTimeout(n);h.parentNode.removeChild(h);return true};k.params.jsonp=i;h.type='text/javascript';h.src=k.toURL();g.appendChild(h)}}),{_v:0,getCallbackName:function(){this._v+=1;return'__jsonp'+this._v+'__'},isUsable:function(a,b,d,f){d.call(f,true)}});Faye.Transport.register('callback-polling',Faye.Transport.JSONP);
//@ sourceMappingURL=faye-browser-min.js.map/** @license MIT License (c) copyright B Cavalier & J Hann */

/**
 * when
 * A lightweight CommonJS Promises/A and when() implementation
 *
 * when is part of the cujo.js family of libraries (http://cujojs.com/)
 *
 * Licensed under the MIT License at:
 * http://www.opensource.org/licenses/mit-license.php
 *
 * @version 1.3.0
 */

(function(define) {
define(function() {
	var freeze, reduceArray, slice, undef;

	//
	// Public API
	//

	when.defer     = defer;
	when.reject    = reject;
	when.isPromise = isPromise;

	when.all       = all;
	when.some      = some;
	when.any       = any;

	when.map       = map;
	when.reduce    = reduce;

	when.chain     = chain;

	/** Object.freeze */
	freeze = Object.freeze || function(o) { return o; };

	/**
	 * Trusted Promise constructor.  A Promise created from this constructor is
	 * a trusted when.js promise.  Any other duck-typed promise is considered
	 * untrusted.
	 *
	 * @constructor
	 */
	function Promise() {}

	Promise.prototype = freeze({
		always: function(alwaysback, progback) {
			return this.then(alwaysback, alwaysback, progback);
		},

		otherwise: function(errback) {
			return this.then(undef, errback);
		}
	});

	/**
	 * Create an already-resolved promise for the supplied value
	 * @private
	 *
	 * @param value anything
	 * @return {Promise}
	 */
	function resolved(value) {

		var p = new Promise();

		p.then = function(callback) {
			try {
				return promise(callback ? callback(value) : value);
			} catch(e) {
				return rejected(e);
			}
		};

		return freeze(p);
	}

	/**
	 * Create an already-rejected {@link Promise} with the supplied
	 * rejection reason.
	 * @private
	 *
	 * @param reason rejection reason
	 * @return {Promise}
	 */
	function rejected(reason) {

		var p = new Promise();

		p.then = function(callback, errback) {
			try {
				return errback ? promise(errback(reason)) : rejected(reason);
			} catch(e) {
				return rejected(e);
			}
		};

		return freeze(p);
	}

	/**
	 * Returns a rejected promise for the supplied promiseOrValue. If
	 * promiseOrValue is a value, it will be the rejection value of the
	 * returned promise.  If promiseOrValue is a promise, its
	 * completion value will be the rejected value of the returned promise
	 *
	 * @param promiseOrValue {*} the rejected value of the returned {@link Promise}
	 *
	 * @return {Promise} rejected {@link Promise}
	 */
	function reject(promiseOrValue) {
		return when(promiseOrValue, function(value) {
			return rejected(value);
		});
	}

	/**
	 * Creates a new, CommonJS compliant, Deferred with fully isolated
	 * resolver and promise parts, either or both of which may be given out
	 * safely to consumers.
	 * The Deferred itself has the full API: resolve, reject, progress, and
	 * then. The resolver has resolve, reject, and progress.  The promise
	 * only has then.
	 *
	 * @memberOf when
	 * @function
	 *
	 * @returns {Deferred}
	 */
	function defer() {
		var deferred, promise, listeners, progressHandlers, _then, _progress, complete;

		listeners = [];
		progressHandlers = [];

		/**
		 * Pre-resolution then() that adds the supplied callback, errback, and progback
		 * functions to the registered listeners
		 *
		 * @private
		 *
		 * @param [callback] {Function} resolution handler
		 * @param [errback] {Function} rejection handler
		 * @param [progback] {Function} progress handler
		 *
		 * @throws {Error} if any argument is not null, undefined, or a Function
		 */
		_then = function unresolvedThen(callback, errback, progback) {
			var deferred = defer();

			listeners.push(function(promise) {
				promise.then(callback, errback)
					.then(deferred.resolve, deferred.reject, deferred.progress);
			});

			progback && progressHandlers.push(progback);

			return deferred.promise;
		};

		/**
		 * Registers a handler for this {@link Deferred}'s {@link Promise}.  Even though all arguments
		 * are optional, each argument that *is* supplied must be null, undefined, or a Function.
		 * Any other value will cause an Error to be thrown.
		 *
		 * @memberOf Promise
		 *
		 * @param [callback] {Function} resolution handler
		 * @param [errback] {Function} rejection handler
		 * @param [progback] {Function} progress handler
		 *
		 * @throws {Error} if any argument is not null, undefined, or a Function
		 */
		function then(callback, errback, progback) {
			return _then(callback, errback, progback);
		}

		/**
		 * Resolves this {@link Deferred}'s {@link Promise} with val as the
		 * resolution value.
		 *
		 * @memberOf Resolver
		 *
		 * @param val anything
		 */
		function resolve(val) {
			complete(resolved(val));
		}

		/**
		 * Rejects this {@link Deferred}'s {@link Promise} with err as the
		 * reason.
		 *
		 * @memberOf Resolver
		 *
		 * @param err anything
		 */
		function reject(err) {
			complete(rejected(err));
		}

		/**
		 * @private
		 * @param update
		 */
		_progress = function(update) {
			var progress, i = 0;
			while (progress = progressHandlers[i++]) progress(update);
		};

		/**
		 * Emits a progress update to all progress observers registered with
		 * this {@link Deferred}'s {@link Promise}
		 *
		 * @memberOf Resolver
		 *
		 * @param update anything
		 */
		function progress(update) {
			_progress(update);
		}

		/**
		 * Transition from pre-resolution state to post-resolution state, notifying
		 * all listeners of the resolution or rejection
		 *
		 * @private
		 *
		 * @param completed {Promise} the completed value of this deferred
		 */
		complete = function(completed) {
			var listener, i = 0;

			// Replace _then with one that directly notifies with the result.
			_then = completed.then;

			// Replace complete so that this Deferred can only be completed
			// once. Also Replace _progress, so that subsequent attempts to issue
			// progress throw.
			complete = _progress = function alreadyCompleted() {
				// TODO: Consider silently returning here so that parties who
				// have a reference to the resolver cannot tell that the promise
				// has been resolved using try/catch
				throw new Error("already completed");
			};

			// Free progressHandlers array since we'll never issue progress events
			// for this promise again now that it's completed
			progressHandlers = undef;

			// Notify listeners
			// Traverse all listeners registered directly with this Deferred

			while (listener = listeners[i++]) {
				listener(completed);
			}

			listeners = [];
		};

		/**
		 * The full Deferred object, with both {@link Promise} and {@link Resolver}
		 * parts
		 * @class Deferred
		 * @name Deferred
		 */
		deferred = {};

		// Promise and Resolver parts
		// Freeze Promise and Resolver APIs

		promise = new Promise();
		promise.then = deferred.then = then;

		/**
		 * The {@link Promise} for this {@link Deferred}
		 * @memberOf Deferred
		 * @name promise
		 * @type {Promise}
		 */
		deferred.promise = freeze(promise);

		/**
		 * The {@link Resolver} for this {@link Deferred}
		 * @memberOf Deferred
		 * @name resolver
		 * @class Resolver
		 */
		deferred.resolver = freeze({
			resolve:  (deferred.resolve  = resolve),
			reject:   (deferred.reject   = reject),
			progress: (deferred.progress = progress)
		});

		return deferred;
	}

	/**
	 * Determines if promiseOrValue is a promise or not.  Uses the feature
	 * test from http://wiki.commonjs.org/wiki/Promises/A to determine if
	 * promiseOrValue is a promise.
	 *
	 * @param promiseOrValue anything
	 *
	 * @returns {Boolean} true if promiseOrValue is a {@link Promise}
	 */
	function isPromise(promiseOrValue) {
		return promiseOrValue && typeof promiseOrValue.then === 'function';
	}

	/**
	 * Register an observer for a promise or immediate value.
	 *
	 * @function
	 * @name when
	 * @namespace
	 *
	 * @param promiseOrValue anything
	 * @param {Function} [callback] callback to be called when promiseOrValue is
	 *   successfully resolved.  If promiseOrValue is an immediate value, callback
	 *   will be invoked immediately.
	 * @param {Function} [errback] callback to be called when promiseOrValue is
	 *   rejected.
	 * @param {Function} [progressHandler] callback to be called when progress updates
	 *   are issued for promiseOrValue.
	 *
	 * @returns {Promise} a new {@link Promise} that will complete with the return
	 *   value of callback or errback or the completion value of promiseOrValue if
	 *   callback and/or errback is not supplied.
	 */
	function when(promiseOrValue, callback, errback, progressHandler) {
		// Get a promise for the input promiseOrValue
		// See promise()
		var trustedPromise = promise(promiseOrValue);

		// Register promise handlers
		return trustedPromise.then(callback, errback, progressHandler);
	}

	/**
	 * Returns promiseOrValue if promiseOrValue is a {@link Promise}, a new Promise if
	 * promiseOrValue is a foreign promise, or a new, already-resolved {@link Promise}
	 * whose resolution value is promiseOrValue if promiseOrValue is an immediate value.
	 *
	 * Note that this function is not safe to export since it will return its
	 * input when promiseOrValue is a {@link Promise}
	 *
	 * @private
	 *
	 * @param promiseOrValue anything
	 *
	 * @returns Guaranteed to return a trusted Promise.  If promiseOrValue is a when.js {@link Promise}
	 *   returns promiseOrValue, otherwise, returns a new, already-resolved, when.js {@link Promise}
	 *   whose resolution value is:
	 *   * the resolution value of promiseOrValue if it's a foreign promise, or
	 *   * promiseOrValue if it's a value
	 */
	function promise(promiseOrValue) {
		var promise, deferred;

		if(promiseOrValue instanceof Promise) {
			// It's a when.js promise, so we trust it
			promise = promiseOrValue;

		} else {
			// It's not a when.js promise.  Check to see if it's a foreign promise
			// or a value.

			deferred = defer();
			if(isPromise(promiseOrValue)) {
				// It's a compliant promise, but we don't know where it came from,
				// so we don't trust its implementation entirely.  Introduce a trusted
				// middleman when.js promise

				// IMPORTANT: This is the only place when.js should ever call .then() on
				// an untrusted promise.
				promiseOrValue.then(deferred.resolve, deferred.reject, deferred.progress);
				promise = deferred.promise;

			} else {
				// It's a value, not a promise.  Create an already-resolved promise
				// for it.
				deferred.resolve(promiseOrValue);
				promise = deferred.promise;
			}
		}

		return promise;
	}

	/**
	 * Return a promise that will resolve when howMany of the supplied promisesOrValues
	 * have resolved. The resolution value of the returned promise will be an array of
	 * length howMany containing the resolutions values of the triggering promisesOrValues.
	 *
	 * @memberOf when
	 *
	 * @param promisesOrValues {Array} array of anything, may contain a mix
	 *      of {@link Promise}s and values
	 * @param howMany
	 * @param [callback]
	 * @param [errback]
	 * @param [progressHandler]
	 *
	 * @returns {Promise}
	 */
	function some(promisesOrValues, howMany, callback, errback, progressHandler) {

		checkCallbacks(2, arguments);

		return when(promisesOrValues, function(promisesOrValues) {

			var toResolve, results, ret, deferred, resolver, rejecter, handleProgress, len, i;

			len = promisesOrValues.length >>> 0;

			toResolve = Math.max(0, Math.min(howMany, len));
			results = [];
			deferred = defer();
			ret = when(deferred, callback, errback, progressHandler);

			// Wrapper so that resolver can be replaced
			function resolve(val) {
				resolver(val);
			}

			// Wrapper so that rejecter can be replaced
			function reject(err) {
				rejecter(err);
			}

			// Wrapper so that progress can be replaced
			function progress(update) {
				handleProgress(update);
			}

			function complete() {
				resolver = rejecter = handleProgress = noop;
			}

			// No items in the input, resolve immediately
			if (!toResolve) {
				deferred.resolve(results);

			} else {
				// Resolver for promises.  Captures the value and resolves
				// the returned promise when toResolve reaches zero.
				// Overwrites resolver var with a noop once promise has
				// be resolved to cover case where n < promises.length
				resolver = function(val) {
					// This orders the values based on promise resolution order
					// Another strategy would be to use the original position of
					// the corresponding promise.
					results.push(val);

					if (!--toResolve) {
						complete();
						deferred.resolve(results);
					}
				};

				// Rejecter for promises.  Rejects returned promise
				// immediately, and overwrites rejecter var with a noop
				// once promise to cover case where n < promises.length.
				// TODO: Consider rejecting only when N (or promises.length - N?)
				// promises have been rejected instead of only one?
				rejecter = function(err) {
					complete();
					deferred.reject(err);
				};

				handleProgress = deferred.progress;

				// TODO: Replace while with forEach
				for(i = 0; i < len; ++i) {
					if(i in promisesOrValues) {
						when(promisesOrValues[i], resolve, reject, progress);
					}
				}
			}

			return ret;
		});
	}

	/**
	 * Return a promise that will resolve only once all the supplied promisesOrValues
	 * have resolved. The resolution value of the returned promise will be an array
	 * containing the resolution values of each of the promisesOrValues.
	 *
	 * @memberOf when
	 *
	 * @param promisesOrValues {Array|Promise} array of anything, may contain a mix
	 *      of {@link Promise}s and values
	 * @param [callback] {Function}
	 * @param [errback] {Function}
	 * @param [progressHandler] {Function}
	 *
	 * @returns {Promise}
	 */
	function all(promisesOrValues, callback, errback, progressHandler) {

		checkCallbacks(1, arguments);

		return when(promisesOrValues, function(promisesOrValues) {
			return _reduce(promisesOrValues, reduceIntoArray, []);
		}).then(callback, errback, progressHandler);
	}

	function reduceIntoArray(current, val, i) {
		current[i] = val;
		return current;
	}

	/**
	 * Return a promise that will resolve when any one of the supplied promisesOrValues
	 * has resolved. The resolution value of the returned promise will be the resolution
	 * value of the triggering promiseOrValue.
	 *
	 * @memberOf when
	 *
	 * @param promisesOrValues {Array|Promise} array of anything, may contain a mix
	 *      of {@link Promise}s and values
	 * @param [callback] {Function}
	 * @param [errback] {Function}
	 * @param [progressHandler] {Function}
	 *
	 * @returns {Promise}
	 */
	function any(promisesOrValues, callback, errback, progressHandler) {

		function unwrapSingleResult(val) {
			return callback ? callback(val[0]) : val[0];
		}

		return some(promisesOrValues, 1, unwrapSingleResult, errback, progressHandler);
	}

	/**
	 * Traditional map function, similar to `Array.prototype.map()`, but allows
	 * input to contain {@link Promise}s and/or values, and mapFunc may return
	 * either a value or a {@link Promise}
	 *
	 * @memberOf when
	 *
	 * @param promise {Array|Promise} array of anything, may contain a mix
	 *      of {@link Promise}s and values
	 * @param mapFunc {Function} mapping function mapFunc(value) which may return
	 *      either a {@link Promise} or value
	 *
	 * @returns {Promise} a {@link Promise} that will resolve to an array containing
	 *      the mapped output values.
	 */
	function map(promise, mapFunc) {
		return when(promise, function(array) {
			return _map(array, mapFunc);
		});
	}

	/**
	 * Private map helper to map an array of promises
	 * @private
	 *
	 * @param promisesOrValues {Array}
	 * @param mapFunc {Function}
	 * @return {Promise}
	 */
	function _map(promisesOrValues, mapFunc) {

		var results, len, i;

		// Since we know the resulting length, we can preallocate the results
		// array to avoid array expansions.
		len = promisesOrValues.length >>> 0;
		results = new Array(len);

		// Since mapFunc may be async, get all invocations of it into flight
		// asap, and then use reduce() to collect all the results
		for(i = 0; i < len; i++) {
			if(i in promisesOrValues)
				results[i] = when(promisesOrValues[i], mapFunc);
		}

		// Could use all() here, but that would result in another array
		// being allocated, i.e. map() would end up allocating 2 arrays
		// of size len instead of just 1.  Since all() uses reduce()
		// anyway, avoid the additional allocation by calling reduce
		// directly.
		return _reduce(results, reduceIntoArray, results);
	}

	/**
	 * Traditional reduce function, similar to `Array.prototype.reduce()`, but
	 * input may contain {@link Promise}s and/or values, and reduceFunc
	 * may return either a value or a {@link Promise}, *and* initialValue may
	 * be a {@link Promise} for the starting value.
	 *
	 * @memberOf when
	 *
	 * @param promise {Array|Promise} array of anything, may contain a mix
	 *      of {@link Promise}s and values.  May also be a {@link Promise} for
	 *      an array.
	 * @param reduceFunc {Function} reduce function reduce(currentValue, nextValue, index, total),
	 *      where total is the total number of items being reduced, and will be the same
	 *      in each call to reduceFunc.
	 * @param initialValue starting value, or a {@link Promise} for the starting value
	 *
	 * @returns {Promise} that will resolve to the final reduced value
	 */
	function reduce(promise, reduceFunc, initialValue) {
		var args = slice.call(arguments, 1);
		return when(promise, function(array) {
			return _reduce.apply(undef, [array].concat(args));
		});
	}

	/**
	 * Private reduce to reduce an array of promises
	 * @private
	 *
	 * @param promisesOrValues {Array}
	 * @param reduceFunc {Function}
	 * @param initialValue {*}
	 * @return {Promise}
	 */
	function _reduce(promisesOrValues, reduceFunc, initialValue) {

		var total, args;

		total = promisesOrValues.length;

		// Skip promisesOrValues, since it will be used as 'this' in the call
		// to the actual reduce engine below.

		// Wrap the supplied reduceFunc with one that handles promises and then
		// delegates to the supplied.

		args = [
			function (current, val, i) {
				return when(current, function (c) {
					return when(val, function (value) {
						return reduceFunc(c, value, i, total);
					});
				});
			}
		];

		if (arguments.length > 2) args.push(initialValue);

		return reduceArray.apply(promisesOrValues, args);
	}

	/**
	 * Ensure that resolution of promiseOrValue will complete resolver with the completion
	 * value of promiseOrValue, or instead with resolveValue if it is provided.
	 *
	 * @memberOf when
	 *
	 * @param promiseOrValue
	 * @param resolver {Resolver}
	 * @param [resolveValue] anything
	 *
	 * @returns {Promise}
	 */
	function chain(promiseOrValue, resolver, resolveValue) {
		var useResolveValue = arguments.length > 2;

		return when(promiseOrValue,
			function(val) {
				if(useResolveValue) val = resolveValue;
				resolver.resolve(val);
				return val;
			},
			function(e) {
				resolver.reject(e);
				return rejected(e);
			},
			resolver.progress
		);
	}

	//
	// Utility functions
	//

	/**
	 * Helper that checks arrayOfCallbacks to ensure that each element is either
	 * a function, or null or undefined.
	 *
	 * @private
	 *
	 * @param arrayOfCallbacks {Array} array to check
	 * @throws {Error} if any element of arrayOfCallbacks is something other than
	 * a Functions, null, or undefined.
	 */
	function checkCallbacks(start, arrayOfCallbacks) {
		var arg, i = arrayOfCallbacks.length;
		while(i > start) {
			arg = arrayOfCallbacks[--i];
			if (arg != null && typeof arg != 'function') throw new Error('callback is not a function');
		}
	}

	/**
	 * No-Op function used in method replacement
	 * @private
	 */
	function noop() {}

	slice = [].slice;

	// ES5 reduce implementation if native not available
	// See: http://es5.github.com/#x15.4.4.21 as there are many
	// specifics and edge cases.
	reduceArray = [].reduce ||
		function(reduceFunc /*, initialValue */) {
			// ES5 dictates that reduce.length === 1

			// This implementation deviates from ES5 spec in the following ways:
			// 1. It does not check if reduceFunc is a Callable

			var arr, args, reduced, len, i;

			i = 0;
			arr = Object(this);
			len = arr.length >>> 0;
			args = arguments;

			// If no initialValue, use first item of array (we know length !== 0 here)
			// and adjust i to start at second item
			if(args.length <= 1) {
				// Skip to the first real element in the array
				for(;;) {
					if(i in arr) {
						reduced = arr[i++];
						break;
					}

					// If we reached the end of the array without finding any real
					// elements, it's a TypeError
					if(++i >= len) {
						throw new TypeError();
					}
				}
			} else {
				// If initialValue provided, use it
				reduced = args[1];
			}

			// Do the actual reduce
			for(;i < len; ++i) {
				// Skip holes
				if(i in arr)
					reduced = reduceFunc(reduced, arr[i], i, arr);
			}

			return reduced;
		};

	return when;
});
})(typeof define == 'function'
	? define
	: function (factory) { typeof module != 'undefined'
		? (module.exports = factory())
		: (this.when      = factory());
	}
	// Boilerplate for AMD, Node, and browser global
);
//     uuid.js
//
//     (c) 2010-2012 Robert Kieffer
//     MIT License
//     https://github.com/broofa/node-uuid
(function() {
  var _global = this;

  // Unique ID creation requires a high quality random # generator.  We feature
  // detect to determine the best RNG source, normalizing to a function that
  // returns 128-bits of randomness, since that's what's usually required
  var _rng;

  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
  //
  // Moderately fast, high quality
  if (typeof(require) == 'function') {
    try {
      var _rb = require('crypto').randomBytes;
      _rng = _rb && function() {return _rb(16);};
    } catch(e) {}
  }

  if (!_rng && _global.crypto && crypto.getRandomValues) {
    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
    //
    // Moderately fast, high quality
    var _rnds8 = new Uint8Array(16);
    _rng = function whatwgRNG() {
      crypto.getRandomValues(_rnds8);
      return _rnds8;
    };
  }

  if (!_rng) {
    // Math.random()-based (RNG)
    //
    // If all else fails, use Math.random().  It's fast, but is of unspecified
    // quality.
    var  _rnds = new Array(16);
    _rng = function() {
      for (var i = 0, r; i < 16; i++) {
        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
      }

      return _rnds;
    };
  }

  // Buffer class to use
  var BufferClass = typeof(Buffer) == 'function' ? Buffer : Array;

  // Maps for number <-> hex string conversion
  var _byteToHex = [];
  var _hexToByte = {};
  for (var i = 0; i < 256; i++) {
    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
    _hexToByte[_byteToHex[i]] = i;
  }

  // **`parse()` - Parse a UUID into it's component bytes**
  function parse(s, buf, offset) {
    var i = (buf && offset) || 0, ii = 0;

    buf = buf || [];
    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
      if (ii < 16) { // Don't overflow!
        buf[i + ii++] = _hexToByte[oct];
      }
    });

    // Zero out remaining bytes if string was short
    while (ii < 16) {
      buf[i + ii++] = 0;
    }

    return buf;
  }

  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
  function unparse(buf, offset) {
    var i = offset || 0, bth = _byteToHex;
    return  bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]];
  }

  // **`v1()` - Generate time-based UUID**
  //
  // Inspired by https://github.com/LiosK/UUID.js
  // and http://docs.python.org/library/uuid.html

  // random #'s we need to init node and clockseq
  var _seedBytes = _rng();

  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
  var _nodeId = [
    _seedBytes[0] | 0x01,
    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
  ];

  // Per 4.2.2, randomize (14 bit) clockseq
  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

  // Previous uuid creation time
  var _lastMSecs = 0, _lastNSecs = 0;

  // See https://github.com/broofa/node-uuid for API details
  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];

    options = options || {};

    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;

    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    var msecs = options.msecs != null ? options.msecs : new Date().getTime();

    // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock
    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;

    // Time since last uuid creation (in msecs)
    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

    // Per 4.2.1.2, Bump clockseq on clock regression
    if (dt < 0 && options.clockseq == null) {
      clockseq = clockseq + 1 & 0x3fff;
    }

    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
      nsecs = 0;
    }

    // Per 4.2.1.2 Throw error if too many uuids are requested
    if (nsecs >= 10000) {
      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
    }

    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;

    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    msecs += 12219292800000;

    // `time_low`
    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff;

    // `time_mid`
    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff;

    // `time_high_and_version`
    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
    b[i++] = tmh >>> 16 & 0xff;

    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    b[i++] = clockseq >>> 8 | 0x80;

    // `clock_seq_low`
    b[i++] = clockseq & 0xff;

    // `node`
    var node = options.node || _nodeId;
    for (var n = 0; n < 6; n++) {
      b[i + n] = node[n];
    }

    return buf ? buf : unparse(b);
  }

  // **`v4()` - Generate random UUID**

  // See https://github.com/broofa/node-uuid for API details
  function v4(options, buf, offset) {
    // Deprecated - 'format' argument, as supported in v1.2
    var i = buf && offset || 0;

    if (typeof(options) == 'string') {
      buf = options == 'binary' ? new BufferClass(16) : null;
      options = null;
    }
    options = options || {};

    var rnds = options.random || (options.rng || _rng)();

    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;

    // Copy bytes to buffer, if provided
    if (buf) {
      for (var ii = 0; ii < 16; ii++) {
        buf[i + ii] = rnds[ii];
      }
    }

    return buf || unparse(rnds);
  }

  // Export public API
  var uuid = v4;
  uuid.v1 = v1;
  uuid.v4 = v4;
  uuid.parse = parse;
  uuid.unparse = unparse;
  uuid.BufferClass = BufferClass;

  if (_global.define && define.amd) {
    // Publish as AMD module
    define(function() {return uuid;});
  } else if (typeof(module) != 'undefined' && module.exports) {
    // Publish as node.js module
    module.exports = uuid;
  } else {
    // Publish as global (in browsers)
    var _previousRoot = _global.uuid;

    // **`noConflict()` - (browser only) to reset global 'uuid' var**
    uuid.noConflict = function() {
      _global.uuid = _previousRoot;
      return uuid;
    };

    _global.uuid = uuid;
  }
}());
(typeof require === "function" && typeof module === "object" ? 
 function (m) {
     module.exports = m(require("faye"), require("when"), require("node-uuid"));
 } :
 function (m) {
     if (!this.buster) { this.buster = {}; }
     if (!this.buster.captureServer) { this.buster.captureServer = {}; }
     this.buster.captureServer.PubSubClient = m(Faye, when, uuid);
 })(function (Faye, when, uuid) {
    var NOOP = function NOOP() {};
    var PUBLIC_METHODS = ["connect", "disconnect", "on", "emit"];
    var EVENT_NAME_RE = /^[a-z0-9\-\_\!\~\(\)\$\@\:]+$/i;

    function PubSubClient(opts) {
        if (opts._fayeClient) {
            this._fayeClient = opts._fayeClient;
        } else {
            this._serverHost = opts.host || "127.0.0.1";
            this._serverPort = opts.port;
            this._fayeClient = this._createFayeClient();
            this._hasOwnFayeClient = true;
        }
        this._contextPath = opts.contextPath || "";
        this.id = uuid();
        this.connectionId = this.id;
        this._onConnect = opts.onConnect || NOOP;
        this._subscriptions = [];

        function delegateMethod(self, meth) {
            var impl = self[meth];
            self[meth] = function () {
                return impl.apply(self, arguments);
            };
        }

        // TODO: find a way to test this. Currently untested.
        var i, ii;
        for (i = 0, ii = PUBLIC_METHODS.length; i < ii; i++) {
            delegateMethod(this, PUBLIC_METHODS[i]);
        }
    }

    PubSubClient.prototype = {
        connect: function () {
            var self = this;
            var deferred = when.defer();

            var initPath = "/initialize/" + this.id;
            this._fayeClient.subscribe(initPath, function () {
                self._fayeClient.unsubscribe(initPath);
                self._onConnect();
                deferred.resolve();
            }).callback(function () {
                self._fayeClient.publish(initPath, {id: self.connectionId});
            });

            // TODO: Handle timeout
            return deferred.promise;
        },

        disconnect: function () {
            if (this._hasOwnFayeClient) {
                this._fayeClient.disconnect();
            }
        },

        on: function (eventName, handler) {
            var path, _handler;

            if (arguments.length === 1) {
                handler = eventName;
                path = this._contextPath + "/user/**";
                _handler = function (e) { handler(e.eventName, e.data); };
            } else {
                path = this._contextPath + this._getEventName(eventName);
                _handler = function (e) { handler(e.data); };
            }

            var subscription = this._fayeClient.subscribe(path, _handler);
            this._subscriptions.push(subscription);
        },

        emit: function (eventName, data) {
            var path = this._contextPath + this._getEventName(eventName);
            this._fayeClient.publish(path, {
                data: data,
                eventName: eventName
            });
        },

        inherit: function (contextPath) {
            if (contextPath.length === 0) {
                throw new Error("Must set a context path");
            }

            var pubsubClient = new PubSubClient({
                _fayeClient: this._fayeClient,
                contextPath: contextPath
            });
            pubsubClient.connectionId = this.connectionId;
            return pubsubClient;
        },

        teardown: function () {
            this._subscriptions.forEach(function (s) { s.cancel(); });
        },

        _getEventName: function (eventName) {
            if (!EVENT_NAME_RE.test(eventName)) {
                throw new TypeError("Event name must match " + EVENT_NAME_RE);
            }

            return "/user/" + eventName
                .replace(/-/g, "--")
                .replace(/:/g, "-");
        },

        _createFayeClient: function () {
            var url = "http://" + this._serverHost + ":" +
                this._serverPort + "/messaging";

            return new Faye.Client(url, {
                retry: 0.5,
                timeout: 1
            });
        }
    };

    return PubSubClient;
});
if (typeof module === "object" && typeof require === "function") {
    var bane = require("bane");
    var when = require("when");
    var buster = {};
}

(function () {
    var STATES = [["started", "onStart"],
                  ["loaded", "onLoad"],
                  ["ended", "onEnd"],
                  ["unloaded", "onUnload"]];

    function SessionClient(session, serverPubsub, opts) {
        this.sessionId = session.id;
        this.resourcesPath = session.resourcesPath;
        this.thisId = this.sessionId;
        this._opts = opts || {};
        this._pubsubClient = serverPubsub.inherit(session.messagingPath);
        this._privatePubsubClient = serverPubsub.inherit(
            session.privateMessagingPath
        );
        this._setUpPrivatePubsubClient();
        this._privateEventEmitter = bane.createEventEmitter();
        this.on = this._pubsubClient.on;
        this._onAbortDeferred = when.defer();
        this._stateDeferreds = {};

        function delegate(self, state) {
            var stateName = state[0];
            var handlerName = state[1];

            var deferred = when.defer();
            self._stateDeferreds[stateName] = deferred;
            self[handlerName] = function () {
                deferred.promise.then.apply(deferred.promise, arguments);
            };
        }

        var i, ii;
        for (i = 0, ii = STATES.length; i < ii; i++) {
            delegate(this, STATES[i]);
        }
    }

    buster.captureServer = buster.captureServer || {};
    buster.captureServer.SessionClient = SessionClient;
    SessionClient.prototype = {
        emit: function (event, data) {
            this._pubsubClient.emit(event, {
                data: data,
                clientId: this.clientId
            });
        },

        end: function () {
            var deferred = when.defer();
            this._privatePubsubClient.emit("end");
            this.onEnd(deferred.resolve, deferred.reject);
            return deferred.promise;
        },

        onSlaveFreed: function (func) {
            this._privateEventEmitter.on("slave:freed", func);
        },

        onAbort: function (func) {
            this._onAbortDeferred.then(func);
        },

        _setUpPrivatePubsubClient: function () {
            var self = this;

            this._privatePubsubClient.on("state", function (e) {
                self._setAborted(e.aborted);
                self._setState(e.state);
            });

            this._privatePubsubClient.on("slave:freed", function (e) {
                self._privateEventEmitter.emit("slave:freed", {
                    slave: e.slave,
                    slaves: e.slaves
                });
            });

            this._privatePubsubClient.emit("initialize");
        },

        _setAborted: function (err) {
            if (!err) { return; }
            if (this._hasAborted) { return; }

            this._hasAborted = true;
            this._onAbortDeferred.resolve({error: err});
        },

        _setState: function (states) {
            var state;
            for (state in states) {
                if (states[state].reached) {
                    this._resolveToState(state, states);
                }
            }
        },

        _resolveToState: function (toState, allStates) {
            var i, ii;
            for (i = 0, ii = STATES.length; i < ii; i++) {
                var state = STATES[i];
                var stateName = state[0];
                var handlerName = state[1];

                var deferred = this._stateDeferreds[stateName];
                try {
                    deferred.resolve(allStates[stateName].data);
                } catch (e) {}
                if (stateName === toState) { break; }
            }
        }
    };

    if (typeof module === "object" && typeof require === "function") {
        module.exports = SessionClient;
    }
}());
if (!this.buster) { this.buster = {}; }

(function (buster) {
    buster.captureServer = buster.captureServer || {};
    buster.captureServer.prisonUtil = {
        addEventListener: function (element, event, handler) {
            if (element.addEventListener) {
                element.addEventListener(event, handler, false);
            } else if (element.attachEvent) {
                element.attachEvent("on" + event, handler);
            }
        },

        removeEventListener: function (element, event, handler) {
            if (element.removeEventListener) {
                element.removeEventListener(event, handler, false);
            } else if (element.detachEvent) {
                element.detachEvent("on" + event, handler);
            }
        },

        frame: function (el) {
            return {
                window: function () {
                    return el.contentWindow;
                },

                setSrc: function (src, onload) {
                    var wrappedHandler = function () {
                        buster.captureServer.prisonUtil
                            .removeEventListener(el, "load", wrappedHandler);
                        setTimeout(onload, 1);
                    };
                    buster.captureServer.prisonUtil
                        .addEventListener(el, "load", wrappedHandler);
                    el.src = src;
                }
            };
        }
    };
}(this.buster));
(function (B) {
    B.captureServer = B.captureServer || {};

    function Prison() {
        // TODO: Provide these somehow, so the browser doesn't
        // have to guess them.
        var l = window.location;
        var hostAndPort = /^[a-z]+:\/\/([^\/]+)/.exec(l)[1].split(":");
        var host = hostAndPort[0];
        var port = parseInt(hostAndPort[1] || "80", 10);
        this.slaveId = /^[a-z]+:\/\/[^\/]+\/slaves\/([^\/]+)/.exec(l)[1];
        this.capturePath = "http://" + host + ":" + port + "/capture";

        this.serverClient = new B.captureServer.PubSubClient({
            host: host,
            port: port
        });

    }

    Prison.prototype = B.captureServer.prison = {
        create: function () {
            return new Prison();
        },

        listen: function () {
            var self = this;
            var frameEl = document.getElementById("session_frame");
            var sessionFrame = B.captureServer.prisonUtil.frame(frameEl);

            var loadEvent = "slave:" + self.slaveId + ":session:load";
            var loadedEvent = "slave:" + self.slaveId + ":session:loaded";
            var unloadEvent = "slave:" + self.slaveId + ":session:unload";
            var unloadedEvent = "slave:" + self.slaveId + ":session:unloaded";

            this.serverClient.connect().then(function () {
                // TODO: Don't use the faye client directly for this
                self.serverClient._fayeClient.addExtension({
                    incoming: function (message, callback) {
                        var serverIsBackAfterRestart =
                            message.channel === "/meta/connect"
                            && message.successful === false
                            && (/^401/.test(message.error));

                        if (serverIsBackAfterRestart) {
                            window.location = self.capturePath;
                            return;
                        }
                        callback(message);
                    }
                });


                self.serverClient.on(loadEvent, function (session) {
                    self.currentSession = session;
                    self.sessionClient = new B.captureServer.SessionClient(
                        session,
                        self.serverClient
                    );
                    self.sessionClient.clientId = self.slaveId;

                    var path = session.resourcesPath + "/";
                    sessionFrame.setSrc(path, function () {
                        self.serverClient.emit(loadedEvent);
                    });
                });

                self.serverClient.on(unloadEvent, function () {
                    sessionFrame.setSrc("", function () {
                        self.serverClient.emit(unloadedEvent);
                    });
                });

                var event = "slave:" + self.slaveId + ":imprisoned";
                self.serverClient.emit(event, {
                    pubsubClientId: self.serverClient.id,
                    userAgent: navigator.userAgent
                });
            });
        },

        initSessionFrame: function (sessionBuster) {
            var self = this;

            sessionBuster.emit = function (event, data) {
                self.sessionClient.emit(event, data);
            };
            sessionBuster.on = function (event, handler) {
                self.sessionClient.on(event, handler);
            };

            sessionBuster.env = sessionBuster.env || {};
            sessionBuster.env.contextPath = this.currentSession.resourcesPath;
            sessionBuster.env.id = this.slaveId;
        }
    };
}(buster));
(function (B) {
    B.captureServer.prisonUtil.addEventListener(window, "load", function () {
        var prison = B.captureServer.prison.create();
        prison.listen();
        B.captureServer.sharedPrison = prison;
    });
}(buster));