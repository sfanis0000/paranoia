goog.provide('Zopfli');
// Note: For maximum-speed code, see "Optimizing Code" on the Emscripten wiki, https://github.com/kripken/emscripten/wiki/Optimizing-Code
// Note: Some Emscripten settings may limit the speed of the generated code.
try {
  this['Module'] = Module;
} catch(e) {
  this['Module'] = Module = {};
}

// The environment setup code below is customized to use Module.
// *** Environment setup code ***
var ENVIRONMENT_IS_NODE = typeof process === 'object' && typeof require === 'function';
var ENVIRONMENT_IS_WEB = typeof window === 'object';
var ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';
var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

if (ENVIRONMENT_IS_NODE) {
  // Expose functionality in the same simple way that the shells work
  // Note that we pollute the global namespace here, otherwise we break in node
  Module['print'] = function(x) {
    process['stdout'].write(x + '\n');
  };
  Module['printErr'] = function(x) {
    process['stderr'].write(x + '\n');
  };

  var nodeFS = require('fs');
  var nodePath = require('path');

  Module['read'] = function(filename) {
    filename = nodePath['normalize'](filename);
    var ret = nodeFS['readFileSync'](filename).toString();
    // The path is absolute if the normalized version is the same as the resolved.
    if (!ret && filename != nodePath['resolve'](filename)) {
      filename = path.join(__dirname, '..', 'src', filename);
      ret = nodeFS['readFileSync'](filename).toString();
    }
    return ret;
  };

  Module['load'] = function(f) {
    globalEval(read(f));
  };

  if (!Module['arguments']) {
    Module['arguments'] = process['argv'].slice(2);
  }
}

if (ENVIRONMENT_IS_SHELL) {
  Module['print'] = print;
  if (typeof printErr != 'undefined') Module['printErr'] = printErr; // not present in v8 or older sm

  // Polyfill over SpiderMonkey/V8 differences
  if (typeof read != 'undefined') {
    Module['read'] = read;
  } else {
    Module['read'] = function(f) { snarf(f) };
  }

  if (!Module['arguments']) {
    if (typeof scriptArgs != 'undefined') {
      Module['arguments'] = scriptArgs;
    } else if (typeof arguments != 'undefined') {
      Module['arguments'] = arguments;
    }
  }
}

if (ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER) {
  if (!Module['print']) {
    Module['print'] = function(x) {
      console.log(x);
    };
  }

  if (!Module['printErr']) {
    Module['printErr'] = function(x) {
      console.log(x);
    };
  }
}

if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  Module['read'] = function(url) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, false);
    xhr.send(null);
    return xhr.responseText;
  };

  if (!Module['arguments']) {
    if (typeof arguments != 'undefined') {
      Module['arguments'] = arguments;
    }
  }
}

if (ENVIRONMENT_IS_WORKER) {
  // We can do very little here...
  var TRY_USE_DUMP = false;
  if (!Module['print']) {
    Module['print'] = (TRY_USE_DUMP && (typeof(dump) !== "undefined") ? (function(x) {
      dump(x);
    }) : (function(x) {
      // self.postMessage(x); // enable this if you want stdout to be sent as messages
    }));
  }

  Module['load'] = importScripts;
}

if (!ENVIRONMENT_IS_WORKER && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_SHELL) {
  // Unreachable because SHELL is dependant on the others
  throw 'Unknown runtime environment. Where are we?';
}

function globalEval(x) {
  eval.call(null, x);
}
if (!Module['load'] == 'undefined' && Module['read']) {
  Module['load'] = function(f) {
    globalEval(Module['read'](f));
  };
}
if (!Module['print']) {
  Module['print'] = function(){};
}
if (!Module['printErr']) {
  Module['printErr'] = Module['print'];
}
if (!Module['arguments']) {
  Module['arguments'] = [];
}
// *** Environment setup code ***

// Closure helpers
Module.print = Module['print'];
Module.printErr = Module['printErr'];

// Callbacks
if (!Module['preRun']) Module['preRun'] = [];
if (!Module['postRun']) Module['postRun'] = [];

  
// === Auto-generated preamble library stuff ===

//========================================
// Runtime code shared with compiler
//========================================

var Runtime = {
  stackSave: function () {
    return STACKTOP;
  },
  stackRestore: function (stackTop) {
    STACKTOP = stackTop;
  },
  forceAlign: function (target, quantum) {
    quantum = quantum || 4;
    if (quantum == 1) return target;
    if (isNumber(target) && isNumber(quantum)) {
      return Math.ceil(target/quantum)*quantum;
    } else if (isNumber(quantum) && isPowerOfTwo(quantum)) {
      var logg = log2(quantum);
      return '((((' +target + ')+' + (quantum-1) + ')>>' + logg + ')<<' + logg + ')';
    }
    return 'Math.ceil((' + target + ')/' + quantum + ')*' + quantum;
  },
  isNumberType: function (type) {
    return type in Runtime.INT_TYPES || type in Runtime.FLOAT_TYPES;
  },
  isPointerType: function isPointerType(type) {
  return type[type.length-1] == '*';
},
  isStructType: function isStructType(type) {
  if (isPointerType(type)) return false;
  if (/^\[\d+\ x\ (.*)\]/.test(type)) return true; // [15 x ?] blocks. Like structs
  if (/<?{ ?[^}]* ?}>?/.test(type)) return true; // { i32, i8 } etc. - anonymous struct types
  // See comment in isStructPointerType()
  return type[0] == '%';
},
  INT_TYPES: {"i1":0,"i8":0,"i16":0,"i32":0,"i64":0},
  FLOAT_TYPES: {"float":0,"double":0},
  BITSHIFT64_SHL: 0,
  BITSHIFT64_ASHR: 1,
  BITSHIFT64_LSHR: 2,
  bitshift64: function (low, high, op, bits) {
    var ret;
    var ander = Math.pow(2, bits)-1;
    if (bits < 32) {
      switch (op) {
        case Runtime.BITSHIFT64_SHL:
          ret = [low << bits, (high << bits) | ((low&(ander << (32 - bits))) >>> (32 - bits))];
          break;
        case Runtime.BITSHIFT64_ASHR:
          ret = [(((low >>> bits ) | ((high&ander) << (32 - bits))) >> 0) >>> 0, (high >> bits) >>> 0];
          break;
        case Runtime.BITSHIFT64_LSHR:
          ret = [((low >>> bits) | ((high&ander) << (32 - bits))) >>> 0, high >>> bits];
          break;
      }
    } else if (bits == 32) {
      switch (op) {
        case Runtime.BITSHIFT64_SHL:
          ret = [0, low];
          break;
        case Runtime.BITSHIFT64_ASHR:
          ret = [high, (high|0) < 0 ? ander : 0];
          break;
        case Runtime.BITSHIFT64_LSHR:
          ret = [high, 0];
          break;
      }
    } else { // bits > 32
      switch (op) {
        case Runtime.BITSHIFT64_SHL:
          ret = [0, low << (bits - 32)];
          break;
        case Runtime.BITSHIFT64_ASHR:
          ret = [(high >> (bits - 32)) >>> 0, (high|0) < 0 ? ander : 0];
          break;
        case Runtime.BITSHIFT64_LSHR:
          ret = [high >>>  (bits - 32) , 0];
          break;
      }
    }
    HEAP32[tempDoublePtr>>2] = ret[0]; // cannot use utility functions since we are in runtime itself
    HEAP32[tempDoublePtr+4>>2] = ret[1];
  },
  or64: function (x, y) {
    var l = (x | 0) | (y | 0);
    var h = (Math.round(x / 4294967296) | Math.round(y / 4294967296)) * 4294967296;
    return l + h;
  },
  and64: function (x, y) {
    var l = (x | 0) & (y | 0);
    var h = (Math.round(x / 4294967296) & Math.round(y / 4294967296)) * 4294967296;
    return l + h;
  },
  xor64: function (x, y) {
    var l = (x | 0) ^ (y | 0);
    var h = (Math.round(x / 4294967296) ^ Math.round(y / 4294967296)) * 4294967296;
    return l + h;
  },
  getNativeTypeSize: function (type, quantumSize) {
    if (Runtime.QUANTUM_SIZE == 1) return 1;
    var size = {
      '%i1': 1,
      '%i8': 1,
      '%i16': 2,
      '%i32': 4,
      '%i64': 8,
      "%float": 4,
      "%double": 8
    }['%'+type]; // add '%' since float and double confuse Closure compiler as keys, and also spidermonkey as a compiler will remove 's from '_i8' etc
    if (!size) {
      if (type.charAt(type.length-1) == '*') {
        size = Runtime.QUANTUM_SIZE; // A pointer
      } else if (type[0] == 'i') {
        var bits = parseInt(type.substr(1));
        assert(bits % 8 == 0);
        size = bits/8;
      }
    }
    return size;
  },
  getNativeFieldSize: function (type) {
    return Math.max(Runtime.getNativeTypeSize(type), Runtime.QUANTUM_SIZE);
  },
  dedup: function dedup(items, ident) {
  var seen = {};
  if (ident) {
    return items.filter(function(item) {
      if (seen[item[ident]]) return false;
      seen[item[ident]] = true;
      return true;
    });
  } else {
    return items.filter(function(item) {
      if (seen[item]) return false;
      seen[item] = true;
      return true;
    });
  }
},
  set: function set() {
  var args = typeof arguments[0] === 'object' ? arguments[0] : arguments;
  var ret = {};
  for (var i = 0; i < args.length; i++) {
    ret[args[i]] = 0;
  }
  return ret;
},
  calculateStructAlignment: function calculateStructAlignment(type) {
    type.flatSize = 0;
    type.alignSize = 0;
    var diffs = [];
    var prev = -1;
    type.flatIndexes = type.fields.map(function(field) {
      var size, alignSize;
      if (Runtime.isNumberType(field) || Runtime.isPointerType(field)) {
        size = Runtime.getNativeTypeSize(field); // pack char; char; in structs, also char[X]s.
        alignSize = size;
      } else if (Runtime.isStructType(field)) {
        size = Types.types[field].flatSize;
        alignSize = Types.types[field].alignSize;
      } else if (field[0] == 'b') {
        // bN, large number field, like a [N x i8]
        size = field.substr(1)|0;
        alignSize = 1;
      } else {
        throw 'Unclear type in struct: ' + field + ', in ' + type.name_ + ' :: ' + dump(Types.types[type.name_]);
      }
      alignSize = type.packed ? 1 : Math.min(alignSize, Runtime.QUANTUM_SIZE);
      type.alignSize = Math.max(type.alignSize, alignSize);
      var curr = Runtime.alignMemory(type.flatSize, alignSize); // if necessary, place this on aligned memory
      type.flatSize = curr + size;
      if (prev >= 0) {
        diffs.push(curr-prev);
      }
      prev = curr;
      return curr;
    });
    type.flatSize = Runtime.alignMemory(type.flatSize, type.alignSize);
    if (diffs.length == 0) {
      type.flatFactor = type.flatSize;
    } else if (Runtime.dedup(diffs).length == 1) {
      type.flatFactor = diffs[0];
    }
    type.needsFlattening = (type.flatFactor != 1);
    return type.flatIndexes;
  },
  generateStructInfo: function (struct, typeName, offset) {
    var type, alignment;
    if (typeName) {
      offset = offset || 0;
      type = (typeof Types === 'undefined' ? Runtime.typeInfo : Types.types)[typeName];
      if (!type) return null;
      if (type.fields.length != struct.length) {
        printErr('Number of named fields must match the type for ' + typeName + ': possibly duplicate struct names. Cannot return structInfo');
        return null;
      }
      alignment = type.flatIndexes;
    } else {
      var type = { fields: struct.map(function(item) { return item[0] }) };
      alignment = Runtime.calculateStructAlignment(type);
    }
    var ret = {
      __size__: type.flatSize
    };
    if (typeName) {
      struct.forEach(function(item, i) {
        if (typeof item === 'string') {
          ret[item] = alignment[i] + offset;
        } else {
          // embedded struct
          var key;
          for (var k in item) key = k;
          ret[key] = Runtime.generateStructInfo(item[key], type.fields[i], alignment[i]);
        }
      });
    } else {
      struct.forEach(function(item, i) {
        ret[item[1]] = alignment[i];
      });
    }
    return ret;
  },
  dynCall: function (sig, ptr, args) {
    if (args && args.length) {
      return FUNCTION_TABLE[ptr].apply(null, args);
    } else {
      return FUNCTION_TABLE[ptr]();
    }
  },
  addFunction: function (func, sig) {
    //assert(sig); // TODO: support asm
    var table = FUNCTION_TABLE; // TODO: support asm
    var ret = table.length;
    table.push(func);
    table.push(0);
    return ret;
  },
  warnOnce: function (text) {
    if (!Runtime.warnOnce.shown) Runtime.warnOnce.shown = {};
    if (!Runtime.warnOnce.shown[text]) {
      Runtime.warnOnce.shown[text] = 1;
      Module.printErr(text);
    }
  },
  funcWrappers: {},
  getFuncWrapper: function (func, sig) {
    assert(sig);
    if (!Runtime.funcWrappers[func]) {
      Runtime.funcWrappers[func] = function() {
        Runtime.dynCall(sig, func, arguments);
      };
    }
    return Runtime.funcWrappers[func];
  },
  UTF8Processor: function () {
    var buffer = [];
    var needed = 0;
    this.processCChar = function (code) {
      code = code & 0xff;
      if (needed) {
        buffer.push(code);
        needed--;
      }
      if (buffer.length == 0) {
        if (code < 128) return String.fromCharCode(code);
        buffer.push(code);
        if (code > 191 && code < 224) {
          needed = 1;
        } else {
          needed = 2;
        }
        return '';
      }
      if (needed > 0) return '';
      var c1 = buffer[0];
      var c2 = buffer[1];
      var c3 = buffer[2];
      var ret;
      if (c1 > 191 && c1 < 224) {
        ret = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));
      } else {
        ret = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
      }
      buffer.length = 0;
      return ret;
    }
    this.processJSString = function(string) {
      string = unescape(encodeURIComponent(string));
      var ret = [];
      for (var i = 0; i < string.length; i++) {
        ret.push(string.charCodeAt(i));
      }
      return ret;
    }
  },
  stackAlloc: function stackAlloc(size) { var ret = STACKTOP;STACKTOP = (STACKTOP + size)|0;STACKTOP = ((((STACKTOP)+3)>>2)<<2); return ret; },
  staticAlloc: function staticAlloc(size) { var ret = STATICTOP;STATICTOP = (STATICTOP + size)|0;STATICTOP = ((((STATICTOP)+3)>>2)<<2); if (STATICTOP >= TOTAL_MEMORY) enlargeMemory();; return ret; },
  alignMemory: function alignMemory(size,quantum) { var ret = size = Math.ceil((size)/(quantum ? quantum : 4))*(quantum ? quantum : 4); return ret; },
  makeBigInt: function makeBigInt(low,high,unsigned) { var ret = (unsigned ? (((low)>>>(0))+(((high)>>>(0))*4294967296)) : (((low)>>>(0))+(((high)|(0))*4294967296))); return ret; },
  QUANTUM_SIZE: 4,
  __dummy__: 0
}









//========================================
// Runtime essentials
//========================================

var __THREW__ = 0; // Used in checking for thrown exceptions.
var setjmpId = 1; // Used in setjmp/longjmp
var setjmpLabels = {};

var ABORT = false;

var undef = 0;
// tempInt is used for 32-bit signed values or smaller. tempBigInt is used
// for 32-bit unsigned values or more than 32 bits. TODO: audit all uses of tempInt
var tempValue, tempInt, tempBigInt, tempInt2, tempBigInt2, tempPair, tempBigIntI, tempBigIntR, tempBigIntS, tempBigIntP, tempBigIntD;
var tempI64, tempI64b;
var tempRet0, tempRet1, tempRet2, tempRet3, tempRet4, tempRet5, tempRet6, tempRet7, tempRet8, tempRet9;

function abort(text) {
  Module.print(text + ':\n' + (new Error).stack);
  ABORT = true;
  throw "Assertion: " + text;
}

function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed: ' + text);
  }
}

var globalScope = this;

// C calling interface. A convenient way to call C functions (in C files, or
// defined with extern "C").
//
// Note: LLVM optimizations can inline and remove functions, after which you will not be
//       able to call them. Closure can also do so. To avoid that, add your function to
//       the exports using something like
//
//         -s EXPORTED_FUNCTIONS='["_main", "_myfunc"]'
//
// @param ident      The name of the C function (note that C++ functions will be name-mangled - use extern "C")
// @param returnType The return type of the function, one of the JS types 'number', 'string' or 'array' (use 'number' for any C pointer, and
//                   'array' for JavaScript arrays and typed arrays).
// @param argTypes   An array of the types of arguments for the function (if there are no arguments, this can be ommitted). Types are as in returnType,
//                   except that 'array' is not possible (there is no way for us to know the length of the array)
// @param args       An array of the arguments to the function, as native JS values (as in returnType)
//                   Note that string arguments will be stored on the stack (the JS string will become a C string on the stack).
// @return           The return value, as a native JS value (as in returnType)
function ccall(ident, returnType, argTypes, args) {
  return ccallFunc(getCFunc(ident), returnType, argTypes, args);
}
Module["ccall"] = ccall;

// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)
function getCFunc(ident) {
  try {
    var func = globalScope['Module']['_' + ident]; // closure exported function
    if (!func) func = eval('_' + ident); // explicit lookup
  } catch(e) {
  }
  assert(func, 'Cannot call unknown function ' + ident + ' (perhaps LLVM optimizations or closure removed it?)');
  return func;
}

// Internal function that does a C call using a function, not an identifier
function ccallFunc(func, returnType, argTypes, args) {
  var stack = 0;
  function toC(value, type) {
    if (type == 'string') {
      if (value === null || value === undefined || value === 0) return 0; // null string
      if (!stack) stack = Runtime.stackSave();
      var ret = Runtime.stackAlloc(value.length+1);
      writeStringToMemory(value, ret);
      return ret;
    } else if (type == 'array') {
      if (!stack) stack = Runtime.stackSave();
      var ret = Runtime.stackAlloc(value.length);
      writeArrayToMemory(value, ret);
      return ret;
    }
    return value;
  }
  function fromC(value, type) {
    if (type == 'string') {
      return Pointer_stringify(value);
    }
    assert(type != 'array');
    return value;
  }
  var i = 0;
  var cArgs = args ? args.map(function(arg) {
    return toC(arg, argTypes[i++]);
  }) : [];
  var ret = fromC(func.apply(null, cArgs), returnType);
  if (stack) Runtime.stackRestore(stack);
  return ret;
}

// Returns a native JS wrapper for a C function. This is similar to ccall, but
// returns a function you can call repeatedly in a normal way. For example:
//
//   var my_function = cwrap('my_c_function', 'number', ['number', 'number']);
//   alert(my_function(5, 22));
//   alert(my_function(99, 12));
//
function cwrap(ident, returnType, argTypes) {
  var func = getCFunc(ident);
  return function() {
    return ccallFunc(func, returnType, argTypes, Array.prototype.slice.call(arguments));
  }
}
Module["cwrap"] = cwrap;

// Sets a value in memory in a dynamic way at run-time. Uses the
// type data. This is the same as makeSetValue, except that
// makeSetValue is done at compile-time and generates the needed
// code then, whereas this function picks the right code at
// run-time.
// Note that setValue and getValue only do *aligned* writes and reads!
// Note that ccall uses JS types as for defining types, while setValue and
// getValue need LLVM types ('i8', 'i32') - this is a lower-level operation
function setValue(ptr, value, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': HEAP8[(ptr)]=value; break;
      case 'i8': HEAP8[(ptr)]=value; break;
      case 'i16': HEAP16[((ptr)>>1)]=value; break;
      case 'i32': HEAP32[((ptr)>>2)]=value; break;
      case 'i64': (tempI64 = [value>>>0,Math.min(Math.floor((value)/4294967296), 4294967295)>>>0],HEAP32[((ptr)>>2)]=tempI64[0],HEAP32[(((ptr)+(4))>>2)]=tempI64[1]); break;
      case 'float': HEAPF32[((ptr)>>2)]=value; break;
      case 'double': (HEAPF64[(tempDoublePtr)>>3]=value,HEAP32[((ptr)>>2)]=HEAP32[((tempDoublePtr)>>2)],HEAP32[(((ptr)+(4))>>2)]=HEAP32[(((tempDoublePtr)+(4))>>2)]); break;
      default: abort('invalid type for setValue: ' + type);
    }
}
Module['setValue'] = setValue;

// Parallel to setValue.
function getValue(ptr, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': return HEAP8[(ptr)];
      case 'i8': return HEAP8[(ptr)];
      case 'i16': return HEAP16[((ptr)>>1)];
      case 'i32': return HEAP32[((ptr)>>2)];
      case 'i64': return HEAP32[((ptr)>>2)];
      case 'float': return HEAPF32[((ptr)>>2)];
      case 'double': return (HEAP32[((tempDoublePtr)>>2)]=HEAP32[((ptr)>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[(((ptr)+(4))>>2)],HEAPF64[(tempDoublePtr)>>3]);
      default: abort('invalid type for setValue: ' + type);
    }
  return null;
}
Module['getValue'] = getValue;

var ALLOC_NORMAL = 0; // Tries to use _malloc()
var ALLOC_STACK = 1; // Lives for the duration of the current function call
var ALLOC_STATIC = 2; // Cannot be freed
var ALLOC_NONE = 3; // Do not allocate
Module['ALLOC_NORMAL'] = ALLOC_NORMAL;
Module['ALLOC_STACK'] = ALLOC_STACK;
Module['ALLOC_STATIC'] = ALLOC_STATIC;
Module['ALLOC_NONE'] = ALLOC_NONE;

// allocate(): This is for internal use. You can use it yourself as well, but the interface
//             is a little tricky (see docs right below). The reason is that it is optimized
//             for multiple syntaxes to save space in generated code. So you should
//             normally not use allocate(), and instead allocate memory using _malloc(),
//             initialize it with setValue(), and so forth.
// @slab: An array of data, or a number. If a number, then the size of the block to allocate,
//        in *bytes* (note that this is sometimes confusing: the next parameter does not
//        affect this!)
// @types: Either an array of types, one for each byte (or 0 if no type at that position),
//         or a single type which is used for the entire block. This only matters if there
//         is initial data - if @slab is a number, then this does not matter at all and is
//         ignored.
// @allocator: How to allocate memory, see ALLOC_*
function allocate(slab, types, allocator, ptr) {
  var zeroinit, size;
  if (typeof slab === 'number') {
    zeroinit = true;
    size = slab;
  } else {
    zeroinit = false;
    size = slab.length;
  }

  var singleType = typeof types === 'string' ? types : null;

  var ret;
  if (allocator == ALLOC_NONE) {
    ret = ptr;
  } else {
    ret = [_malloc, Runtime.stackAlloc, Runtime.staticAlloc][allocator === undefined ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length));
  }

  if (zeroinit) {
    var ptr = ret, stop;
    assert((ret & 3) == 0);
    stop = ret + (size & ~3);
    for (; ptr < stop; ptr += 4) {
      HEAP32[((ptr)>>2)]=0;
    }
    stop = ret + size;
    while (ptr < stop) {
      HEAP8[((ptr++)|0)]=0;
    }
    return ret;
  }

  if (singleType === 'i8') {
    HEAPU8.set(new Uint8Array(slab), ret);
    return ret;
  }

  var i = 0, type, typeSize, previousType;
  while (i < size) {
    var curr = slab[i];

    if (typeof curr === 'function') {
      curr = Runtime.getFunctionIndex(curr);
    }

    type = singleType || types[i];
    if (type === 0) {
      i++;
      continue;
    }

    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later

    setValue(ret+i, curr, type);

    // no need to look up size unless type changes, so cache it
    if (previousType !== type) {
      typeSize = Runtime.getNativeTypeSize(type);
      previousType = type;
    }
    i += typeSize;
  }

  return ret;
}
Module['allocate'] = allocate;

function Pointer_stringify(ptr, /* optional */ length) {
  var utf8 = new Runtime.UTF8Processor();
  var nullTerminated = typeof(length) == "undefined";
  var ret = "";
  var i = 0;
  var t;
  while (1) {
    t = HEAPU8[(((ptr)+(i))|0)];
    if (nullTerminated && t == 0) break;
    ret += utf8.processCChar(t);
    i += 1;
    if (!nullTerminated && i == length) break;
  }
  return ret;
}
Module['Pointer_stringify'] = Pointer_stringify;

function Array_stringify(array) {
  var ret = "";
  for (var i = 0; i < array.length; i++) {
    ret += String.fromCharCode(array[i]);
  }
  return ret;
}
Module['Array_stringify'] = Array_stringify;

// Memory management

var PAGE_SIZE = 4096;
function alignMemoryPage(x) {
  return ((x+4095)>>12)<<12;
}

var HEAP;
var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;

var STACK_ROOT, STACKTOP, STACK_MAX;
var STATICTOP;
function enlargeMemory() {
  abort('Cannot enlarge memory arrays. Either (1) compile with -s TOTAL_MEMORY=X with X higher than the current value, (2) compile with ALLOW_MEMORY_GROWTH which adjusts the size at runtime but prevents some optimizations, or (3) set Module.TOTAL_MEMORY before the program runs.');
}

var TOTAL_STACK = Module['TOTAL_STACK'] || 5242880;
var TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 16777216;
var FAST_MEMORY = Module['FAST_MEMORY'] || 2097152;

// Initialize the runtime's memory
// check for full engine support (use string 'subarray' to avoid closure compiler confusion)
assert(!!Int32Array && !!Float64Array && !!(new Int32Array(1)['subarray']) && !!(new Int32Array(1)['set']),
       'Cannot fallback to non-typed array case: Code is too specialized');

var buffer = new ArrayBuffer(TOTAL_MEMORY);
HEAP8 = new Int8Array(buffer);
HEAP16 = new Int16Array(buffer);
HEAP32 = new Int32Array(buffer);
HEAPU8 = new Uint8Array(buffer);
HEAPU16 = new Uint16Array(buffer);
HEAPU32 = new Uint32Array(buffer);
HEAPF32 = new Float32Array(buffer);
HEAPF64 = new Float64Array(buffer);

// Endianness check (note: assumes compiler arch was little-endian)
HEAP32[0] = 255;
assert(HEAPU8[0] === 255 && HEAPU8[3] === 0, 'Typed arrays 2 must be run on a little-endian system');

Module['HEAP'] = HEAP;
Module['HEAP8'] = HEAP8;
Module['HEAP16'] = HEAP16;
Module['HEAP32'] = HEAP32;
Module['HEAPU8'] = HEAPU8;
Module['HEAPU16'] = HEAPU16;
Module['HEAPU32'] = HEAPU32;
Module['HEAPF32'] = HEAPF32;
Module['HEAPF64'] = HEAPF64;

STACK_ROOT = STACKTOP = Runtime.alignMemory(1);
STACK_MAX = TOTAL_STACK; // we lose a little stack here, but TOTAL_STACK is nice and round so use that as the max

var tempDoublePtr = Runtime.alignMemory(allocate(12, 'i8', ALLOC_STACK), 8);
assert(tempDoublePtr % 8 == 0);
function copyTempFloat(ptr) { // functions, because inlining this code increases code size too much
  HEAP8[tempDoublePtr] = HEAP8[ptr];
  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];
  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];
  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];
}
function copyTempDouble(ptr) {
  HEAP8[tempDoublePtr] = HEAP8[ptr];
  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];
  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];
  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];
  HEAP8[tempDoublePtr+4] = HEAP8[ptr+4];
  HEAP8[tempDoublePtr+5] = HEAP8[ptr+5];
  HEAP8[tempDoublePtr+6] = HEAP8[ptr+6];
  HEAP8[tempDoublePtr+7] = HEAP8[ptr+7];
}

STATICTOP = STACK_MAX;
assert(STATICTOP < TOTAL_MEMORY); // Stack must fit in TOTAL_MEMORY; allocations from here on may enlarge TOTAL_MEMORY

var nullString = allocate(intArrayFromString('(null)'), 'i8', ALLOC_STACK);

function callRuntimeCallbacks(callbacks) {
  while(callbacks.length > 0) {
    var callback = callbacks.shift();
    var func = callback.func;
    if (typeof func === 'number') {
      if (callback.arg === undefined) {
        Runtime.dynCall('v', func);
      } else {
        Runtime.dynCall('vi', func, [callback.arg]);
      }
    } else {
      func(callback.arg === undefined ? null : callback.arg);
    }
  }
}

var __ATINIT__ = []; // functions called during startup
var __ATMAIN__ = []; // functions called when main() is to be run
var __ATEXIT__ = []; // functions called during shutdown

function initRuntime() {
  callRuntimeCallbacks(__ATINIT__);
}
function preMain() {
  callRuntimeCallbacks(__ATMAIN__);
}
function exitRuntime() {
  callRuntimeCallbacks(__ATEXIT__);
}

// Tools

// This processes a JS string into a C-line array of numbers, 0-terminated.
// For LLVM-originating strings, see parser.js:parseLLVMString function
function intArrayFromString(stringy, dontAddNull, length /* optional */) {
  var ret = (new Runtime.UTF8Processor()).processJSString(stringy);
  if (length) {
    ret.length = length;
  }
  if (!dontAddNull) {
    ret.push(0);
  }
  return ret;
}
Module['intArrayFromString'] = intArrayFromString;

function intArrayToString(array) {
  var ret = [];
  for (var i = 0; i < array.length; i++) {
    var chr = array[i];
    if (chr > 0xFF) {
      chr &= 0xFF;
    }
    ret.push(String.fromCharCode(chr));
  }
  return ret.join('');
}
Module['intArrayToString'] = intArrayToString;

// Write a Javascript array to somewhere in the heap
function writeStringToMemory(string, buffer, dontAddNull) {
  var array = intArrayFromString(string, dontAddNull);
  var i = 0;
  while (i < array.length) {
    var chr = array[i];
    HEAP8[(((buffer)+(i))|0)]=chr
    i = i + 1;
  }
}
Module['writeStringToMemory'] = writeStringToMemory;

function writeArrayToMemory(array, buffer) {
  for (var i = 0; i < array.length; i++) {
    HEAP8[(((buffer)+(i))|0)]=array[i];
  }
}
Module['writeArrayToMemory'] = writeArrayToMemory;

function unSign(value, bits, ignore, sig) {
  if (value >= 0) {
    return value;
  }
  return bits <= 32 ? 2*Math.abs(1 << (bits-1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts
                    : Math.pow(2, bits)         + value;
}
function reSign(value, bits, ignore, sig) {
  if (value <= 0) {
    return value;
  }
  var half = bits <= 32 ? Math.abs(1 << (bits-1)) // abs is needed if bits == 32
                        : Math.pow(2, bits-1);
  if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don't do that
                                                       // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors
                                                       // TODO: In i64 mode 1, resign the two parts separately and safely
    value = -2*half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts
  }
  return value;
}

if (!Math.imul) Math.imul = function(a, b) {
  var ah  = a >>> 16;
  var al = a & 0xffff;
  var bh  = b >>> 16;
  var bl = b & 0xffff;
  return (al*bl + ((ah*bl + al*bh) << 16))|0;
};

// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// PRE_RUN_ADDITIONS (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyTracking = {};
var calledRun = false;
var runDependencyWatcher = null;
function addRunDependency(id) {
  runDependencies++;
  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }
  if (id) {
    assert(!runDependencyTracking[id]);
    runDependencyTracking[id] = 1;
    if (runDependencyWatcher === null && typeof setInterval !== 'undefined') {
      // Check for missing dependencies every few seconds
      runDependencyWatcher = setInterval(function() {
        var shown = false;
        for (var dep in runDependencyTracking) {
          if (!shown) {
            shown = true;
            Module.printErr('still waiting on run dependencies:');
          }
          Module.printErr('dependency: ' + dep);
        }
        if (shown) {
          Module.printErr('(end of list)');
        }
      }, 6000);
    }
  } else {
    Module.printErr('warning: run dependency added without ID');
  }
}
Module['addRunDependency'] = addRunDependency;
function removeRunDependency(id) {
  runDependencies--;
  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }
  if (id) {
    assert(runDependencyTracking[id]);
    delete runDependencyTracking[id];
  } else {
    Module.printErr('warning: run dependency removed without ID');
  }
  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    } 
    // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
    if (!calledRun && shouldRunNow) run();
  }
}
Module['removeRunDependency'] = removeRunDependency;

Module["preloadedImages"] = {}; // maps url to image data
Module["preloadedAudios"] = {}; // maps url to audio data

// === Body ===



assert(STATICTOP == STACK_MAX); assert(STACK_MAX == TOTAL_STACK);

STATICTOP += 7476;

assert(STATICTOP < TOTAL_MEMORY);

var _stderr;







































































































var __ZTVSt9exception;


var __ZTVN10__cxxabiv120__si_class_type_infoE;


var __ZTISt9exception;









allocate(4, "i8", ALLOC_NONE, 5242880);
allocate(4, "i8", ALLOC_NONE, 5242884);
allocate(24, "i8", ALLOC_NONE, 5242888);
allocate(4, "i8", ALLOC_NONE, 5242912);
allocate(1024, "i8", ALLOC_NONE, 5242916);
allocate([107,32,60,61,32,90,79,80,70,76,73,95,77,65,88,95,77,65,84,67,72,0] /* k _= ZOPFLI_MAX_MATC */, "i8", ALLOC_NONE, 5243940);
allocate([109,97,120,32,115,121,115,116,101,109,32,98,121,116,101,115,32,61,32,37,49,48,108,117,10,0] /* max system bytes = % */, "i8", ALLOC_NONE, 5243964);
allocate([112,32,60,32,90,79,80,70,76,73,95,87,73,78,68,79,87,95,83,73,90,69,0] /* p _ ZOPFLI_WINDOW_SI */, "i8", ALLOC_NONE, 5243992);
allocate([100,97,116,97,0] /* data\00 */, "i8", ALLOC_NONE, 5244016);
allocate([79,114,105,103,105,110,97,108,32,83,105,122,101,58,32,37,100,44,32,67,111,109,112,114,101,115,115,101,100,58,32,37,100,44,32,67,111,109,112,114,101,115,115,105,111,110,58,32,37,102,37,37,32,82,101,109,111,118,101,100,10,0] /* Original Size: %d, C */, "i8", ALLOC_NONE, 5244024);
allocate([108,105,116,108,101,110,32,62,61,32,51,32,38,38,32,108,105,116,108,101,110,32,60,61,32,50,56,56,0] /* litlen _= 3 && litle */, "i8", ALLOC_NONE, 5244088);
allocate([32,37,120,0] /*  %x\00 */, "i8", ALLOC_NONE, 5244120);
allocate([110,101,119,67,111,115,116,32,62,61,32,48,0] /* newCost _= 0\00 */, "i8", ALLOC_NONE, 5244124);
allocate([112,112,32,61,61,32,104,112,111,115,0] /* pp == hpos\00 */, "i8", ALLOC_NONE, 5244140);
allocate([108,108,95,108,101,110,103,116,104,115,91,108,105,116,108,101,110,93,32,62,32,48,0] /* ll_lengths[litlen] _ */, "i8", ALLOC_NONE, 5244152);
allocate([40,104,101,120,58,0] /* (hex:\00 */, "i8", ALLOC_NONE, 5244176);
allocate([108,101,110,103,116,104,95,97,114,114,97,121,91,105,110,100,101,120,93,32,33,61,32,48,0] /* length_array[index]  */, "i8", ALLOC_NONE, 5244184);
allocate([104,118,97,108,32,60,32,54,53,53,51,54,0] /* hval _ 65536\00 */, "i8", ALLOC_NONE, 5244212);
allocate([108,105,116,108,101,110,32,60,32,50,53,54,0] /* litlen _ 256\00 */, "i8", ALLOC_NONE, 5244228);
allocate([47,85,115,101,114,115,47,121,117,116,97,46,105,109,97,121,97,47,103,105,116,47,122,111,112,102,108,105,46,106,115,47,122,111,112,102,108,105,47,116,114,101,101,46,99,0] /* /Users/yuta.imaya/gi */, "i8", ALLOC_NONE, 5244244);
allocate([37,100,32,0] /* %d \00 */, "i8", ALLOC_NONE, 5244292);
allocate([108,101,110,103,116,104,95,97,114,114,97,121,91,105,110,100,101,120,93,32,60,61,32,90,79,80,70,76,73,95,77,65,88,95,77,65,84,67,72,0] /* length_array[index]  */, "i8", ALLOC_NONE, 5244296);
allocate([112,111,115,32,60,32,115,105,122,101,0] /* pos _ size\00 */, "i8", ALLOC_NONE, 5244336);
allocate([99,111,109,112,114,101,115,115,101,100,32,98,108,111,99,107,32,115,105,122,101,58,32,37,100,32,40,37,100,107,41,32,40,117,110,99,58,32,37,100,41,10,0] /* compressed block siz */, "i8", ALLOC_NONE, 5244348);
allocate([98,108,111,99,107,32,115,112,108,105,116,32,112,111,105,110,116,115,58,32,0] /* block split points:  */, "i8", ALLOC_NONE, 5244392);
allocate([108,101,110,103,116,104,95,97,114,114,97,121,91,105,110,100,101,120,93,32,60,61,32,105,110,100,101,120,0] /* length_array[index]  */, "i8", ALLOC_NONE, 5244416);
allocate([47,85,115,101,114,115,47,121,117,116,97,46,105,109,97,121,97,47,103,105,116,47,122,111,112,102,108,105,46,106,115,47,122,111,112,102,108,105,47,115,113,117,101,101,122,101,46,99,0] /* /Users/yuta.imaya/gi */, "i8", ALLOC_NONE, 5244448);
allocate([108,105,109,105,116,32,62,61,32,90,79,80,70,76,73,95,77,73,78,95,77,65,84,67,72,0] /* limit _= ZOPFLI_MIN_ */, "i8", ALLOC_NONE, 5244500);
allocate([100,95,99,111,117,110,116,115,91,105,93,32,61,61,32,48,32,124,124,32,100,95,108,101,110,103,116,104,115,91,105,93,32,62,32,48,0] /* d_counts[i] == 0 ||  */, "i8", ALLOC_NONE, 5244528);
allocate([110,112,111,105,110,116,115,32,61,61,32,110,108,122,55,55,112,111,105,110,116,115,0] /* npoints == nlz77poin */, "i8", ALLOC_NONE, 5244568);
allocate([112,111,115,32,43,32,108,101,110,103,116,104,32,60,61,32,105,110,101,110,100,0] /* pos + length _= inen */, "i8", ALLOC_NONE, 5244592);
allocate([108,105,109,105,116,32,60,61,32,90,79,80,70,76,73,95,77,65,88,95,77,65,84,67,72,0] /* limit _= ZOPFLI_MAX_ */, "i8", ALLOC_NONE, 5244616);
allocate([108,108,95,99,111,117,110,116,115,91,105,93,32,61,61,32,48,32,124,124,32,108,108,95,108,101,110,103,116,104,115,91,105,93,32,62,32,48,0] /* ll_counts[i] == 0 || */, "i8", ALLOC_NONE, 5244644);
allocate([42,110,112,111,105,110,116,115,32,61,61,32,110,108,122,55,55,112,111,105,110,116,115,0] /* _npoints == nlz77poi */, "i8", ALLOC_NONE, 5244684);
allocate([115,116,100,58,58,98,97,100,95,97,108,108,111,99,0] /* std::bad_alloc\00 */, "i8", ALLOC_NONE, 5244708);
allocate([33,101,114,114,111,114,0] /* !error\00 */, "i8", ALLOC_NONE, 5244724);
allocate([33,40,100,117,109,109,121,95,108,101,110,103,116,104,32,33,61,32,108,101,110,103,116,104,32,38,38,32,108,101,110,103,116,104,32,62,32,50,32,38,38,32,100,117,109,109,121,95,108,101,110,103,116,104,32,62,32,50,41,0] /* !(dummy_length != le */, "i8", ALLOC_NONE, 5244732);
allocate([112,111,115,32,43,32,42,108,101,110,103,116,104,32,60,61,32,115,105,122,101,0] /* pos + _length _= siz */, "i8", ALLOC_NONE, 5244792);
allocate([116,114,101,101,115,105,122,101,58,32,37,100,10,0] /* treesize: %d\0A\00 */, "i8", ALLOC_NONE, 5244816);
allocate([98,101,115,116,108,101,110,103,116,104,32,61,61,32,90,111,112,102,108,105,77,97,120,67,97,99,104,101,100,83,117,98,108,101,110,40,108,109,99,44,32,112,111,115,44,32,108,101,110,103,116,104,41,0] /* bestlength == Zopfli */, "i8", ALLOC_NONE, 5244832);
allocate([47,85,115,101,114,115,47,121,117,116,97,46,105,109,97,121,97,47,103,105,116,47,122,111,112,102,108,105,46,106,115,47,122,111,112,102,108,105,47,108,122,55,55,46,99,0] /* /Users/yuta.imaya/gi */, "i8", ALLOC_NONE, 5244888);
allocate([79,114,105,103,105,110,97,108,32,83,105,122,101,58,32,37,100,44,32,67,111,109,112,114,101,115,115,101,100,58,32,37,100,44,32,67,111,109,112,114,101,115,115,105,111,110,58,32,37,102,37,37,32,82,101,109,111,118,101,100,10,0] /* Original Size: %d, C */, "i8", ALLOC_NONE, 5244936);
allocate([108,108,112,111,115,32,60,32,108,101,110,100,0] /* llpos _ lend\00 */, "i8", ALLOC_NONE, 5245000);
allocate([105,110,32,117,115,101,32,98,121,116,101,115,32,32,32,32,32,61,32,37,49,48,108,117,10,0] /* in use bytes     = % */, "i8", ALLOC_NONE, 5245016);
allocate([98,105,116,108,101,110,103,116,104,115,91,105,93,32,62,61,32,48,0] /* bitlengths[i] _= 0\0 */, "i8", ALLOC_NONE, 5245044);
allocate([112,111,115,32,60,32,105,110,101,110,100,0] /* pos _ inend\00 */, "i8", ALLOC_NONE, 5245064);
allocate([100,97,116,97,91,112,111,115,32,45,32,100,105,115,116,32,43,32,105,93,32,61,61,32,100,97,116,97,91,112,111,115,32,43,32,105,93,0] /* data[pos - dist + i] */, "i8", ALLOC_NONE, 5245076);
allocate([98,116,121,112,101,32,61,61,32,50,0] /* btype == 2\00 */, "i8", ALLOC_NONE, 5245116);
allocate([98,101,115,116,108,101,110,103,116,104,32,60,61,32,108,101,110,103,116,104,0] /* bestlength _= length */, "i8", ALLOC_NONE, 5245128);
allocate([108,108,112,111,115,32,62,32,108,115,116,97,114,116,0] /* llpos _ lstart\00 */, "i8", ALLOC_NONE, 5245152);
allocate([115,121,115,116,101,109,32,98,121,116,101,115,32,32,32,32,32,61,32,37,49,48,108,117,10,0] /* system bytes     = % */, "i8", ALLOC_NONE, 5245168);
allocate([114,0] /* r\00 */, "i8", ALLOC_NONE, 5245196);
allocate([108,101,110,103,116,104,115,91,105,93,32,60,61,32,109,97,120,98,105,116,115,0] /* lengths[i] _= maxbit */, "i8", ALLOC_NONE, 5245200);
allocate([115,117,98,108,101,110,91,42,108,101,110,103,116,104,93,32,61,61,32,115,45,62,108,109,99,45,62,100,105,115,116,91,108,109,99,112,111,115,93,0] /* sublen[_length] == s */, "i8", ALLOC_NONE, 5245224);
allocate([33,40,115,45,62,108,109,99,45,62,108,101,110,103,116,104,91,108,109,99,112,111,115,93,32,61,61,32,49,32,38,38,32,115,45,62,108,109,99,45,62,100,105,115,116,91,108,109,99,112,111,115,93,32,61,61,32,48,41,0] /* !(s-_lmc-_length[lmc */, "i8", ALLOC_NONE, 5245264);
allocate([98,116,121,112,101,32,61,61,32,49,0] /* btype == 1\00 */, "i8", ALLOC_NONE, 5245324);
allocate([99,111,115,116,32,60,32,90,79,80,70,76,73,95,76,65,82,71,69,95,70,76,79,65,84,0] /* cost _ ZOPFLI_LARGE_ */, "i8", ALLOC_NONE, 5245336);
allocate([115,45,62,108,109,99,45,62,108,101,110,103,116,104,91,108,109,99,112,111,115,93,32,61,61,32,49,32,38,38,32,115,45,62,108,109,99,45,62,100,105,115,116,91,108,109,99,112,111,115,93,32,61,61,32,48,0] /* s-_lmc-_length[lmcpo */, "i8", ALLOC_NONE, 5245364);
allocate([98,108,111,99,107,115,105,122,101,32,60,32,54,53,53,51,54,0] /* blocksize _ 65536\00 */, "i8", ALLOC_NONE, 5245424);
allocate([47,85,115,101,114,115,47,121,117,116,97,46,105,109,97,121,97,47,103,105,116,47,122,111,112,102,108,105,46,106,115,47,122,111,112,102,108,105,47,100,101,102,108,97,116,101,46,99,0] /* /Users/yuta.imaya/gi */, "i8", ALLOC_NONE, 5245444);
allocate([105,32,60,32,105,110,101,110,100,0] /* i _ inend\00 */, "i8", ALLOC_NONE, 5245496);
allocate([98,97,100,95,97,114,114,97,121,95,110,101,119,95,108,101,110,103,116,104,0] /* bad_array_new_length */, "i8", ALLOC_NONE, 5245508);
allocate([114,108,101,91,114,108,101,95,115,105,122,101,32,45,32,49,93,32,60,61,32,49,56,0] /* rle[rle_size - 1] _= */, "i8", ALLOC_NONE, 5245532);
allocate([98,101,115,116,108,101,110,103,116,104,32,60,61,32,108,105,109,105,116,0] /* bestlength _= limit\ */, "i8", ALLOC_NONE, 5245556);
allocate([112,111,115,32,43,32,108,101,110,103,116,104,32,60,61,32,100,97,116,97,115,105,122,101,0] /* pos + length _= data */, "i8", ALLOC_NONE, 5245576);
allocate([108,108,100,95,108,101,110,103,116,104,115,91,105,93,32,60,32,49,54,0] /* lld_lengths[i] _ 16\ */, "i8", ALLOC_NONE, 5245604);
allocate([100,105,115,116,32,60,61,32,112,111,115,0] /* dist _= pos\00 */, "i8", ALLOC_NONE, 5245624);
allocate([101,120,112,101,99,116,101,100,95,100,97,116,97,95,115,105,122,101,32,61,61,32,48,32,124,124,32,116,101,115,116,108,101,110,103,116,104,32,61,61,32,101,120,112,101,99,116,101,100,95,100,97,116,97,95,115,105,122,101,0] /* expected_data_size = */, "i8", ALLOC_NONE, 5245636);
allocate([98,116,121,112,101,32,61,61,32,49,32,124,124,32,98,116,121,112,101,32,61,61,32,50,0] /* btype == 1 || btype  */, "i8", ALLOC_NONE, 5245696);
allocate([104,104,97,115,104,118,97,108,91,112,93,32,61,61,32,104,118,97,108,0] /* hhashval[p] == hval\ */, "i8", ALLOC_NONE, 5245724);
allocate([100,95,108,101,110,103,116,104,115,91,100,115,93,32,62,32,48,0] /* d_lengths[ds] _ 0\00 */, "i8", ALLOC_NONE, 5245744);
allocate([98,101,115,116,108,101,110,103,116,104,32,61,61,32,108,101,110,103,116,104,0] /* bestlength == length */, "i8", ALLOC_NONE, 5245764);
allocate([47,85,115,101,114,115,47,121,117,116,97,46,105,109,97,121,97,47,103,105,116,47,122,111,112,102,108,105,46,106,115,47,122,111,112,102,108,105,47,99,97,99,104,101,46,99,0] /* /Users/yuta.imaya/gi */, "i8", ALLOC_NONE, 5245788);
allocate([99,111,115,116,115,91,98,108,111,99,107,115,105,122,101,93,32,62,61,32,48,0] /* costs[blocksize] _=  */, "i8", ALLOC_NONE, 5245836);
allocate([112,32,61,61,32,104,112,114,101,118,91,112,112,93,0] /* p == hprev[pp]\00 */, "i8", ALLOC_NONE, 5245860);
allocate([108,108,95,108,101,110,103,116,104,115,91,108,108,115,93,32,62,32,48,0] /* ll_lengths[lls] _ 0\ */, "i8", ALLOC_NONE, 5245876);
allocate([41,10,0] /* )\0A\00 */, "i8", ALLOC_NONE, 5245896);
allocate([108,115,116,97,114,116,32,60,32,108,101,110,100,0] /* lstart _ lend\00 */, "i8", ALLOC_NONE, 5245900);
allocate([47,85,115,101,114,115,47,121,117,116,97,46,105,109,97,121,97,47,103,105,116,47,122,111,112,102,108,105,46,106,115,47,122,111,112,102,108,105,47,98,108,111,99,107,115,112,108,105,116,116,101,114,46,99,0] /* /Users/yuta.imaya/gi */, "i8", ALLOC_NONE, 5245916);
allocate(472, "i8", ALLOC_NONE, 5245972);
allocate([90,111,112,102,108,105,86,101,114,105,102,121,76,101,110,68,105,115,116,0] /* ZopfliVerifyLenDist\ */, "i8", ALLOC_NONE, 5246444);
allocate([90,111,112,102,108,105,83,117,98,108,101,110,84,111,67,97,99,104,101,0] /* ZopfliSublenToCache\ */, "i8", ALLOC_NONE, 5246464);
allocate([90,111,112,102,108,105,76,101,110,103,116,104,115,84,111,83,121,109,98,111,108,115,0] /* ZopfliLengthsToSymbo */, "i8", ALLOC_NONE, 5246484);
allocate([90,111,112,102,108,105,76,90,55,55,71,114,101,101,100,121,0] /* ZopfliLZ77Greedy\00 */, "i8", ALLOC_NONE, 5246508);
allocate([90,111,112,102,108,105,70,105,110,100,76,111,110,103,101,115,116,77,97,116,99,104,0] /* ZopfliFindLongestMat */, "i8", ALLOC_NONE, 5246528);
allocate([90,111,112,102,108,105,67,97,108,99,117,108,97,116,101,69,110,116,114,111,112,121,0] /* ZopfliCalculateEntro */, "i8", ALLOC_NONE, 5246552);
allocate([90,111,112,102,108,105,67,97,108,99,117,108,97,116,101,66,108,111,99,107,83,105,122,101,0] /* ZopfliCalculateBlock */, "i8", ALLOC_NONE, 5246576);
allocate([90,111,112,102,108,105,67,97,108,99,117,108,97,116,101,66,105,116,76,101,110,103,116,104,115,0] /* ZopfliCalculateBitLe */, "i8", ALLOC_NONE, 5246604);
allocate([90,111,112,102,108,105,66,108,111,99,107,83,112,108,105,116,76,90,55,55,0] /* ZopfliBlockSplitLZ77 */, "i8", ALLOC_NONE, 5246632);
allocate([90,111,112,102,108,105,66,108,111,99,107,83,112,108,105,116,0] /* ZopfliBlockSplit\00 */, "i8", ALLOC_NONE, 5246656);
allocate([84,114,121,71,101,116,70,114,111,109,76,111,110,103,101,115,116,77,97,116,99,104,67,97,99,104,101,0] /* TryGetFromLongestMat */, "i8", ALLOC_NONE, 5246676);
allocate([84,114,97,99,101,66,97,99,107,119,97,114,100,115,0] /* TraceBackwards\00 */, "i8", ALLOC_NONE, 5246704);
allocate([83,116,111,114,101,73,110,76,111,110,103,101,115,116,77,97,116,99,104,67,97,99,104,101,0] /* StoreInLongestMatchC */, "i8", ALLOC_NONE, 5246720);
allocate([80,114,105,110,116,66,108,111,99,107,83,112,108,105,116,80,111,105,110,116,115,0] /* PrintBlockSplitPoint */, "i8", ALLOC_NONE, 5246748);
allocate([76,90,55,55,79,112,116,105,109,97,108,82,117,110,0] /* LZ77OptimalRun\00 */, "i8", ALLOC_NONE, 5246772);
allocate([71,101,116,66,101,115,116,76,101,110,103,116,104,115,0] /* GetBestLengths\00 */, "i8", ALLOC_NONE, 5246788);
allocate([70,111,108,108,111,119,80,97,116,104,0] /* FollowPath\00 */, "i8", ALLOC_NONE, 5246804);
allocate([68,101,102,108,97,116,101,83,112,108,105,116,116,105,110,103,76,97,115,116,0] /* DeflateSplittingLast */, "i8", ALLOC_NONE, 5246816);
allocate([68,101,102,108,97,116,101,78,111,110,67,111,109,112,114,101,115,115,101,100,66,108,111,99,107,0] /* DeflateNonCompressed */, "i8", ALLOC_NONE, 5246840);
allocate([68,101,102,108,97,116,101,66,108,111,99,107,0] /* DeflateBlock\00 */, "i8", ALLOC_NONE, 5246868);
allocate([65,100,100,76,90,55,55,68,97,116,97,0] /* AddLZ77Data\00 */, "i8", ALLOC_NONE, 5246884);
allocate([65,100,100,76,90,55,55,66,108,111,99,107,0] /* AddLZ77Block\00 */, "i8", ALLOC_NONE, 5246896);
allocate([65,100,100,68,121,110,97,109,105,99,84,114,101,101,0] /* AddDynamicTree\00 */, "i8", ALLOC_NONE, 5246912);
allocate([0,0,0,0,44,16,80,0,0,0,0,0,0,0,0,0,0,0,0,0], "i8", ALLOC_NONE, 5246928);
allocate(1, "i8", ALLOC_NONE, 5246948);
allocate([0,0,0,0,56,16,80,0,0,0,0,0,0,0,0,0,0,0,0,0], "i8", ALLOC_NONE, 5246952);
allocate(1, "i8", ALLOC_NONE, 5246972);
allocate([83,116,57,98,97,100,95,97,108,108,111,99,0] /* St9bad_alloc\00 */, "i8", ALLOC_NONE, 5246976);
allocate([83,116,50,48,98,97,100,95,97,114,114,97,121,95,110,101,119,95,108,101,110,103,116,104,0] /* St20bad_array_new_le */, "i8", ALLOC_NONE, 5246992);
allocate(12, "i8", ALLOC_NONE, 5247020);
allocate([0,0,0,0,0,0,0,0,44,16,80,0], "i8", ALLOC_NONE, 5247032);
allocate(1, "i8", ALLOC_NONE, 5247044);
allocate(4, "i8", ALLOC_NONE, 5247048);
allocate([0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,2,1,0,0,3,1,0,0,4,1,0,0,5,1,0,0,6,1,0,0,7,1,0,0,8,1,0,0,9,1,0,0,9,1,0,0,10,1,0,0,10,1,0,0,11,1,0,0,11,1,0,0,12,1,0,0,12,1,0,0,13,1,0,0,13,1,0,0,13,1,0,0,13,1,0,0,14,1,0,0,14,1,0,0,14,1,0,0,14,1,0,0,15,1,0,0,15,1,0,0,15,1,0,0,15,1,0,0,16,1,0,0,16,1,0,0,16,1,0,0,16,1,0,0,17,1,0,0,17,1,0,0,17,1,0,0,17,1,0,0,17,1,0,0,17,1,0,0,17,1,0,0,17,1,0,0,18,1,0,0,18,1,0,0,18,1,0,0,18,1,0,0,18,1,0,0,18,1,0,0,18,1,0,0,18,1,0,0,19,1,0,0,19,1,0,0,19,1,0,0,19,1,0,0,19,1,0,0,19,1,0,0,19,1,0,0,19,1,0,0,20,1,0,0,20,1,0,0,20,1,0,0,20,1,0,0,20,1,0,0,20,1,0,0,20,1,0,0,20,1,0,0,21,1,0,0,21,1,0,0,21,1,0,0,21,1,0,0,21,1,0,0,21,1,0,0,21,1,0,0,21,1,0,0,21,1,0,0,21,1,0,0,21,1,0,0,21,1,0,0,21,1,0,0,21,1,0,0,21,1,0,0,21,1,0,0,22,1,0,0,22,1,0,0,22,1,0,0,22,1,0,0,22,1,0,0,22,1,0,0,22,1,0,0,22,1,0,0,22,1,0,0,22,1,0,0,22,1,0,0,22,1,0,0,22,1,0,0,22,1,0,0,22,1,0,0,22,1,0,0,23,1,0,0,23,1,0,0,23,1,0,0,23,1,0,0,23,1,0,0,23,1,0,0,23,1,0,0,23,1,0,0,23,1,0,0,23,1,0,0,23,1,0,0,23,1,0,0,23,1,0,0,23,1,0,0,23,1,0,0,23,1,0,0,24,1,0,0,24,1,0,0,24,1,0,0,24,1,0,0,24,1,0,0,24,1,0,0,24,1,0,0,24,1,0,0,24,1,0,0,24,1,0,0,24,1,0,0,24,1,0,0,24,1,0,0,24,1,0,0,24,1,0,0,24,1,0,0,25,1,0,0,25,1,0,0,25,1,0,0,25,1,0,0,25,1,0,0,25,1,0,0,25,1,0,0,25,1,0,0,25,1,0,0,25,1,0,0,25,1,0,0,25,1,0,0,25,1,0,0,25,1,0,0,25,1,0,0,25,1,0,0,25,1,0,0,25,1,0,0,25,1,0,0,25,1,0,0,25,1,0,0,25,1,0,0,25,1,0,0,25,1,0,0,25,1,0,0,25,1,0,0,25,1,0,0,25,1,0,0,25,1,0,0,25,1,0,0,25,1,0,0,25,1,0,0,26,1,0,0,26,1,0,0,26,1,0,0,26,1,0,0,26,1,0,0,26,1,0,0,26,1,0,0,26,1,0,0,26,1,0,0,26,1,0,0,26,1,0,0,26,1,0,0,26,1,0,0,26,1,0,0,26,1,0,0,26,1,0,0,26,1,0,0,26,1,0,0,26,1,0,0,26,1,0,0,26,1,0,0,26,1,0,0,26,1,0,0,26,1,0,0,26,1,0,0,26,1,0,0,26,1,0,0,26,1,0,0,26,1,0,0,26,1,0,0,26,1,0,0,26,1,0,0,27,1,0,0,27,1,0,0,27,1,0,0,27,1,0,0,27,1,0,0,27,1,0,0,27,1,0,0,27,1,0,0,27,1,0,0,27,1,0,0,27,1,0,0,27,1,0,0,27,1,0,0,27,1,0,0,27,1,0,0,27,1,0,0,27,1,0,0,27,1,0,0,27,1,0,0,27,1,0,0,27,1,0,0,27,1,0,0,27,1,0,0,27,1,0,0,27,1,0,0,27,1,0,0,27,1,0,0,27,1,0,0,27,1,0,0,27,1,0,0,27,1,0,0,27,1,0,0,28,1,0,0,28,1,0,0,28,1,0,0,28,1,0,0,28,1,0,0,28,1,0,0,28,1,0,0,28,1,0,0,28,1,0,0,28,1,0,0,28,1,0,0,28,1,0,0,28,1,0,0,28,1,0,0,28,1,0,0,28,1,0,0,28,1,0,0,28,1,0,0,28,1,0,0,28,1,0,0,28,1,0,0,28,1,0,0,28,1,0,0,28,1,0,0,28,1,0,0,28,1,0,0,28,1,0,0,28,1,0,0,28,1,0,0,28,1,0,0,28,1,0,0,29,1,0,0], "i8", ALLOC_NONE, 5247052);
allocate([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,3,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,4,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,5,0,0,0,0,0,0,0], "i8", ALLOC_NONE, 5248088);
allocate([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,4,0,0,0,5,0,0,0,6,0,0,0,7,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,4,0,0,0,5,0,0,0,6,0,0,0,7,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,4,0,0,0,5,0,0,0,6,0,0,0,7,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,4,0,0,0,5,0,0,0,6,0,0,0,7,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,4,0,0,0,5,0,0,0,6,0,0,0,7,0,0,0,8,0,0,0,9,0,0,0,10,0,0,0,11,0,0,0,12,0,0,0,13,0,0,0,14,0,0,0,15,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,4,0,0,0,5,0,0,0,6,0,0,0,7,0,0,0,8,0,0,0,9,0,0,0,10,0,0,0,11,0,0,0,12,0,0,0,13,0,0,0,14,0,0,0,15,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,4,0,0,0,5,0,0,0,6,0,0,0,7,0,0,0,8,0,0,0,9,0,0,0,10,0,0,0,11,0,0,0,12,0,0,0,13,0,0,0,14,0,0,0,15,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,4,0,0,0,5,0,0,0,6,0,0,0,7,0,0,0,8,0,0,0,9,0,0,0,10,0,0,0,11,0,0,0,12,0,0,0,13,0,0,0,14,0,0,0,15,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,4,0,0,0,5,0,0,0,6,0,0,0,7,0,0,0,8,0,0,0,9,0,0,0,10,0,0,0,11,0,0,0,12,0,0,0,13,0,0,0,14,0,0,0,15,0,0,0,16,0,0,0,17,0,0,0,18,0,0,0,19,0,0,0,20,0,0,0,21,0,0,0,22,0,0,0,23,0,0,0,24,0,0,0,25,0,0,0,26,0,0,0,27,0,0,0,28,0,0,0,29,0,0,0,30,0,0,0,31,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,4,0,0,0,5,0,0,0,6,0,0,0,7,0,0,0,8,0,0,0,9,0,0,0,10,0,0,0,11,0,0,0,12,0,0,0,13,0,0,0,14,0,0,0,15,0,0,0,16,0,0,0,17,0,0,0,18,0,0,0,19,0,0,0,20,0,0,0,21,0,0,0,22,0,0,0,23,0,0,0,24,0,0,0,25,0,0,0,26,0,0,0,27,0,0,0,28,0,0,0,29,0,0,0,30,0,0,0,31,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,4,0,0,0,5,0,0,0,6,0,0,0,7,0,0,0,8,0,0,0,9,0,0,0,10,0,0,0,11,0,0,0,12,0,0,0,13,0,0,0,14,0,0,0,15,0,0,0,16,0,0,0,17,0,0,0,18,0,0,0,19,0,0,0,20,0,0,0,21,0,0,0,22,0,0,0,23,0,0,0,24,0,0,0,25,0,0,0,26,0,0,0,27,0,0,0,28,0,0,0,29,0,0,0,30,0,0,0,31,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,4,0,0,0,5,0,0,0,6,0,0,0,7,0,0,0,8,0,0,0,9,0,0,0,10,0,0,0,11,0,0,0,12,0,0,0,13,0,0,0,14,0,0,0,15,0,0,0,16,0,0,0,17,0,0,0,18,0,0,0,19,0,0,0,20,0,0,0,21,0,0,0,22,0,0,0,23,0,0,0,24,0,0,0,25,0,0,0,26,0,0,0,27,0,0,0,28,0,0,0,29,0,0,0,30,0,0,0,0,0,0,0], "i8", ALLOC_NONE, 5249124);
allocate([1,0,0,0,2,0,0,0,3,0,0,0,4,0,0,0,5,0,0,0,7,0,0,0,9,0,0,0,13,0,0,0,17,0,0,0,25,0,0,0,33,0,0,0,49,0,0,0,65,0,0,0,97,0,0,0,129,0,0,0,193,0,0,0,1,1,0,0,129,1,0,0,1,2,0,0,1,3,0,0,1,4,0,0,1,6,0,0,1,8,0,0,1,12,0,0,1,16,0,0,1,24,0,0,1,32,0,0,1,48,0,0,1,64,0,0,1,96,0,0], "i8", ALLOC_NONE, 5250160);
allocate([16,0,0,0,17,0,0,0,18,0,0,0,0,0,0,0,8,0,0,0,7,0,0,0,9,0,0,0,6,0,0,0,10,0,0,0,5,0,0,0,11,0,0,0,4,0,0,0,12,0,0,0,3,0,0,0,13,0,0,0,2,0,0,0,14,0,0,0,1,0,0,0,15,0,0,0], "i8", ALLOC_NONE, 5250280);
HEAP32[((5246936)>>2)]=(4);
HEAP32[((5246940)>>2)]=(12);
HEAP32[((5246944)>>2)]=(8);
HEAP32[((5246960)>>2)]=(16);
HEAP32[((5246964)>>2)]=(2);
HEAP32[((5246968)>>2)]=(10);
__ZTVN10__cxxabiv120__si_class_type_infoE=allocate([2,0,0,0], "i8", ALLOC_STATIC);
HEAP32[((5247020)>>2)]=(((__ZTVN10__cxxabiv120__si_class_type_infoE+8)|0));
HEAP32[((5247024)>>2)]=((5246976)|0);
HEAP32[((5247028)>>2)]=__ZTISt9exception;
HEAP32[((5247032)>>2)]=(((__ZTVN10__cxxabiv120__si_class_type_infoE+8)|0));
HEAP32[((5247036)>>2)]=((5246992)|0);

  
  function __exit(status) {
      // void _exit(int status);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/exit.html
  
  
      exitRuntime();
      ABORT = true;
  
      throw 'exit(' + status + ') called, at ' + new Error().stack;
    }function _exit(status) {
      __exit(status);
    }

  function ___assert_func(filename, line, func, condition) {
      throw 'Assertion failed: ' + (condition ? Pointer_stringify(condition) : 'unknown condition') + ', at: ' + [filename ? Pointer_stringify(filename) : 'unknown filename', line, func ? Pointer_stringify(func) : 'unknown function'] + ' at ' + new Error().stack;
    }

  
  
  
  var ERRNO_CODES={E2BIG:7,EACCES:13,EADDRINUSE:98,EADDRNOTAVAIL:99,EAFNOSUPPORT:97,EAGAIN:11,EALREADY:114,EBADF:9,EBADMSG:74,EBUSY:16,ECANCELED:125,ECHILD:10,ECONNABORTED:103,ECONNREFUSED:111,ECONNRESET:104,EDEADLK:35,EDESTADDRREQ:89,EDOM:33,EDQUOT:122,EEXIST:17,EFAULT:14,EFBIG:27,EHOSTUNREACH:113,EIDRM:43,EILSEQ:84,EINPROGRESS:115,EINTR:4,EINVAL:22,EIO:5,EISCONN:106,EISDIR:21,ELOOP:40,EMFILE:24,EMLINK:31,EMSGSIZE:90,EMULTIHOP:72,ENAMETOOLONG:36,ENETDOWN:100,ENETRESET:102,ENETUNREACH:101,ENFILE:23,ENOBUFS:105,ENODATA:61,ENODEV:19,ENOENT:2,ENOEXEC:8,ENOLCK:37,ENOLINK:67,ENOMEM:12,ENOMSG:42,ENOPROTOOPT:92,ENOSPC:28,ENOSR:63,ENOSTR:60,ENOSYS:38,ENOTCONN:107,ENOTDIR:20,ENOTEMPTY:39,ENOTRECOVERABLE:131,ENOTSOCK:88,ENOTSUP:95,ENOTTY:25,ENXIO:6,EOVERFLOW:75,EOWNERDEAD:130,EPERM:1,EPIPE:32,EPROTO:71,EPROTONOSUPPORT:93,EPROTOTYPE:91,ERANGE:34,EROFS:30,ESPIPE:29,ESRCH:3,ESTALE:116,ETIME:62,ETIMEDOUT:110,ETXTBSY:26,EWOULDBLOCK:11,EXDEV:18};
  
  function ___setErrNo(value) {
      // For convenient setting and returning of errno.
      if (!___setErrNo.ret) ___setErrNo.ret = allocate([0], 'i32', ALLOC_STATIC);
      HEAP32[((___setErrNo.ret)>>2)]=value
      return value;
    }
  
  var _stdin=allocate(1, "i32*", ALLOC_STACK);
  
  var _stdout=allocate(1, "i32*", ALLOC_STACK);
  
  var _stderr=allocate(1, "i32*", ALLOC_STACK);
  
  var __impure_ptr=allocate(1, "i32*", ALLOC_STACK);var FS={currentPath:"/",nextInode:2,streams:[null],ignorePermissions:true,joinPath:function (parts, forceRelative) {
        var ret = parts[0];
        for (var i = 1; i < parts.length; i++) {
          if (ret[ret.length-1] != '/') ret += '/';
          ret += parts[i];
        }
        if (forceRelative && ret[0] == '/') ret = ret.substr(1);
        return ret;
      },absolutePath:function (relative, base) {
        if (typeof relative !== 'string') return null;
        if (base === undefined) base = FS.currentPath;
        if (relative && relative[0] == '/') base = '';
        var full = base + '/' + relative;
        var parts = full.split('/').reverse();
        var absolute = [''];
        while (parts.length) {
          var part = parts.pop();
          if (part == '' || part == '.') {
            // Nothing.
          } else if (part == '..') {
            if (absolute.length > 1) absolute.pop();
          } else {
            absolute.push(part);
          }
        }
        return absolute.length == 1 ? '/' : absolute.join('/');
      },analyzePath:function (path, dontResolveLastLink, linksVisited) {
        var ret = {
          isRoot: false,
          exists: false,
          error: 0,
          name: null,
          path: null,
          object: null,
          parentExists: false,
          parentPath: null,
          parentObject: null
        };
        path = FS.absolutePath(path);
        if (path == '/') {
          ret.isRoot = true;
          ret.exists = ret.parentExists = true;
          ret.name = '/';
          ret.path = ret.parentPath = '/';
          ret.object = ret.parentObject = FS.root;
        } else if (path !== null) {
          linksVisited = linksVisited || 0;
          path = path.slice(1).split('/');
          var current = FS.root;
          var traversed = [''];
          while (path.length) {
            if (path.length == 1 && current.isFolder) {
              ret.parentExists = true;
              ret.parentPath = traversed.length == 1 ? '/' : traversed.join('/');
              ret.parentObject = current;
              ret.name = path[0];
            }
            var target = path.shift();
            if (!current.isFolder) {
              ret.error = ERRNO_CODES.ENOTDIR;
              break;
            } else if (!current.read) {
              ret.error = ERRNO_CODES.EACCES;
              break;
            } else if (!current.contents.hasOwnProperty(target)) {
              ret.error = ERRNO_CODES.ENOENT;
              break;
            }
            current = current.contents[target];
            if (current.link && !(dontResolveLastLink && path.length == 0)) {
              if (linksVisited > 40) { // Usual Linux SYMLOOP_MAX.
                ret.error = ERRNO_CODES.ELOOP;
                break;
              }
              var link = FS.absolutePath(current.link, traversed.join('/'));
              ret = FS.analyzePath([link].concat(path).join('/'),
                                   dontResolveLastLink, linksVisited + 1);
              return ret;
            }
            traversed.push(target);
            if (path.length == 0) {
              ret.exists = true;
              ret.path = traversed.join('/');
              ret.object = current;
            }
          }
        }
        return ret;
      },findObject:function (path, dontResolveLastLink) {
        FS.ensureRoot();
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (ret.exists) {
          return ret.object;
        } else {
          ___setErrNo(ret.error);
          return null;
        }
      },createObject:function (parent, name, properties, canRead, canWrite) {
        if (!parent) parent = '/';
        if (typeof parent === 'string') parent = FS.findObject(parent);
  
        if (!parent) {
          ___setErrNo(ERRNO_CODES.EACCES);
          throw new Error('Parent path must exist.');
        }
        if (!parent.isFolder) {
          ___setErrNo(ERRNO_CODES.ENOTDIR);
          throw new Error('Parent must be a folder.');
        }
        if (!parent.write && !FS.ignorePermissions) {
          ___setErrNo(ERRNO_CODES.EACCES);
          throw new Error('Parent folder must be writeable.');
        }
        if (!name || name == '.' || name == '..') {
          ___setErrNo(ERRNO_CODES.ENOENT);
          throw new Error('Name must not be empty.');
        }
        if (parent.contents.hasOwnProperty(name)) {
          ___setErrNo(ERRNO_CODES.EEXIST);
          throw new Error("Can't overwrite object.");
        }
  
        parent.contents[name] = {
          read: canRead === undefined ? true : canRead,
          write: canWrite === undefined ? false : canWrite,
          timestamp: Date.now(),
          inodeNumber: FS.nextInode++
        };
        for (var key in properties) {
          if (properties.hasOwnProperty(key)) {
            parent.contents[name][key] = properties[key];
          }
        }
  
        return parent.contents[name];
      },createFolder:function (parent, name, canRead, canWrite) {
        var properties = {isFolder: true, isDevice: false, contents: {}};
        return FS.createObject(parent, name, properties, canRead, canWrite);
      },createPath:function (parent, path, canRead, canWrite) {
        var current = FS.findObject(parent);
        if (current === null) throw new Error('Invalid parent.');
        path = path.split('/').reverse();
        while (path.length) {
          var part = path.pop();
          if (!part) continue;
          if (!current.contents.hasOwnProperty(part)) {
            FS.createFolder(current, part, canRead, canWrite);
          }
          current = current.contents[part];
        }
        return current;
      },createFile:function (parent, name, properties, canRead, canWrite) {
        properties.isFolder = false;
        return FS.createObject(parent, name, properties, canRead, canWrite);
      },createDataFile:function (parent, name, data, canRead, canWrite) {
        if (typeof data === 'string') {
          var dataArray = new Array(data.length);
          for (var i = 0, len = data.length; i < len; ++i) dataArray[i] = data.charCodeAt(i);
          data = dataArray;
        }
        var properties = {
          isDevice: false,
          contents: data.subarray ? data.subarray(0) : data // as an optimization, create a new array wrapper (not buffer) here, to help JS engines understand this object
        };
        return FS.createFile(parent, name, properties, canRead, canWrite);
      },createLazyFile:function (parent, name, url, canRead, canWrite) {
  
        if (typeof XMLHttpRequest !== 'undefined') {
          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
          // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.
          var LazyUint8Array = function(chunkSize, length) {
            this.length = length;
            this.chunkSize = chunkSize;
            this.chunks = []; // Loaded chunks. Index is the chunk number
          }
          LazyUint8Array.prototype.get = function(idx) {
            if (idx > this.length-1 || idx < 0) {
              return undefined;
            }
            var chunkOffset = idx % chunkSize;
            var chunkNum = Math.floor(idx / chunkSize);
            return this.getter(chunkNum)[chunkOffset];
          }
          LazyUint8Array.prototype.setDataGetter = function(getter) {
            this.getter = getter;
          }
    
          // Find length
          var xhr = new XMLHttpRequest();
          xhr.open('HEAD', url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var chunkSize = 1024*1024; // Chunk size in bytes
          if (!hasByteServing) chunkSize = datalength;
    
          // Function to get a range from the remote URL.
          var doXHR = (function(from, to) {
            if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength-1) throw new Error("only " + datalength + " bytes available! programmer error!");
    
            // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, false);
            if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
    
            // Some hints to the browser that we want binary data.
            if (typeof Uint8Array != 'undefined') xhr.responseType = 'arraybuffer';
            if (xhr.overrideMimeType) {
              xhr.overrideMimeType('text/plain; charset=x-user-defined');
            }
    
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            if (xhr.response !== undefined) {
              return new Uint8Array(xhr.response || []);
            } else {
              return intArrayFromString(xhr.responseText || '', true);
            }
          });
    
          var lazyArray = new LazyUint8Array(chunkSize, datalength);
          lazyArray.setDataGetter(function(chunkNum) {
            var start = chunkNum * lazyArray.chunkSize;
            var end = (chunkNum+1) * lazyArray.chunkSize - 1; // including this byte
            end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block
            if (typeof(lazyArray.chunks[chunkNum]) === "undefined") {
              lazyArray.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof(lazyArray.chunks[chunkNum]) === "undefined") throw new Error("doXHR failed!");
            return lazyArray.chunks[chunkNum];
          });
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }
  
        return FS.createFile(parent, name, properties, canRead, canWrite);
      },createPreloadedFile:function (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile) {
        Browser.ensureObjects();
        var fullname = FS.joinPath([parent, name], true);
        function processData(byteArray) {
          function finish(byteArray) {
            if (!dontCreateFile) {
              FS.createDataFile(parent, name, byteArray, canRead, canWrite);
            }
            if (onload) onload();
            removeRunDependency('cp ' + fullname);
          }
          var handled = false;
          Module['preloadPlugins'].forEach(function(plugin) {
            if (handled) return;
            if (plugin['canHandle'](fullname)) {
              plugin['handle'](byteArray, fullname, finish, function() {
                if (onerror) onerror();
                removeRunDependency('cp ' + fullname);
              });
              handled = true;
            }
          });
          if (!handled) finish(byteArray);
        }
        addRunDependency('cp ' + fullname);
        if (typeof url == 'string') {
          Browser.asyncLoad(url, function(byteArray) {
            processData(byteArray);
          }, onerror);
        } else {
          processData(url);
        }
      },createLink:function (parent, name, target, canRead, canWrite) {
        var properties = {isDevice: false, link: target};
        return FS.createFile(parent, name, properties, canRead, canWrite);
      },createDevice:function (parent, name, input, output) {
        if (!(input || output)) {
          throw new Error('A device must have at least one callback defined.');
        }
        var ops = {isDevice: true, input: input, output: output};
        return FS.createFile(parent, name, ops, Boolean(input), Boolean(output));
      },forceLoadFile:function (obj) {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
        var success = true;
        if (typeof XMLHttpRequest !== 'undefined') {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else if (Module['read']) {
          // Command-line.
          try {
            // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as
            //          read() will try to parse UTF8.
            obj.contents = intArrayFromString(Module['read'](obj.url), true);
          } catch (e) {
            success = false;
          }
        } else {
          throw new Error('Cannot load without read() or XMLHttpRequest.');
        }
        if (!success) ___setErrNo(ERRNO_CODES.EIO);
        return success;
      },ensureRoot:function () {
        if (FS.root) return;
        // The main file system tree. All the contents are inside this.
        FS.root = {
          read: true,
          write: true,
          isFolder: true,
          isDevice: false,
          timestamp: Date.now(),
          inodeNumber: 1,
          contents: {}
        };
      },init:function (input, output, error) {
        // Make sure we initialize only once.
        assert(!FS.init.initialized, 'FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)');
        FS.init.initialized = true;
  
        FS.ensureRoot();
  
        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here
        input = input || Module['stdin'];
        output = output || Module['stdout'];
        error = error || Module['stderr'];
  
        // Default handlers.
        var stdinOverridden = true, stdoutOverridden = true, stderrOverridden = true;
        if (!input) {
          stdinOverridden = false;
          input = function() {
            if (!input.cache || !input.cache.length) {
              var result;
              if (typeof window != 'undefined' &&
                  typeof window.prompt == 'function') {
                // Browser.
                result = window.prompt('Input: ');
                if (result === null) result = String.fromCharCode(0); // cancel ==> EOF
              } else if (typeof readline == 'function') {
                // Command line.
                result = readline();
              }
              if (!result) result = '';
              input.cache = intArrayFromString(result + '\n', true);
            }
            return input.cache.shift();
          };
        }
        var utf8 = new Runtime.UTF8Processor();
        function simpleOutput(val) {
          if (val === null || val === '\n'.charCodeAt(0)) {
            output.printer(output.buffer.join(''));
            output.buffer = [];
          } else {
            output.buffer.push(utf8.processCChar(val));
          }
        }
        if (!output) {
          stdoutOverridden = false;
          output = simpleOutput;
        }
        if (!output.printer) output.printer = Module['print'];
        if (!output.buffer) output.buffer = [];
        if (!error) {
          stderrOverridden = false;
          error = simpleOutput;
        }
        if (!error.printer) error.printer = Module['print'];
        if (!error.buffer) error.buffer = [];
  
        // Create the temporary folder, if not already created
        try {
          FS.createFolder('/', 'tmp', true, true);
        } catch(e) {}
  
        // Create the I/O devices.
        var devFolder = FS.createFolder('/', 'dev', true, true);
        var stdin = FS.createDevice(devFolder, 'stdin', input);
        var stdout = FS.createDevice(devFolder, 'stdout', null, output);
        var stderr = FS.createDevice(devFolder, 'stderr', null, error);
        FS.createDevice(devFolder, 'tty', input, output);
  
        // Create default streams.
        FS.streams[1] = {
          path: '/dev/stdin',
          object: stdin,
          position: 0,
          isRead: true,
          isWrite: false,
          isAppend: false,
          isTerminal: !stdinOverridden,
          error: false,
          eof: false,
          ungotten: []
        };
        FS.streams[2] = {
          path: '/dev/stdout',
          object: stdout,
          position: 0,
          isRead: false,
          isWrite: true,
          isAppend: false,
          isTerminal: !stdoutOverridden,
          error: false,
          eof: false,
          ungotten: []
        };
        FS.streams[3] = {
          path: '/dev/stderr',
          object: stderr,
          position: 0,
          isRead: false,
          isWrite: true,
          isAppend: false,
          isTerminal: !stderrOverridden,
          error: false,
          eof: false,
          ungotten: []
        };
        assert(Math.max(_stdin, _stdout, _stderr) < 128); // make sure these are low, we flatten arrays with these
        HEAP32[((_stdin)>>2)]=1;
        HEAP32[((_stdout)>>2)]=2;
        HEAP32[((_stderr)>>2)]=3;
  
        // Other system paths
        FS.createPath('/', 'dev/shm/tmp', true, true); // temp files
  
        // Newlib initialization
        for (var i = FS.streams.length; i < Math.max(_stdin, _stdout, _stderr) + 4; i++) {
          FS.streams[i] = null; // Make sure to keep FS.streams dense
        }
        FS.streams[_stdin] = FS.streams[1];
        FS.streams[_stdout] = FS.streams[2];
        FS.streams[_stderr] = FS.streams[3];
        allocate([ allocate(
          [0, 0, 0, 0, _stdin, 0, 0, 0, _stdout, 0, 0, 0, _stderr, 0, 0, 0],
          'void*', ALLOC_STATIC) ], 'void*', ALLOC_NONE, __impure_ptr);
      },quit:function () {
        if (!FS.init.initialized) return;
        // Flush any partially-printed lines in stdout and stderr. Careful, they may have been closed
        if (FS.streams[2] && FS.streams[2].object.output.buffer.length > 0) FS.streams[2].object.output('\n'.charCodeAt(0));
        if (FS.streams[3] && FS.streams[3].object.output.buffer.length > 0) FS.streams[3].object.output('\n'.charCodeAt(0));
      },standardizePath:function (path) {
        if (path.substr(0, 2) == './') path = path.substr(2);
        return path;
      },deleteFile:function (path) {
        path = FS.analyzePath(path);
        if (!path.parentExists || !path.exists) {
          throw 'Invalid path ' + path;
        }
        delete path.parentObject.contents[path.name];
      }};
  
  
  function _pwrite(fildes, buf, nbyte, offset) {
      // ssize_t pwrite(int fildes, const void *buf, size_t nbyte, off_t offset);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/write.html
      var stream = FS.streams[fildes];
      if (!stream || stream.object.isDevice) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      } else if (!stream.isWrite) {
        ___setErrNo(ERRNO_CODES.EACCES);
        return -1;
      } else if (stream.object.isFolder) {
        ___setErrNo(ERRNO_CODES.EISDIR);
        return -1;
      } else if (nbyte < 0 || offset < 0) {
        ___setErrNo(ERRNO_CODES.EINVAL);
        return -1;
      } else {
        var contents = stream.object.contents;
        while (contents.length < offset) contents.push(0);
        for (var i = 0; i < nbyte; i++) {
          contents[offset + i] = HEAPU8[(((buf)+(i))|0)];
        }
        stream.object.timestamp = Date.now();
        return i;
      }
    }function _write(fildes, buf, nbyte) {
      // ssize_t write(int fildes, const void *buf, size_t nbyte);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/write.html
      var stream = FS.streams[fildes];
      if (!stream) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      } else if (!stream.isWrite) {
        ___setErrNo(ERRNO_CODES.EACCES);
        return -1;
      } else if (nbyte < 0) {
        ___setErrNo(ERRNO_CODES.EINVAL);
        return -1;
      } else {
        if (stream.object.isDevice) {
          if (stream.object.output) {
            for (var i = 0; i < nbyte; i++) {
              try {
                stream.object.output(HEAP8[(((buf)+(i))|0)]);
              } catch (e) {
                ___setErrNo(ERRNO_CODES.EIO);
                return -1;
              }
            }
            stream.object.timestamp = Date.now();
            return i;
          } else {
            ___setErrNo(ERRNO_CODES.ENXIO);
            return -1;
          }
        } else {
          var bytesWritten = _pwrite(fildes, buf, nbyte, stream.position);
          if (bytesWritten != -1) stream.position += bytesWritten;
          return bytesWritten;
        }
      }
    }function _fwrite(ptr, size, nitems, stream) {
      // size_t fwrite(const void *restrict ptr, size_t size, size_t nitems, FILE *restrict stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fwrite.html
      var bytesToWrite = nitems * size;
      if (bytesToWrite == 0) return 0;
      var bytesWritten = _write(stream, ptr, bytesToWrite);
      if (bytesWritten == -1) {
        if (FS.streams[stream]) FS.streams[stream].error = true;
        return 0;
      } else {
        return Math.floor(bytesWritten / size);
      }
    }
  
  
  function _strlen(ptr) {
      ptr = ptr|0;
      var curr = 0;
      curr = ptr;
      while (HEAP8[(curr)]|0 != 0) {
        curr = (curr + 1)|0;
      }
      return (curr - ptr)|0;
    }function __formatString(format, varargs) {
      var textIndex = format;
      var argIndex = 0;
      function getNextArg(type) {
        // NOTE: Explicitly ignoring type safety. Otherwise this fails:
        //       int x = 4; printf("%c\n", (char)x);
        var ret;
        if (type === 'double') {
          ret = (HEAP32[((tempDoublePtr)>>2)]=HEAP32[(((varargs)+(argIndex))>>2)],HEAP32[(((tempDoublePtr)+(4))>>2)]=HEAP32[(((varargs)+((argIndex)+(4)))>>2)],HEAPF64[(tempDoublePtr)>>3]);
        } else if (type == 'i64') {
          ret = [HEAP32[(((varargs)+(argIndex))>>2)],
                 HEAP32[(((varargs)+(argIndex+4))>>2)]];
        } else {
          type = 'i32'; // varargs are always i32, i64, or double
          ret = HEAP32[(((varargs)+(argIndex))>>2)];
        }
        argIndex += Runtime.getNativeFieldSize(type);
        return ret;
      }
  
      var ret = [];
      var curr, next, currArg;
      while(1) {
        var startTextIndex = textIndex;
        curr = HEAP8[(textIndex)];
        if (curr === 0) break;
        next = HEAP8[((textIndex+1)|0)];
        if (curr == '%'.charCodeAt(0)) {
          // Handle flags.
          var flagAlwaysSigned = false;
          var flagLeftAlign = false;
          var flagAlternative = false;
          var flagZeroPad = false;
          flagsLoop: while (1) {
            switch (next) {
              case '+'.charCodeAt(0):
                flagAlwaysSigned = true;
                break;
              case '-'.charCodeAt(0):
                flagLeftAlign = true;
                break;
              case '#'.charCodeAt(0):
                flagAlternative = true;
                break;
              case '0'.charCodeAt(0):
                if (flagZeroPad) {
                  break flagsLoop;
                } else {
                  flagZeroPad = true;
                  break;
                }
              default:
                break flagsLoop;
            }
            textIndex++;
            next = HEAP8[((textIndex+1)|0)];
          }
  
          // Handle width.
          var width = 0;
          if (next == '*'.charCodeAt(0)) {
            width = getNextArg('i32');
            textIndex++;
            next = HEAP8[((textIndex+1)|0)];
          } else {
            while (next >= '0'.charCodeAt(0) && next <= '9'.charCodeAt(0)) {
              width = width * 10 + (next - '0'.charCodeAt(0));
              textIndex++;
              next = HEAP8[((textIndex+1)|0)];
            }
          }
  
          // Handle precision.
          var precisionSet = false;
          if (next == '.'.charCodeAt(0)) {
            var precision = 0;
            precisionSet = true;
            textIndex++;
            next = HEAP8[((textIndex+1)|0)];
            if (next == '*'.charCodeAt(0)) {
              precision = getNextArg('i32');
              textIndex++;
            } else {
              while(1) {
                var precisionChr = HEAP8[((textIndex+1)|0)];
                if (precisionChr < '0'.charCodeAt(0) ||
                    precisionChr > '9'.charCodeAt(0)) break;
                precision = precision * 10 + (precisionChr - '0'.charCodeAt(0));
                textIndex++;
              }
            }
            next = HEAP8[((textIndex+1)|0)];
          } else {
            var precision = 6; // Standard default.
          }
  
          // Handle integer sizes. WARNING: These assume a 32-bit architecture!
          var argSize;
          switch (String.fromCharCode(next)) {
            case 'h':
              var nextNext = HEAP8[((textIndex+2)|0)];
              if (nextNext == 'h'.charCodeAt(0)) {
                textIndex++;
                argSize = 1; // char (actually i32 in varargs)
              } else {
                argSize = 2; // short (actually i32 in varargs)
              }
              break;
            case 'l':
              var nextNext = HEAP8[((textIndex+2)|0)];
              if (nextNext == 'l'.charCodeAt(0)) {
                textIndex++;
                argSize = 8; // long long
              } else {
                argSize = 4; // long
              }
              break;
            case 'L': // long long
            case 'q': // int64_t
            case 'j': // intmax_t
              argSize = 8;
              break;
            case 'z': // size_t
            case 't': // ptrdiff_t
            case 'I': // signed ptrdiff_t or unsigned size_t
              argSize = 4;
              break;
            default:
              argSize = null;
          }
          if (argSize) textIndex++;
          next = HEAP8[((textIndex+1)|0)];
  
          // Handle type specifier.
          if (['d', 'i', 'u', 'o', 'x', 'X', 'p'].indexOf(String.fromCharCode(next)) != -1) {
            // Integer.
            var signed = next == 'd'.charCodeAt(0) || next == 'i'.charCodeAt(0);
            argSize = argSize || 4;
            var currArg = getNextArg('i' + (argSize * 8));
            var origArg = currArg;
            var argText;
            // Flatten i64-1 [low, high] into a (slightly rounded) double
            if (argSize == 8) {
              currArg = Runtime.makeBigInt(currArg[0], currArg[1], next == 'u'.charCodeAt(0));
            }
            // Truncate to requested size.
            if (argSize <= 4) {
              var limit = Math.pow(256, argSize) - 1;
              currArg = (signed ? reSign : unSign)(currArg & limit, argSize * 8);
            }
            // Format the number.
            var currAbsArg = Math.abs(currArg);
            var prefix = '';
            if (next == 'd'.charCodeAt(0) || next == 'i'.charCodeAt(0)) {
              if (argSize == 8 && i64Math) argText = i64Math.stringify(origArg[0], origArg[1], null); else
              argText = reSign(currArg, 8 * argSize, 1).toString(10);
            } else if (next == 'u'.charCodeAt(0)) {
              if (argSize == 8 && i64Math) argText = i64Math.stringify(origArg[0], origArg[1], true); else
              argText = unSign(currArg, 8 * argSize, 1).toString(10);
              currArg = Math.abs(currArg);
            } else if (next == 'o'.charCodeAt(0)) {
              argText = (flagAlternative ? '0' : '') + currAbsArg.toString(8);
            } else if (next == 'x'.charCodeAt(0) || next == 'X'.charCodeAt(0)) {
              prefix = flagAlternative ? '0x' : '';
              if (argSize == 8 && i64Math) argText = (origArg[1]>>>0).toString(16) + (origArg[0]>>>0).toString(16); else
              if (currArg < 0) {
                // Represent negative numbers in hex as 2's complement.
                currArg = -currArg;
                argText = (currAbsArg - 1).toString(16);
                var buffer = [];
                for (var i = 0; i < argText.length; i++) {
                  buffer.push((0xF - parseInt(argText[i], 16)).toString(16));
                }
                argText = buffer.join('');
                while (argText.length < argSize * 2) argText = 'f' + argText;
              } else {
                argText = currAbsArg.toString(16);
              }
              if (next == 'X'.charCodeAt(0)) {
                prefix = prefix.toUpperCase();
                argText = argText.toUpperCase();
              }
            } else if (next == 'p'.charCodeAt(0)) {
              if (currAbsArg === 0) {
                argText = '(nil)';
              } else {
                prefix = '0x';
                argText = currAbsArg.toString(16);
              }
            }
            if (precisionSet) {
              while (argText.length < precision) {
                argText = '0' + argText;
              }
            }
  
            // Add sign if needed
            if (flagAlwaysSigned) {
              if (currArg < 0) {
                prefix = '-' + prefix;
              } else {
                prefix = '+' + prefix;
              }
            }
  
            // Add padding.
            while (prefix.length + argText.length < width) {
              if (flagLeftAlign) {
                argText += ' ';
              } else {
                if (flagZeroPad) {
                  argText = '0' + argText;
                } else {
                  prefix = ' ' + prefix;
                }
              }
            }
  
            // Insert the result into the buffer.
            argText = prefix + argText;
            argText.split('').forEach(function(chr) {
              ret.push(chr.charCodeAt(0));
            });
          } else if (['f', 'F', 'e', 'E', 'g', 'G'].indexOf(String.fromCharCode(next)) != -1) {
            // Float.
            var currArg = getNextArg('double');
            var argText;
  
            if (isNaN(currArg)) {
              argText = 'nan';
              flagZeroPad = false;
            } else if (!isFinite(currArg)) {
              argText = (currArg < 0 ? '-' : '') + 'inf';
              flagZeroPad = false;
            } else {
              var isGeneral = false;
              var effectivePrecision = Math.min(precision, 20);
  
              // Convert g/G to f/F or e/E, as per:
              // http://pubs.opengroup.org/onlinepubs/9699919799/functions/printf.html
              if (next == 'g'.charCodeAt(0) || next == 'G'.charCodeAt(0)) {
                isGeneral = true;
                precision = precision || 1;
                var exponent = parseInt(currArg.toExponential(effectivePrecision).split('e')[1], 10);
                if (precision > exponent && exponent >= -4) {
                  next = ((next == 'g'.charCodeAt(0)) ? 'f' : 'F').charCodeAt(0);
                  precision -= exponent + 1;
                } else {
                  next = ((next == 'g'.charCodeAt(0)) ? 'e' : 'E').charCodeAt(0);
                  precision--;
                }
                effectivePrecision = Math.min(precision, 20);
              }
  
              if (next == 'e'.charCodeAt(0) || next == 'E'.charCodeAt(0)) {
                argText = currArg.toExponential(effectivePrecision);
                // Make sure the exponent has at least 2 digits.
                if (/[eE][-+]\d$/.test(argText)) {
                  argText = argText.slice(0, -1) + '0' + argText.slice(-1);
                }
              } else if (next == 'f'.charCodeAt(0) || next == 'F'.charCodeAt(0)) {
                argText = currArg.toFixed(effectivePrecision);
              }
  
              var parts = argText.split('e');
              if (isGeneral && !flagAlternative) {
                // Discard trailing zeros and periods.
                while (parts[0].length > 1 && parts[0].indexOf('.') != -1 &&
                       (parts[0].slice(-1) == '0' || parts[0].slice(-1) == '.')) {
                  parts[0] = parts[0].slice(0, -1);
                }
              } else {
                // Make sure we have a period in alternative mode.
                if (flagAlternative && argText.indexOf('.') == -1) parts[0] += '.';
                // Zero pad until required precision.
                while (precision > effectivePrecision++) parts[0] += '0';
              }
              argText = parts[0] + (parts.length > 1 ? 'e' + parts[1] : '');
  
              // Capitalize 'E' if needed.
              if (next == 'E'.charCodeAt(0)) argText = argText.toUpperCase();
  
              // Add sign.
              if (flagAlwaysSigned && currArg >= 0) {
                argText = '+' + argText;
              }
            }
  
            // Add padding.
            while (argText.length < width) {
              if (flagLeftAlign) {
                argText += ' ';
              } else {
                if (flagZeroPad && (argText[0] == '-' || argText[0] == '+')) {
                  argText = argText[0] + '0' + argText.slice(1);
                } else {
                  argText = (flagZeroPad ? '0' : ' ') + argText;
                }
              }
            }
  
            // Adjust case.
            if (next < 'a'.charCodeAt(0)) argText = argText.toUpperCase();
  
            // Insert the result into the buffer.
            argText.split('').forEach(function(chr) {
              ret.push(chr.charCodeAt(0));
            });
          } else if (next == 's'.charCodeAt(0)) {
            // String.
            var arg = getNextArg('i8*') || nullString;
            var argLength = _strlen(arg);
            if (precisionSet) argLength = Math.min(argLength, precision);
            if (!flagLeftAlign) {
              while (argLength < width--) {
                ret.push(' '.charCodeAt(0));
              }
            }
            for (var i = 0; i < argLength; i++) {
              ret.push(HEAPU8[((arg++)|0)]);
            }
            if (flagLeftAlign) {
              while (argLength < width--) {
                ret.push(' '.charCodeAt(0));
              }
            }
          } else if (next == 'c'.charCodeAt(0)) {
            // Character.
            if (flagLeftAlign) ret.push(getNextArg('i8'));
            while (--width > 0) {
              ret.push(' '.charCodeAt(0));
            }
            if (!flagLeftAlign) ret.push(getNextArg('i8'));
          } else if (next == 'n'.charCodeAt(0)) {
            // Write the length written so far to the next parameter.
            var ptr = getNextArg('i32*');
            HEAP32[((ptr)>>2)]=ret.length
          } else if (next == '%'.charCodeAt(0)) {
            // Literal percent sign.
            ret.push(curr);
          } else {
            // Unknown specifiers remain untouched.
            for (var i = startTextIndex; i < textIndex + 2; i++) {
              ret.push(HEAP8[(i)]);
            }
          }
          textIndex += 2;
          // TODO: Support a/A (hex float) and m (last error) specifiers.
          // TODO: Support %1${specifier} for arg selection.
        } else {
          ret.push(curr);
          textIndex += 1;
        }
      }
      return ret;
    }function _fprintf(stream, format, varargs) {
      // int fprintf(FILE *restrict stream, const char *restrict format, ...);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/printf.html
      var result = __formatString(format, varargs);
      var stack = Runtime.stackSave();
      var ret = _fwrite(allocate(result, 'i8', ALLOC_STACK), 1, result.length, stream);
      Runtime.stackRestore(stack);
      return ret;
    }

  
  function _memcpy(dest, src, num) {
      dest = dest|0; src = src|0; num = num|0;
      var ret = 0;
      ret = dest|0;
      if ((dest&3) == (src&3)) {
        while (dest & 3) {
          if ((num|0) == 0) return ret|0;
          HEAP8[(dest)]=HEAP8[(src)];
          dest = (dest+1)|0;
          src = (src+1)|0;
          num = (num-1)|0;
        }
        while ((num|0) >= 4) {
          HEAP32[((dest)>>2)]=HEAP32[((src)>>2)];
          dest = (dest+4)|0;
          src = (src+4)|0;
          num = (num-4)|0;
        }
      }
      while ((num|0) > 0) {
        HEAP8[(dest)]=HEAP8[(src)];
        dest = (dest+1)|0;
        src = (src+1)|0;
        num = (num-1)|0;
      }
      return ret|0;
    }var _llvm_memcpy_p0i8_p0i8_i32=_memcpy;

  function _qsort(base, num, size, cmp) {
      if (num == 0 || size == 0) return;
      // forward calls to the JavaScript sort method
      // first, sort the items logically
      var comparator = function(x, y) {
        return Runtime.dynCall('iii', cmp, [x, y]);
      }
      var keys = [];
      for (var i = 0; i < num; i++) keys.push(i);
      keys.sort(function(a, b) {
        return comparator(base+a*size, base+b*size);
      });
      // apply the sort
      var temp = _malloc(num*size);
      _memcpy(temp, base, num*size);
      for (var i = 0; i < num; i++) {
        if (keys[i] == i) continue; // already in place
        _memcpy(base+i*size, temp+keys[i]*size, size);
      }
      _free(temp);
    }

  
  function _memset(ptr, value, num) {
      ptr = ptr|0; value = value|0; num = num|0;
      var stop = 0, value4 = 0, stop4 = 0, unaligned = 0;
      stop = (ptr + num)|0;
      if ((num|0) >= 20) {
        // This is unaligned, but quite large, so work hard to get to aligned settings
        value = value & 0xff;
        unaligned = ptr & 3;
        value4 = value | (value << 8) | (value << 16) | (value << 24);
        stop4 = stop & ~3;
        if (unaligned) {
          unaligned = (ptr + 4 - unaligned)|0;
          while ((ptr|0) < (unaligned|0)) { // no need to check for stop, since we have large num
            HEAP8[(ptr)]=value;
            ptr = (ptr+1)|0;
          }
        }
        while ((ptr|0) < (stop4|0)) {
          HEAP32[((ptr)>>2)]=value4;
          ptr = (ptr+4)|0;
        }
      }
      while ((ptr|0) < (stop|0)) {
        HEAP8[(ptr)]=value;
        ptr = (ptr+1)|0;
      }
    }var _llvm_memset_p0i8_i32=_memset;

  var _log=Math.log;

  var ctlz_i8 = [8,7,6,6,5,5,5,5,4,4,4,4,4,4,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];function _llvm_ctlz_i32(x) {
      var ret = ctlz_i8[x >>> 24];
      if (ret < 8) return ret;
      var ret = ctlz_i8[(x >> 16)&0xff];
      if (ret < 8) return ret + 8;
      var ret = ctlz_i8[(x >> 8)&0xff];
      if (ret < 8) return ret + 16;
      return ctlz_i8[x&0xff] + 24;
    }

  
  
  var ___dirent_struct_layout={__size__:1040,d_ino:0,d_name:4,d_off:1028,d_reclen:1032,d_type:1036};function _open(path, oflag, varargs) {
      // int open(const char *path, int oflag, ...);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/open.html
      // NOTE: This implementation tries to mimic glibc rather than strictly
      // following the POSIX standard.
  
      var mode = HEAP32[((varargs)>>2)];
  
      // Simplify flags.
      var accessMode = oflag & 3;
      var isWrite = accessMode != 0;
      var isRead = accessMode != 1;
      var isCreate = Boolean(oflag & 512);
      var isExistCheck = Boolean(oflag & 2048);
      var isTruncate = Boolean(oflag & 1024);
      var isAppend = Boolean(oflag & 8);
  
      // Verify path.
      var origPath = path;
      path = FS.analyzePath(Pointer_stringify(path));
      if (!path.parentExists) {
        ___setErrNo(path.error);
        return -1;
      }
      var target = path.object || null;
      var finalPath;
  
      // Verify the file exists, create if needed and allowed.
      if (target) {
        if (isCreate && isExistCheck) {
          ___setErrNo(ERRNO_CODES.EEXIST);
          return -1;
        }
        if ((isWrite || isCreate || isTruncate) && target.isFolder) {
          ___setErrNo(ERRNO_CODES.EISDIR);
          return -1;
        }
        if (isRead && !target.read || isWrite && !target.write) {
          ___setErrNo(ERRNO_CODES.EACCES);
          return -1;
        }
        if (isTruncate && !target.isDevice) {
          target.contents = [];
        } else {
          if (!FS.forceLoadFile(target)) {
            ___setErrNo(ERRNO_CODES.EIO);
            return -1;
          }
        }
        finalPath = path.path;
      } else {
        if (!isCreate) {
          ___setErrNo(ERRNO_CODES.ENOENT);
          return -1;
        }
        if (!path.parentObject.write) {
          ___setErrNo(ERRNO_CODES.EACCES);
          return -1;
        }
        target = FS.createDataFile(path.parentObject, path.name, [],
                                   mode & 0x100, mode & 0x80);  // S_IRUSR, S_IWUSR.
        finalPath = path.parentPath + '/' + path.name;
      }
      // Actually create an open stream.
      var id = FS.streams.length; // Keep dense
      if (target.isFolder) {
        var entryBuffer = 0;
        if (___dirent_struct_layout) {
          entryBuffer = _malloc(___dirent_struct_layout.__size__);
        }
        var contents = [];
        for (var key in target.contents) contents.push(key);
        FS.streams[id] = {
          path: finalPath,
          object: target,
          // An index into contents. Special values: -2 is ".", -1 is "..".
          position: -2,
          isRead: true,
          isWrite: false,
          isAppend: false,
          error: false,
          eof: false,
          ungotten: [],
          // Folder-specific properties:
          // Remember the contents at the time of opening in an array, so we can
          // seek between them relying on a single order.
          contents: contents,
          // Each stream has its own area for readdir() returns.
          currentEntry: entryBuffer
        };
      } else {
        FS.streams[id] = {
          path: finalPath,
          object: target,
          position: 0,
          isRead: isRead,
          isWrite: isWrite,
          isAppend: isAppend,
          error: false,
          eof: false,
          ungotten: []
        };
      }
      return id;
    }function _fopen(filename, mode) {
      // FILE *fopen(const char *restrict filename, const char *restrict mode);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fopen.html
      var flags;
      mode = Pointer_stringify(mode);
      if (mode[0] == 'r') {
        if (mode.indexOf('+') != -1) {
          flags = 2;
        } else {
          flags = 0;
        }
      } else if (mode[0] == 'w') {
        if (mode.indexOf('+') != -1) {
          flags = 2;
        } else {
          flags = 1;
        }
        flags |= 512;
        flags |= 1024;
      } else if (mode[0] == 'a') {
        if (mode.indexOf('+') != -1) {
          flags = 2;
        } else {
          flags = 1;
        }
        flags |= 512;
        flags |= 8;
      } else {
        ___setErrNo(ERRNO_CODES.EINVAL);
        return 0;
      }
      var ret = _open(filename, flags, allocate([0x1FF, 0, 0, 0], 'i32', ALLOC_STACK));  // All creation permissions.
      return (ret == -1) ? 0 : ret;
    }

  
  
  function _pread(fildes, buf, nbyte, offset) {
      // ssize_t pread(int fildes, void *buf, size_t nbyte, off_t offset);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/read.html
      var stream = FS.streams[fildes];
      if (!stream || stream.object.isDevice) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      } else if (!stream.isRead) {
        ___setErrNo(ERRNO_CODES.EACCES);
        return -1;
      } else if (stream.object.isFolder) {
        ___setErrNo(ERRNO_CODES.EISDIR);
        return -1;
      } else if (nbyte < 0 || offset < 0) {
        ___setErrNo(ERRNO_CODES.EINVAL);
        return -1;
      } else {
        var bytesRead = 0;
        while (stream.ungotten.length && nbyte > 0) {
          HEAP8[((buf++)|0)]=stream.ungotten.pop()
          nbyte--;
          bytesRead++;
        }
        var contents = stream.object.contents;
        var size = Math.min(contents.length - offset, nbyte);
        if (contents.subarray || contents.slice) { // typed array or normal array
          for (var i = 0; i < size; i++) {
            HEAP8[(((buf)+(i))|0)]=contents[offset + i]
          }
        } else {
          for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR
            HEAP8[(((buf)+(i))|0)]=contents.get(offset + i)
          }
        }
        bytesRead += size;
        return bytesRead;
      }
    }function _read(fildes, buf, nbyte) {
      // ssize_t read(int fildes, void *buf, size_t nbyte);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/read.html
      var stream = FS.streams[fildes];
      if (!stream) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      } else if (!stream.isRead) {
        ___setErrNo(ERRNO_CODES.EACCES);
        return -1;
      } else if (nbyte < 0) {
        ___setErrNo(ERRNO_CODES.EINVAL);
        return -1;
      } else {
        var bytesRead;
        if (stream.object.isDevice) {
          if (stream.object.input) {
            bytesRead = 0;
            while (stream.ungotten.length && nbyte > 0) {
              HEAP8[((buf++)|0)]=stream.ungotten.pop()
              nbyte--;
              bytesRead++;
            }
            for (var i = 0; i < nbyte; i++) {
              try {
                var result = stream.object.input();
              } catch (e) {
                ___setErrNo(ERRNO_CODES.EIO);
                return -1;
              }
              if (result === null || result === undefined) break;
              bytesRead++;
              HEAP8[(((buf)+(i))|0)]=result
            }
            return bytesRead;
          } else {
            ___setErrNo(ERRNO_CODES.ENXIO);
            return -1;
          }
        } else {
          var ungotSize = stream.ungotten.length;
          bytesRead = _pread(fildes, buf, nbyte, stream.position);
          if (bytesRead != -1) {
            stream.position += (stream.ungotten.length - ungotSize) + bytesRead;
          }
          return bytesRead;
        }
      }
    }function _fread(ptr, size, nitems, stream) {
      // size_t fread(void *restrict ptr, size_t size, size_t nitems, FILE *restrict stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fread.html
      var bytesToRead = nitems * size;
      if (bytesToRead == 0) return 0;
      var bytesRead = _read(stream, ptr, bytesToRead);
      var streamObj = FS.streams[stream];
      if (bytesRead == -1) {
        if (streamObj) streamObj.error = true;
        return 0;
      } else {
        if (bytesRead < bytesToRead) streamObj.eof = true;
        return Math.floor(bytesRead / size);
      }
    }

  function _abort() {
      ABORT = true;
      throw 'abort() at ' + (new Error().stack);
    }

  
  function ___errno_location() {
      return ___setErrNo.ret;
    }var ___errno=___errno_location;

  function _sysconf(name) {
      // long sysconf(int name);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/sysconf.html
      switch(name) {
        case 8: return PAGE_SIZE;
        case 54:
        case 56:
        case 21:
        case 61:
        case 63:
        case 22:
        case 67:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 69:
        case 28:
        case 101:
        case 70:
        case 71:
        case 29:
        case 30:
        case 199:
        case 75:
        case 76:
        case 32:
        case 43:
        case 44:
        case 80:
        case 46:
        case 47:
        case 45:
        case 48:
        case 49:
        case 42:
        case 82:
        case 33:
        case 7:
        case 108:
        case 109:
        case 107:
        case 112:
        case 119:
        case 121:
          return 200809;
        case 13:
        case 104:
        case 94:
        case 95:
        case 34:
        case 35:
        case 77:
        case 81:
        case 83:
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 91:
        case 94:
        case 95:
        case 110:
        case 111:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 120:
        case 40:
        case 16:
        case 79:
        case 19:
          return -1;
        case 92:
        case 93:
        case 5:
        case 72:
        case 6:
        case 74:
        case 92:
        case 93:
        case 96:
        case 97:
        case 98:
        case 99:
        case 102:
        case 103:
        case 105:
          return 1;
        case 38:
        case 66:
        case 50:
        case 51:
        case 4:
          return 1024;
        case 15:
        case 64:
        case 41:
          return 32;
        case 55:
        case 37:
        case 17:
          return 2147483647;
        case 18:
        case 1:
          return 47839;
        case 59:
        case 57:
          return 99;
        case 68:
        case 58:
          return 2048;
        case 0: return 2097152;
        case 3: return 65536;
        case 14: return 32768;
        case 73: return 32767;
        case 39: return 16384;
        case 60: return 1000;
        case 106: return 700;
        case 52: return 256;
        case 62: return 255;
        case 2: return 100;
        case 65: return 64;
        case 36: return 20;
        case 100: return 16;
        case 20: return 6;
        case 53: return 4;
      }
      ___setErrNo(ERRNO_CODES.EINVAL);
      return -1;
    }

  function _time(ptr) {
      var ret = Math.floor(Date.now()/1000);
      if (ptr) {
        HEAP32[((ptr)>>2)]=ret
      }
      return ret;
    }

  function _sbrk(bytes) {
      // Implement a Linux-like 'memory area' for our 'process'.
      // Changes the size of the memory area by |bytes|; returns the
      // address of the previous top ('break') of the memory area
  
      // We need to make sure no one else allocates unfreeable memory!
      // We must control this entirely. So we don't even need to do
      // unfreeable allocations - the HEAP is ours, from STATICTOP up.
      // TODO: We could in theory slice off the top of the HEAP when
      //       sbrk gets a negative increment in |bytes|...
      var self = _sbrk;
      if (!self.called) {
        STATICTOP = alignMemoryPage(STATICTOP); // make sure we start out aligned
        self.called = true;
        _sbrk.DYNAMIC_START = STATICTOP;
      }
      var ret = STATICTOP;
      if (bytes != 0) Runtime.staticAlloc(bytes);
      return ret;  // Previous break location.
    }

  function ___gxx_personality_v0() {
    }

  function ___cxa_allocate_exception(size) {
      return _malloc(size);
    }

  
  function _llvm_eh_exception() {
      return HEAP32[((_llvm_eh_exception.buf)>>2)];
    }
  
  function __ZSt18uncaught_exceptionv() { // std::uncaught_exception()
      return !!__ZSt18uncaught_exceptionv.uncaught_exception;
    }
  
  
  
  function ___cxa_is_number_type(type) {
      var isNumber = false;
      try { if (type == __ZTIi) isNumber = true } catch(e){}
      try { if (type == __ZTIj) isNumber = true } catch(e){}
      try { if (type == __ZTIl) isNumber = true } catch(e){}
      try { if (type == __ZTIm) isNumber = true } catch(e){}
      try { if (type == __ZTIx) isNumber = true } catch(e){}
      try { if (type == __ZTIy) isNumber = true } catch(e){}
      try { if (type == __ZTIf) isNumber = true } catch(e){}
      try { if (type == __ZTId) isNumber = true } catch(e){}
      try { if (type == __ZTIe) isNumber = true } catch(e){}
      try { if (type == __ZTIc) isNumber = true } catch(e){}
      try { if (type == __ZTIa) isNumber = true } catch(e){}
      try { if (type == __ZTIh) isNumber = true } catch(e){}
      try { if (type == __ZTIs) isNumber = true } catch(e){}
      try { if (type == __ZTIt) isNumber = true } catch(e){}
      return isNumber;
    }function ___cxa_does_inherit(definiteType, possibilityType, possibility) {
      if (possibility == 0) return false;
      if (possibilityType == 0 || possibilityType == definiteType)
        return true;
      var possibility_type_info;
      if (___cxa_is_number_type(possibilityType)) {
        possibility_type_info = possibilityType;
      } else {
        var possibility_type_infoAddr = HEAP32[((possibilityType)>>2)] - 8;
        possibility_type_info = HEAP32[((possibility_type_infoAddr)>>2)];
      }
      switch (possibility_type_info) {
      case 0: // possibility is a pointer
        // See if definite type is a pointer
        var definite_type_infoAddr = HEAP32[((definiteType)>>2)] - 8;
        var definite_type_info = HEAP32[((definite_type_infoAddr)>>2)];
        if (definite_type_info == 0) {
          // Also a pointer; compare base types of pointers
          var defPointerBaseAddr = definiteType+8;
          var defPointerBaseType = HEAP32[((defPointerBaseAddr)>>2)];
          var possPointerBaseAddr = possibilityType+8;
          var possPointerBaseType = HEAP32[((possPointerBaseAddr)>>2)];
          return ___cxa_does_inherit(defPointerBaseType, possPointerBaseType, possibility);
        } else
          return false; // one pointer and one non-pointer
      case 1: // class with no base class
        return false;
      case 2: // class with base class
        var parentTypeAddr = possibilityType + 8;
        var parentType = HEAP32[((parentTypeAddr)>>2)];
        return ___cxa_does_inherit(definiteType, parentType, possibility);
      default:
        return false; // some unencountered type
      }
    }function ___cxa_find_matching_catch(thrown, throwntype, typeArray) {
      // If throwntype is a pointer, this means a pointer has been
      // thrown. When a pointer is thrown, actually what's thrown
      // is a pointer to the pointer. We'll dereference it.
      if (throwntype != 0 && !___cxa_is_number_type(throwntype)) {
        var throwntypeInfoAddr= HEAP32[((throwntype)>>2)] - 8;
        var throwntypeInfo= HEAP32[((throwntypeInfoAddr)>>2)];
        if (throwntypeInfo == 0)
          thrown = HEAP32[((thrown)>>2)];
      }
      // The different catch blocks are denoted by different types.
      // Due to inheritance, those types may not precisely match the
      // type of the thrown object. Find one which matches, and
      // return the type of the catch block which should be called.
      for (var i = 0; i < typeArray.length; i++) {
        if (___cxa_does_inherit(typeArray[i], throwntype, thrown))
          return (tempRet0 = typeArray[i],thrown);
      }
      // Shouldn't happen unless we have bogus data in typeArray
      // or encounter a type for which emscripten doesn't have suitable
      // typeinfo defined. Best-efforts match just in case.
      return (tempRet0 = throwntype,thrown);
    }function ___cxa_throw(ptr, type, destructor) {
      if (!___cxa_throw.initialized) {
        try {
          HEAP32[((__ZTVN10__cxxabiv119__pointer_type_infoE)>>2)]=0; // Workaround for libcxxabi integration bug
        } catch(e){}
        try {
          HEAP32[((__ZTVN10__cxxabiv117__class_type_infoE)>>2)]=1; // Workaround for libcxxabi integration bug
        } catch(e){}
        try {
          HEAP32[((__ZTVN10__cxxabiv120__si_class_type_infoE)>>2)]=2; // Workaround for libcxxabi integration bug
        } catch(e){}
        ___cxa_throw.initialized = true;
      }
      HEAP32[((_llvm_eh_exception.buf)>>2)]=ptr
      HEAP32[(((_llvm_eh_exception.buf)+(4))>>2)]=type
      HEAP32[(((_llvm_eh_exception.buf)+(8))>>2)]=destructor
      if (!("uncaught_exception" in __ZSt18uncaught_exceptionv)) {
        __ZSt18uncaught_exceptionv.uncaught_exception = 1;
      } else {
        __ZSt18uncaught_exceptionv.uncaught_exception++;
      }
      throw ptr + " - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch.";;
    }

  function ___cxa_call_unexpected(exception) {
      Module.printErr('Unexpected exception thrown, this is not properly supported - aborting');
      ABORT = true;
      throw exception;
    }

  function ___cxa_begin_catch(ptr) {
      __ZSt18uncaught_exceptionv.uncaught_exception--;
      return ptr;
    }

  
  function ___cxa_free_exception(ptr) {
      return _free(ptr);
    }function ___cxa_end_catch() {
      if (___cxa_end_catch.rethrown) {
        ___cxa_end_catch.rethrown = false;
        return;
      }
      // Clear state flag.
      __THREW__ = 0;
      // Clear type.
      HEAP32[(((_llvm_eh_exception.buf)+(4))>>2)]=0
      // Call destructor if one is registered then clear it.
      var ptr = HEAP32[((_llvm_eh_exception.buf)>>2)];
      var destructor = HEAP32[(((_llvm_eh_exception.buf)+(8))>>2)];
      if (destructor) {
        Runtime.dynCall('vi', destructor, [ptr]);
        HEAP32[(((_llvm_eh_exception.buf)+(8))>>2)]=0
      }
      // Free ptr if it isn't null.
      if (ptr) {
        ___cxa_free_exception(ptr);
        HEAP32[((_llvm_eh_exception.buf)>>2)]=0
      }
    }

  function __ZNSt9exceptionD2Ev(){}


  var _llvm_memset_p0i8_i64=_memset;





  var Browser={mainLoop:{scheduler:null,shouldPause:false,paused:false,queue:[],pause:function () {
          Browser.mainLoop.shouldPause = true;
        },resume:function () {
          if (Browser.mainLoop.paused) {
            Browser.mainLoop.paused = false;
            Browser.mainLoop.scheduler();
          }
          Browser.mainLoop.shouldPause = false;
        },updateStatus:function () {
          if (Module['setStatus']) {
            var message = Module['statusMessage'] || 'Please wait...';
            var remaining = Browser.mainLoop.remainingBlockers;
            var expected = Browser.mainLoop.expectedBlockers;
            if (remaining) {
              if (remaining < expected) {
                Module['setStatus'](message + ' (' + (expected - remaining) + '/' + expected + ')');
              } else {
                Module['setStatus'](message);
              }
            } else {
              Module['setStatus']('');
            }
          }
        }},pointerLock:false,moduleContextCreatedCallbacks:[],workers:[],ensureObjects:function () {
        if (Browser.ensured) return;
        Browser.ensured = true;
        try {
          new Blob();
          Browser.hasBlobConstructor = true;
        } catch(e) {
          Browser.hasBlobConstructor = false;
          console.log("warning: no blob constructor, cannot create blobs with mimetypes");
        }
        Browser.BlobBuilder = typeof MozBlobBuilder != "undefined" ? MozBlobBuilder : (typeof WebKitBlobBuilder != "undefined" ? WebKitBlobBuilder : (!Browser.hasBlobConstructor ? console.log("warning: no BlobBuilder") : null));
        Browser.URLObject = typeof window != "undefined" ? (window.URL ? window.URL : window.webkitURL) : console.log("warning: cannot create object URLs");
  
        // Support for plugins that can process preloaded files. You can add more of these to
        // your app by creating and appending to Module.preloadPlugins.
        //
        // Each plugin is asked if it can handle a file based on the file's name. If it can,
        // it is given the file's raw data. When it is done, it calls a callback with the file's
        // (possibly modified) data. For example, a plugin might decompress a file, or it
        // might create some side data structure for use later (like an Image element, etc.).
  
        function getMimetype(name) {
          return {
            'jpg': 'image/jpeg',
            'jpeg': 'image/jpeg',
            'png': 'image/png',
            'bmp': 'image/bmp',
            'ogg': 'audio/ogg',
            'wav': 'audio/wav',
            'mp3': 'audio/mpeg'
          }[name.substr(-3)];
          return ret;
        }
  
        if (!Module["preloadPlugins"]) Module["preloadPlugins"] = [];
  
        var imagePlugin = {};
        imagePlugin['canHandle'] = function(name) {
          return !Module.noImageDecoding && /\.(jpg|jpeg|png|bmp)$/.exec(name);
        };
        imagePlugin['handle'] = function(byteArray, name, onload, onerror) {
          var b = null;
          if (Browser.hasBlobConstructor) {
            try {
              b = new Blob([byteArray], { type: getMimetype(name) });
            } catch(e) {
              Runtime.warnOnce('Blob constructor present but fails: ' + e + '; falling back to blob builder');
            }
          }
          if (!b) {
            var bb = new Browser.BlobBuilder();
            bb.append((new Uint8Array(byteArray)).buffer); // we need to pass a buffer, and must copy the array to get the right data range
            b = bb.getBlob();
          }
          var url = Browser.URLObject.createObjectURL(b);
          var img = new Image();
          img.onload = function() {
            assert(img.complete, 'Image ' + name + ' could not be decoded');
            var canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            var ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            Module["preloadedImages"][name] = canvas;
            Browser.URLObject.revokeObjectURL(url);
            if (onload) onload(byteArray);
          };
          img.onerror = function(event) {
            console.log('Image ' + url + ' could not be decoded');
            if (onerror) onerror();
          };
          img.src = url;
        };
        Module['preloadPlugins'].push(imagePlugin);
  
        var audioPlugin = {};
        audioPlugin['canHandle'] = function(name) {
          return !Module.noAudioDecoding && name.substr(-4) in { '.ogg': 1, '.wav': 1, '.mp3': 1 };
        };
        audioPlugin['handle'] = function(byteArray, name, onload, onerror) {
          var done = false;
          function finish(audio) {
            if (done) return;
            done = true;
            Module["preloadedAudios"][name] = audio;
            if (onload) onload(byteArray);
          }
          function fail() {
            if (done) return;
            done = true;
            Module["preloadedAudios"][name] = new Audio(); // empty shim
            if (onerror) onerror();
          }
          if (Browser.hasBlobConstructor) {
            try {
              var b = new Blob([byteArray], { type: getMimetype(name) });
            } catch(e) {
              return fail();
            }
            var url = Browser.URLObject.createObjectURL(b); // XXX we never revoke this!
            var audio = new Audio();
            audio.addEventListener('canplaythrough', function() { finish(audio) }, false); // use addEventListener due to chromium bug 124926
            audio.onerror = function(event) {
              if (done) return;
              console.log('warning: browser could not fully decode audio ' + name + ', trying slower base64 approach');
              function encode64(data) {
                var BASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                var PAD = '=';
                var ret = '';
                var leftchar = 0;
                var leftbits = 0;
                for (var i = 0; i < data.length; i++) {
                  leftchar = (leftchar << 8) | data[i];
                  leftbits += 8;
                  while (leftbits >= 6) {
                    var curr = (leftchar >> (leftbits-6)) & 0x3f;
                    leftbits -= 6;
                    ret += BASE[curr];
                  }
                }
                if (leftbits == 2) {
                  ret += BASE[(leftchar&3) << 4];
                  ret += PAD + PAD;
                } else if (leftbits == 4) {
                  ret += BASE[(leftchar&0xf) << 2];
                  ret += PAD;
                }
                return ret;
              }
              audio.src = 'data:audio/x-' + name.substr(-3) + ';base64,' + encode64(byteArray);
              finish(audio); // we don't wait for confirmation this worked - but it's worth trying
            };
            audio.src = url;
            // workaround for chrome bug 124926 - we do not always get oncanplaythrough or onerror
            setTimeout(function() {
              finish(audio); // try to use it even though it is not necessarily ready to play
            }, 10000);
          } else {
            return fail();
          }
        };
        Module['preloadPlugins'].push(audioPlugin);
      },createContext:function (canvas, useWebGL, setInModule) {
        var ctx;
        try {
          if (useWebGL) {
            ctx = canvas.getContext('experimental-webgl', {
              alpha: false,
            });
          } else {
            ctx = canvas.getContext('2d');
          }
          if (!ctx) throw ':(';
        } catch (e) {
          Module.print('Could not create canvas - ' + e);
          return null;
        }
        if (useWebGL) {
          // Set the background of the WebGL canvas to black
          canvas.style.backgroundColor = "black";
  
          // Warn on context loss
          canvas.addEventListener('webglcontextlost', function(event) {
            alert('WebGL context lost. You will need to reload the page.');
          }, false);
        }
        if (setInModule) {
          Module.ctx = ctx;
          Module.useWebGL = useWebGL;
          Browser.moduleContextCreatedCallbacks.forEach(function(callback) { callback() });
        }
        return ctx;
      },destroyContext:function (canvas, useWebGL, setInModule) {},requestFullScreen:function () {
        var canvas = Module['canvas'];
        function fullScreenChange() {
          var isFullScreen = false;
          if ((document['webkitFullScreenElement'] || document['webkitFullscreenElement'] ||
               document['mozFullScreenElement'] || document['mozFullscreenElement'] ||
               document['fullScreenElement'] || document['fullscreenElement']) === canvas) {
            canvas.requestPointerLock = canvas['requestPointerLock'] ||
                                        canvas['mozRequestPointerLock'] ||
                                        canvas['webkitRequestPointerLock'];
            canvas.requestPointerLock();
            isFullScreen = true;
          }
          if (Module['onFullScreen']) Module['onFullScreen'](isFullScreen);
        }
  
        document.addEventListener('fullscreenchange', fullScreenChange, false);
        document.addEventListener('mozfullscreenchange', fullScreenChange, false);
        document.addEventListener('webkitfullscreenchange', fullScreenChange, false);
  
        function pointerLockChange() {
          Browser.pointerLock = document['pointerLockElement'] === canvas ||
                                document['mozPointerLockElement'] === canvas ||
                                document['webkitPointerLockElement'] === canvas;
        }
  
        document.addEventListener('pointerlockchange', pointerLockChange, false);
        document.addEventListener('mozpointerlockchange', pointerLockChange, false);
        document.addEventListener('webkitpointerlockchange', pointerLockChange, false);
  
        canvas.requestFullScreen = canvas['requestFullScreen'] ||
                                   canvas['mozRequestFullScreen'] ||
                                   (canvas['webkitRequestFullScreen'] ? function() { canvas['webkitRequestFullScreen'](Element['ALLOW_KEYBOARD_INPUT']) } : null);
        canvas.requestFullScreen(); 
      },requestAnimationFrame:function (func) {
        if (!window.requestAnimationFrame) {
          window.requestAnimationFrame = window['requestAnimationFrame'] ||
                                         window['mozRequestAnimationFrame'] ||
                                         window['webkitRequestAnimationFrame'] ||
                                         window['msRequestAnimationFrame'] ||
                                         window['oRequestAnimationFrame'] ||
                                         window['setTimeout'];
        }
        window.requestAnimationFrame(func);
      },getMovementX:function (event) {
        return event['movementX'] ||
               event['mozMovementX'] ||
               event['webkitMovementX'] ||
               0;
      },getMovementY:function (event) {
        return event['movementY'] ||
               event['mozMovementY'] ||
               event['webkitMovementY'] ||
               0;
      },xhrLoad:function (url, onload, onerror) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.responseType = 'arraybuffer';
        xhr.onload = function() {
          if (xhr.status == 200) {
            onload(xhr.response);
          } else {
            onerror();
          }
        };
        xhr.onerror = onerror;
        xhr.send(null);
      },asyncLoad:function (url, onload, onerror, noRunDep) {
        Browser.xhrLoad(url, function(arrayBuffer) {
          assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
          onload(new Uint8Array(arrayBuffer));
          if (!noRunDep) removeRunDependency('al ' + url);
        }, function(event) {
          if (onerror) {
            onerror();
          } else {
            throw 'Loading data file "' + url + '" failed.';
          }
        });
        if (!noRunDep) addRunDependency('al ' + url);
      },resizeListeners:[],updateResizeListeners:function () {
        var canvas = Module['canvas'];
        Browser.resizeListeners.forEach(function(listener) {
          listener(canvas.width, canvas.height);
        });
      },setCanvasSize:function (width, height, noUpdates) {
        var canvas = Module['canvas'];
        canvas.width = width;
        canvas.height = height;
        if (!noUpdates) Browser.updateResizeListeners();
      }};
__ATINIT__.unshift({ func: function() { if (!Module["noFSInit"] && !FS.init.initialized) FS.init() } });__ATMAIN__.push({ func: function() { FS.ignorePermissions = false } });__ATEXIT__.push({ func: function() { FS.quit() } });Module["FS_createFolder"] = FS.createFolder;Module["FS_createPath"] = FS.createPath;Module["FS_createDataFile"] = FS.createDataFile;Module["FS_createPreloadedFile"] = FS.createPreloadedFile;Module["FS_createLazyFile"] = FS.createLazyFile;Module["FS_createLink"] = FS.createLink;Module["FS_createDevice"] = FS.createDevice;
___setErrNo(0);
_llvm_eh_exception.buf = allocate(12, "void*", ALLOC_STATIC);
Module["requestFullScreen"] = function() { Browser.requestFullScreen() };
  Module["requestAnimationFrame"] = function(func) { Browser.requestAnimationFrame(func) };
  Module["pauseMainLoop"] = function() { Browser.mainLoop.pause() };
  Module["resumeMainLoop"] = function() { Browser.mainLoop.resume() };
  


var FUNCTION_TABLE = [0,0,__ZNSt20bad_array_new_lengthD0Ev,0,__ZNSt9bad_allocD1Ev,0,_GetCostStat,0,__ZNKSt9bad_alloc4whatEv,0,__ZNKSt20bad_array_new_length4whatEv,0,__ZNSt9bad_allocD0Ev,0,_LeafComparator,0,__ZNSt20bad_array_new_lengthD1Ev,0,_GetCostFixed,0];

function _FindLargestSplittableBlock(r1, r2, r3, r4, r5, r6) {
  var r7, r8, r9, r10, r11, r12, r13, r14;
  r7 = r1 - 1 | 0;
  r1 = 0;
  r8 = 0;
  r9 = 0;
  while (1) {
    if ((r1 | 0) == 0) {
      r10 = 0;
    } else {
      r10 = HEAP32[r3 + (r1 - 1 << 2) >> 2];
    }
    if ((r1 | 0) == (r4 | 0)) {
      r11 = r7;
    } else {
      r11 = HEAP32[r3 + (r1 << 2) >> 2];
    }
    do {
      if (HEAP8[r2 + r10 | 0] << 24 >> 24 == 0) {
        r12 = r11 - r10 | 0;
        if (r12 >>> 0 <= r9 >>> 0) {
          r13 = r9;
          r14 = r8;
          break;
        }
        HEAP32[r5 >> 2] = r10;
        HEAP32[r6 >> 2] = r11;
        r13 = r12;
        r14 = 1;
      } else {
        r13 = r9;
        r14 = r8;
      }
    } while (0);
    r12 = r1 + 1 | 0;
    if (r12 >>> 0 > r4 >>> 0) {
      break;
    } else {
      r1 = r12;
      r8 = r14;
      r9 = r13;
    }
  }
  return r14;
}
function _ZopfliMaxCachedSublen(r1, r2, r3) {
  var r4;
  r3 = r2 * 24 & -1;
  r2 = HEAP32[r1 + 8 >> 2];
  do {
    if (HEAP8[r2 + (r3 | 1) | 0] << 24 >> 24 == 0) {
      if (HEAP8[r2 + (r3 | 2) | 0] << 24 >> 24 == 0) {
        r4 = 0;
      } else {
        break;
      }
      return r4;
    }
  } while (0);
  r4 = HEAPU8[r3 + (r2 + 21) | 0] + 3 | 0;
  return r4;
}
function _FindMinimum(r1, r2, r3) {
  var r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26;
  r4 = 0;
  r5 = STACKTOP;
  STACKTOP = STACKTOP + 108 | 0;
  r6 = r5 >> 2;
  r7 = r5 + 36;
  if ((r3 - r2 | 0) >>> 0 < 1024) {
    if (r2 >>> 0 < r3 >>> 0) {
      r8 = 1e+30;
      r9 = r2;
      r10 = r2;
    } else {
      r11 = r2;
      STACKTOP = r5;
      return r11;
    }
    while (1) {
      r12 = _SplitCost(r10, r1);
      r13 = r12 < r8;
      r14 = r13 ? r10 : r9;
      r15 = r10 + 1 | 0;
      if ((r15 | 0) == (r3 | 0)) {
        r11 = r14;
        break;
      } else {
        r8 = r13 ? r12 : r8;
        r9 = r14;
        r10 = r15;
      }
    }
    STACKTOP = r5;
    return r11;
  }
  r10 = r3 - r2 | 0;
  if (r10 >>> 0 < 10) {
    r11 = r2;
    STACKTOP = r5;
    return r11;
  }
  r9 = r7 | 0;
  r8 = r2;
  r15 = r3;
  r3 = 1e+30;
  r14 = r2;
  r2 = r10;
  while (1) {
    r10 = Math.floor((r2 >>> 0) / 10);
    r12 = r10 + r8 | 0;
    HEAP32[r6] = r12;
    r13 = _SplitCost(r12, r1);
    r12 = r7 | 0;
    HEAPF64[tempDoublePtr >> 3] = r13, HEAP32[r12 >> 2] = HEAP32[tempDoublePtr >> 2], HEAP32[r12 + 4 >> 2] = HEAP32[tempDoublePtr + 4 >> 2];
    r12 = (r10 << 1) + r8 | 0;
    HEAP32[r6 + 1] = r12;
    r13 = _SplitCost(r12, r1);
    r12 = r7 + 8 | 0;
    HEAPF64[tempDoublePtr >> 3] = r13, HEAP32[r12 >> 2] = HEAP32[tempDoublePtr >> 2], HEAP32[r12 + 4 >> 2] = HEAP32[tempDoublePtr + 4 >> 2];
    r12 = (r10 * 3 & -1) + r8 | 0;
    HEAP32[r6 + 2] = r12;
    r13 = _SplitCost(r12, r1);
    r12 = r7 + 16 | 0;
    HEAPF64[tempDoublePtr >> 3] = r13, HEAP32[r12 >> 2] = HEAP32[tempDoublePtr >> 2], HEAP32[r12 + 4 >> 2] = HEAP32[tempDoublePtr + 4 >> 2];
    r12 = (r10 << 2) + r8 | 0;
    HEAP32[r6 + 3] = r12;
    r13 = _SplitCost(r12, r1);
    r12 = r7 + 24 | 0;
    HEAPF64[tempDoublePtr >> 3] = r13, HEAP32[r12 >> 2] = HEAP32[tempDoublePtr >> 2], HEAP32[r12 + 4 >> 2] = HEAP32[tempDoublePtr + 4 >> 2];
    r12 = (r10 * 5 & -1) + r8 | 0;
    HEAP32[r6 + 4] = r12;
    r13 = _SplitCost(r12, r1);
    r12 = r7 + 32 | 0;
    HEAPF64[tempDoublePtr >> 3] = r13, HEAP32[r12 >> 2] = HEAP32[tempDoublePtr >> 2], HEAP32[r12 + 4 >> 2] = HEAP32[tempDoublePtr + 4 >> 2];
    r12 = (r10 * 6 & -1) + r8 | 0;
    HEAP32[r6 + 5] = r12;
    r13 = _SplitCost(r12, r1);
    r12 = r7 + 40 | 0;
    HEAPF64[tempDoublePtr >> 3] = r13, HEAP32[r12 >> 2] = HEAP32[tempDoublePtr >> 2], HEAP32[r12 + 4 >> 2] = HEAP32[tempDoublePtr + 4 >> 2];
    r12 = (r10 * 7 & -1) + r8 | 0;
    HEAP32[r6 + 6] = r12;
    r13 = _SplitCost(r12, r1);
    r12 = r7 + 48 | 0;
    HEAPF64[tempDoublePtr >> 3] = r13, HEAP32[r12 >> 2] = HEAP32[tempDoublePtr >> 2], HEAP32[r12 + 4 >> 2] = HEAP32[tempDoublePtr + 4 >> 2];
    r12 = (r10 << 3) + r8 | 0;
    HEAP32[r6 + 7] = r12;
    r13 = _SplitCost(r12, r1);
    r12 = r7 + 56 | 0;
    HEAPF64[tempDoublePtr >> 3] = r13, HEAP32[r12 >> 2] = HEAP32[tempDoublePtr >> 2], HEAP32[r12 + 4 >> 2] = HEAP32[tempDoublePtr + 4 >> 2];
    r12 = (r10 * 9 & -1) + r8 | 0;
    HEAP32[r6 + 8] = r12;
    r10 = _SplitCost(r12, r1);
    r12 = r7 + 64 | 0;
    HEAPF64[tempDoublePtr >> 3] = r10, HEAP32[r12 >> 2] = HEAP32[tempDoublePtr >> 2], HEAP32[r12 + 4 >> 2] = HEAP32[tempDoublePtr + 4 >> 2];
    r12 = (HEAP32[tempDoublePtr >> 2] = HEAP32[r9 >> 2], HEAP32[tempDoublePtr + 4 >> 2] = HEAP32[r9 + 4 >> 2], HEAPF64[tempDoublePtr >> 3]);
    r10 = r7 + 8 | 0;
    r13 = (HEAP32[tempDoublePtr >> 2] = HEAP32[r10 >> 2], HEAP32[tempDoublePtr + 4 >> 2] = HEAP32[r10 + 4 >> 2], HEAPF64[tempDoublePtr >> 3]);
    r10 = r13 < r12;
    r16 = r10 ? r13 : r12;
    r12 = r7 + 16 | 0;
    r13 = (HEAP32[tempDoublePtr >> 2] = HEAP32[r12 >> 2], HEAP32[tempDoublePtr + 4 >> 2] = HEAP32[r12 + 4 >> 2], HEAPF64[tempDoublePtr >> 3]);
    r12 = r13 < r16;
    r17 = r12 ? r13 : r16;
    r16 = r7 + 24 | 0;
    r13 = (HEAP32[tempDoublePtr >> 2] = HEAP32[r16 >> 2], HEAP32[tempDoublePtr + 4 >> 2] = HEAP32[r16 + 4 >> 2], HEAPF64[tempDoublePtr >> 3]);
    r16 = r13 < r17;
    r18 = r16 ? r13 : r17;
    r17 = r7 + 32 | 0;
    r13 = (HEAP32[tempDoublePtr >> 2] = HEAP32[r17 >> 2], HEAP32[tempDoublePtr + 4 >> 2] = HEAP32[r17 + 4 >> 2], HEAPF64[tempDoublePtr >> 3]);
    r17 = r13 < r18;
    r19 = r17 ? r13 : r18;
    r18 = r7 + 40 | 0;
    r13 = (HEAP32[tempDoublePtr >> 2] = HEAP32[r18 >> 2], HEAP32[tempDoublePtr + 4 >> 2] = HEAP32[r18 + 4 >> 2], HEAPF64[tempDoublePtr >> 3]);
    r18 = r13 < r19;
    r20 = r18 ? r13 : r19;
    r19 = r7 + 48 | 0;
    r13 = (HEAP32[tempDoublePtr >> 2] = HEAP32[r19 >> 2], HEAP32[tempDoublePtr + 4 >> 2] = HEAP32[r19 + 4 >> 2], HEAPF64[tempDoublePtr >> 3]);
    r19 = r13 < r20;
    r21 = r19 ? r13 : r20;
    r20 = r7 + 56 | 0;
    r13 = (HEAP32[tempDoublePtr >> 2] = HEAP32[r20 >> 2], HEAP32[tempDoublePtr + 4 >> 2] = HEAP32[r20 + 4 >> 2], HEAPF64[tempDoublePtr >> 3]);
    r20 = r13 < r21;
    r22 = r20 ? r13 : r21;
    r21 = r7 + 64 | 0;
    r13 = (HEAP32[tempDoublePtr >> 2] = HEAP32[r21 >> 2], HEAP32[tempDoublePtr + 4 >> 2] = HEAP32[r21 + 4 >> 2], HEAPF64[tempDoublePtr >> 3]);
    r21 = r13 < r22;
    r23 = r21 ? 8 : r20 ? 7 : r19 ? 6 : r18 ? 5 : r17 ? 4 : r16 ? 3 : r12 ? 2 : r10 & 1;
    r10 = r21 ? r13 : r22;
    if (r10 > r3) {
      r11 = r14;
      r4 = 30;
      break;
    }
    do {
      if ((r23 | 0) == 0) {
        r24 = r8;
        r4 = 25;
      } else {
        r22 = HEAP32[(r23 - 1 << 2 >> 2) + r6];
        if ((r23 | 0) == 8) {
          r25 = r15;
          r26 = r22;
          break;
        } else {
          r24 = r22;
          r4 = 25;
          break;
        }
      }
    } while (0);
    if (r4 == 25) {
      r4 = 0;
      r25 = HEAP32[(r23 + 1 << 2 >> 2) + r6];
      r26 = r24;
    }
    r22 = HEAP32[(r23 << 2 >> 2) + r6];
    r13 = r25 - r26 | 0;
    if (r13 >>> 0 < 10) {
      r11 = r22;
      r4 = 32;
      break;
    } else {
      r8 = r26;
      r15 = r25;
      r3 = r10;
      r14 = r22;
      r2 = r13;
    }
  }
  if (r4 == 30) {
    STACKTOP = r5;
    return r11;
  } else if (r4 == 32) {
    STACKTOP = r5;
    return r11;
  }
}
function _SplitCost(r1, r2) {
  var r3, r4;
  r3 = r2;
  r4 = r2 + 4 | 0;
  return _EstimateCost(HEAP32[r3 >> 2], HEAP32[r4 >> 2], HEAP32[r2 + 12 >> 2], r1) + _EstimateCost(HEAP32[r3 >> 2], HEAP32[r4 >> 2], r1, HEAP32[r2 + 16 >> 2]);
}
function _EstimateCost(r1, r2, r3, r4) {
  return _ZopfliCalculateBlockSize(r1, r2, r3, r4, 2);
}
function _AddSorted(r1, r2, r3) {
  var r4, r5, r6, r7;
  r4 = r3 >> 2;
  r3 = r2 >> 2;
  r2 = 0;
  r5 = HEAP32[r4];
  if ((r5 - 1 & r5 | 0) == 0) {
    if ((r5 | 0) == 0) {
      r6 = _malloc(4);
    } else {
      r6 = _realloc(HEAP32[r3], r5 << 3);
    }
    HEAP32[r3] = r6;
  }
  HEAP32[HEAP32[r3] + (HEAP32[r4] << 2) >> 2] = r1;
  r6 = HEAP32[r4] + 1 | 0;
  HEAP32[r4] = r6;
  if ((r6 | 0) == 0) {
    return;
  }
  r6 = HEAP32[r4] - 1 | 0;
  r4 = 0;
  while (1) {
    if (r4 >>> 0 >= r6 >>> 0) {
      r2 = 49;
      break;
    }
    if (HEAP32[HEAP32[r3] + (r4 << 2) >> 2] >>> 0 > r1 >>> 0) {
      break;
    } else {
      r4 = r4 + 1 | 0;
    }
  }
  if (r2 == 49) {
    return;
  }
  L62 : do {
    if (r6 >>> 0 > r4 >>> 0) {
      r2 = r6;
      while (1) {
        r5 = r2 - 1 | 0;
        r7 = HEAP32[r3];
        HEAP32[r7 + (r2 << 2) >> 2] = HEAP32[r7 + (r5 << 2) >> 2];
        if (r5 >>> 0 > r4 >>> 0) {
          r2 = r5;
        } else {
          break L62;
        }
      }
    }
  } while (0);
  HEAP32[HEAP32[r3] + (r4 << 2) >> 2] = r1;
  return;
}
function _PrintBlockSplitPoints(r1, r2, r3, r4, r5) {
  var r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26;
  r6 = STACKTOP;
  L68 : do {
    if ((r5 | 0) == 0 | (r3 | 0) == 0) {
      r7 = 0;
      r8 = 0;
    } else {
      r9 = 0;
      r10 = 0;
      r11 = 0;
      r12 = 0;
      while (1) {
        if (HEAP16[r2 + (r10 << 1) >> 1] << 16 >> 16 == 0) {
          r13 = 1;
        } else {
          r13 = HEAPU16[r1 + (r10 << 1) >> 1];
        }
        if ((HEAP32[r4 + (r9 << 2) >> 2] | 0) == (r10 | 0)) {
          if ((r9 - 1 & r9 | 0) == 0) {
            if ((r9 | 0) == 0) {
              r14 = _malloc(4);
            } else {
              r14 = _realloc(r12, r9 << 3);
            }
            r15 = r14;
          } else {
            r15 = r12;
          }
          HEAP32[r15 + (r9 << 2) >> 2] = r11;
          r16 = r9 + 1 | 0;
          if ((r16 | 0) == (r5 | 0)) {
            r7 = r15;
            r8 = r16;
            break L68;
          } else {
            r17 = r15;
            r18 = r16;
          }
        } else {
          r17 = r12;
          r18 = r9;
        }
        r16 = r10 + 1 | 0;
        if (r16 >>> 0 < r3 >>> 0) {
          r9 = r18;
          r10 = r16;
          r11 = r13 + r11 | 0;
          r12 = r17;
        } else {
          r7 = r17;
          r8 = r18;
          break L68;
        }
      }
    }
  } while (0);
  if ((r8 | 0) != (r5 | 0)) {
    ___assert_func(5245916, 171, 5246748, 5244568);
  }
  _fwrite(5244392, 20, 1, HEAP32[_stderr >> 2]);
  r5 = HEAP32[_stderr >> 2];
  if ((r8 | 0) == 0) {
    _fwrite(5244176, 5, 1, r5);
    r19 = HEAP32[_stderr >> 2];
    r20 = _fwrite(5245896, 2, 1, r19);
    r21 = r7;
    _free(r21);
    STACKTOP = r6;
    return;
  } else {
    r22 = 0;
    r23 = r5;
  }
  while (1) {
    _fprintf(r23, 5244292, (tempInt = STACKTOP, STACKTOP = STACKTOP + 4 | 0, HEAP32[tempInt >> 2] = HEAP32[r7 + (r22 << 2) >> 2], tempInt));
    r5 = r22 + 1 | 0;
    r24 = HEAP32[_stderr >> 2];
    if ((r5 | 0) == (r8 | 0)) {
      break;
    } else {
      r22 = r5;
      r23 = r24;
    }
  }
  _fwrite(5244176, 5, 1, r24);
  r24 = HEAP32[_stderr >> 2];
  if ((r8 | 0) == 0) {
    r19 = r24;
    r20 = _fwrite(5245896, 2, 1, r19);
    r21 = r7;
    _free(r21);
    STACKTOP = r6;
    return;
  } else {
    r25 = 0;
    r26 = r24;
  }
  while (1) {
    _fprintf(r26, 5244120, (tempInt = STACKTOP, STACKTOP = STACKTOP + 4 | 0, HEAP32[tempInt >> 2] = HEAP32[r7 + (r25 << 2) >> 2], tempInt));
    r24 = r25 + 1 | 0;
    r23 = HEAP32[_stderr >> 2];
    if ((r24 | 0) == (r8 | 0)) {
      r19 = r23;
      break;
    } else {
      r25 = r24;
      r26 = r23;
    }
  }
  r20 = _fwrite(5245896, 2, 1, r19);
  r21 = r7;
  _free(r21);
  STACKTOP = r6;
  return;
}
function _ZopfliBlockSplit(r1, r2, r3, r4, r5, r6, r7) {
  var r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21, r22;
  r8 = r7 >> 2;
  r7 = STACKTOP;
  STACKTOP = STACKTOP + 36 | 0;
  r9 = r7, r10 = r9 >> 2;
  r11 = r7 + 16, r12 = r11 >> 2;
  r13 = r7 + 20, r14 = r13 >> 2;
  r15 = r7 + 24;
  HEAP32[r12] = 0;
  HEAP32[r14] = 0;
  _ZopfliInitLZ77Store(r15);
  HEAP32[r10] = r1;
  HEAP32[r10 + 2] = r3;
  HEAP32[r10 + 3] = r4;
  HEAP32[r10 + 1] = 0;
  HEAP32[r8] = 0;
  HEAP32[r6 >> 2] = 0;
  _ZopfliLZ77Greedy(r9, r2, r3, r4, r15);
  r4 = r15 | 0;
  r2 = r15 + 4 | 0;
  r9 = (r15 + 8 | 0) >> 2;
  _ZopfliBlockSplitLZ77(r1, HEAP32[r4 >> 2], HEAP32[r2 >> 2], HEAP32[r9], r5, r11, r13);
  L100 : do {
    if ((HEAP32[r14] | 0) != 0) {
      if ((HEAP32[r9] | 0) == 0) {
        break;
      }
      r13 = HEAP32[r2 >> 2];
      r11 = HEAP32[r12];
      r5 = HEAP32[r14];
      r1 = HEAP32[r9];
      r10 = HEAP32[r4 >> 2];
      r16 = 0;
      r17 = r3;
      while (1) {
        if (HEAP16[r13 + (r16 << 1) >> 1] << 16 >> 16 == 0) {
          r18 = 1;
        } else {
          r18 = HEAPU16[r10 + (r16 << 1) >> 1];
        }
        r19 = HEAP32[r8];
        if ((HEAP32[r11 + (r19 << 2) >> 2] | 0) == (r16 | 0)) {
          if ((r19 - 1 & r19 | 0) == 0) {
            if ((r19 | 0) == 0) {
              r20 = _malloc(4);
            } else {
              r20 = _realloc(HEAP32[r6 >> 2], r19 << 3);
            }
            HEAP32[r6 >> 2] = r20;
          }
          HEAP32[HEAP32[r6 >> 2] + (HEAP32[r8] << 2) >> 2] = r17;
          r19 = HEAP32[r8] + 1 | 0;
          HEAP32[r8] = r19;
          if ((r19 | 0) == (r5 | 0)) {
            break L100;
          }
        }
        r19 = r16 + 1 | 0;
        if (r19 >>> 0 < r1 >>> 0) {
          r16 = r19;
          r17 = r18 + r17 | 0;
        } else {
          break L100;
        }
      }
    }
  } while (0);
  if ((HEAP32[r8] | 0) == (HEAP32[r14] | 0)) {
    r21 = HEAP32[r12];
    r22 = r21;
    _free(r22);
    _ZopfliCleanLZ77Store(r15);
    STACKTOP = r7;
    return;
  }
  ___assert_func(5245916, 327, 5246656, 5244684);
  r21 = HEAP32[r12];
  r22 = r21;
  _free(r22);
  _ZopfliCleanLZ77Store(r15);
  STACKTOP = r7;
  return;
}
function _ZopfliBlockSplitSimple(r1, r2, r3, r4, r5, r6) {
  var r7, r8, r9;
  if (r2 >>> 0 >= r3 >>> 0) {
    return;
  }
  r1 = r2;
  r2 = HEAP32[r6 >> 2];
  while (1) {
    if ((r2 - 1 & r2 | 0) == 0) {
      if ((r2 | 0) == 0) {
        r7 = _malloc(4);
      } else {
        r7 = _realloc(HEAP32[r5 >> 2], r2 << 3);
      }
      HEAP32[r5 >> 2] = r7;
    }
    HEAP32[HEAP32[r5 >> 2] + (HEAP32[r6 >> 2] << 2) >> 2] = r1;
    r8 = HEAP32[r6 >> 2] + 1 | 0;
    HEAP32[r6 >> 2] = r8;
    r9 = r1 + r4 | 0;
    if (r9 >>> 0 < r3 >>> 0) {
      r1 = r9;
      r2 = r8;
    } else {
      break;
    }
  }
  return;
}
function _ZopfliInitCache(r1, r2) {
  var r3, r4, r5, r6, r7, r8;
  r3 = r1 << 1;
  r4 = r2 | 0;
  HEAP32[r4 >> 2] = _malloc(r3);
  r5 = r2 + 4 | 0;
  HEAP32[r5 >> 2] = _malloc(r3);
  r3 = r1 * 24 & -1;
  r6 = r2 + 8 | 0;
  HEAP32[r6 >> 2] = _malloc(r3);
  L138 : do {
    if ((r1 | 0) != 0) {
      r2 = 0;
      while (1) {
        HEAP16[HEAP32[r4 >> 2] + (r2 << 1) >> 1] = 1;
        r7 = r2 + 1 | 0;
        if ((r7 | 0) == (r1 | 0)) {
          break;
        } else {
          r2 = r7;
        }
      }
      if ((r1 | 0) == 0) {
        break;
      } else {
        r8 = 0;
      }
      while (1) {
        HEAP16[HEAP32[r5 >> 2] + (r8 << 1) >> 1] = 0;
        r2 = r8 + 1 | 0;
        if ((r2 | 0) == (r1 | 0)) {
          break L138;
        } else {
          r8 = r2;
        }
      }
    }
  } while (0);
  if ((r3 | 0) == 0) {
    return;
  }
  r3 = r1 * 24 & -1;
  r1 = 0;
  while (1) {
    HEAP8[HEAP32[r6 >> 2] + r1 | 0] = 0;
    r8 = r1 + 1 | 0;
    if ((r8 | 0) == (r3 | 0)) {
      break;
    } else {
      r1 = r8;
    }
  }
  return;
}
function _ZopfliCleanCache(r1) {
  _free(HEAP32[r1 >> 2]);
  _free(HEAP32[r1 + 4 >> 2]);
  _free(HEAP32[r1 + 8 >> 2]);
  return;
}
function _ZopfliSublenToCache(r1, r2, r3, r4) {
  var r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18;
  r5 = 0;
  r6 = r2 * 24 & -1;
  r7 = HEAP32[r4 + 8 >> 2];
  if (r3 >>> 0 < 3) {
    return;
  }
  r8 = r6 | 1;
  r9 = r6 | 2;
  r10 = 0;
  r11 = 0;
  r12 = 3;
  while (1) {
    do {
      if ((r12 | 0) == (r3 | 0)) {
        r5 = 117;
      } else {
        if (HEAP16[r1 + (r12 << 1) >> 1] << 16 >> 16 == HEAP16[r1 + (r12 + 1 << 1) >> 1] << 16 >> 16) {
          r13 = r11;
          r14 = r10;
          break;
        } else {
          r5 = 117;
          break;
        }
      }
    } while (0);
    if (r5 == 117) {
      r5 = 0;
      r15 = r10 * 3 & -1;
      HEAP8[r7 + r15 + r6 | 0] = r12 + 253 & 255;
      r16 = (r12 << 1) + r1 | 0;
      HEAP8[r7 + r8 + r15 | 0] = HEAP16[r16 >> 1] & 255;
      HEAP8[r7 + r9 + r15 | 0] = HEAPU16[r16 >> 1] >>> 8 & 255;
      r16 = r10 + 1 | 0;
      if (r16 >>> 0 > 7) {
        r17 = r12;
        r5 = 123;
        break;
      } else {
        r13 = r12;
        r14 = r16;
      }
    }
    r16 = r12 + 1 | 0;
    if (r16 >>> 0 > r3 >>> 0) {
      r5 = 119;
      break;
    } else {
      r10 = r14;
      r11 = r13;
      r12 = r16;
    }
  }
  do {
    if (r5 == 119) {
      if (r14 >>> 0 >= 8) {
        r17 = r13;
        r5 = 123;
        break;
      }
      if ((r13 | 0) != (r3 | 0)) {
        ___assert_func(5245788, 73, 5246464, 5245764);
      }
      HEAP8[r6 + (r7 + 21) | 0] = r13 + 253 & 255;
      r18 = r13;
      break;
    }
  } while (0);
  do {
    if (r5 == 123) {
      if (r17 >>> 0 <= r3 >>> 0) {
        r18 = r17;
        break;
      }
      ___assert_func(5245788, 76, 5246464, 5245128);
      r18 = r17;
    }
  } while (0);
  if ((r18 | 0) == (_ZopfliMaxCachedSublen(r4, r2, 0) | 0)) {
    return;
  }
  ___assert_func(5245788, 78, 5246464, 5244832);
  return;
}
function _ZopfliBlockSplitLZ77(r1, r2, r3, r4, r5, r6, r7) {
  var r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21, r22, r23, r24;
  r8 = 0;
  r9 = STACKTOP;
  STACKTOP = STACKTOP + 28 | 0;
  r10 = r9, r11 = r10 >> 2;
  r12 = r9 + 4, r13 = r12 >> 2;
  r14 = r9 + 8;
  if (r4 >>> 0 < 10) {
    STACKTOP = r9;
    return;
  }
  r15 = _malloc(r4);
  if ((r15 | 0) == 0) {
    _exit(-1);
  }
  if ((r4 | 0) != 0) {
    _memset(r15, 0, r4);
  }
  HEAP32[r11] = 0;
  HEAP32[r13] = r4;
  r16 = (r5 | 0) == 0;
  r17 = r14 | 0;
  r18 = r14 + 4 | 0;
  r19 = r14 + 8 | 0;
  r20 = r14 + 12 | 0;
  r21 = r14 + 16 | 0;
  r22 = r14;
  r14 = 1;
  while (1) {
    if (!(r16 | r14 >>> 0 < r5 >>> 0)) {
      break;
    }
    HEAP32[r17 >> 2] = r2;
    HEAP32[r18 >> 2] = r3;
    HEAP32[r19 >> 2] = r4;
    HEAP32[r20 >> 2] = HEAP32[r11];
    HEAP32[r21 >> 2] = HEAP32[r13];
    if (HEAP32[r11] >>> 0 >= HEAP32[r13] >>> 0) {
      ___assert_func(5245916, 251, 5246632, 5245900);
    }
    r23 = _FindMinimum(r22, HEAP32[r11] + 1 | 0, HEAP32[r13]);
    if (r23 >>> 0 <= HEAP32[r11] >>> 0) {
      ___assert_func(5245916, 254, 5246632, 5245152);
    }
    if (r23 >>> 0 >= HEAP32[r13] >>> 0) {
      ___assert_func(5245916, 255, 5246632, 5245e3);
    }
    do {
      if (_EstimateCost(r2, r3, HEAP32[r11], r23) + _EstimateCost(r2, r3, r23, HEAP32[r13]) > _EstimateCost(r2, r3, HEAP32[r11], HEAP32[r13])) {
        r8 = 146;
      } else {
        if ((r23 | 0) == (HEAP32[r11] + 1 | 0) | (r23 | 0) == (HEAP32[r13] | 0)) {
          r8 = 146;
          break;
        }
        _AddSorted(r23, r6, r7);
        r24 = r14 + 1 | 0;
        break;
      }
    } while (0);
    if (r8 == 146) {
      r8 = 0;
      HEAP8[r15 + HEAP32[r11] | 0] = 1;
      r24 = r14;
    }
    if ((_FindLargestSplittableBlock(r4, r15, HEAP32[r6 >> 2], HEAP32[r7 >> 2], r10, r12) | 0) == 0) {
      break;
    }
    if ((HEAP32[r13] - HEAP32[r11] | 0) >>> 0 < 10) {
      break;
    } else {
      r14 = r24;
    }
  }
  if ((HEAP32[r1 >> 2] | 0) != 0) {
    _PrintBlockSplitPoints(r2, r3, r4, HEAP32[r6 >> 2], HEAP32[r7 >> 2]);
  }
  _free(r15);
  STACKTOP = r9;
  return;
}
function _GetFixedTree(r1, r2) {
  var r3, r4, r5;
  r3 = r1 >> 2;
  r1 = 0;
  while (1) {
    HEAP32[(r1 << 2 >> 2) + r3] = 8;
    r4 = r1 + 1 | 0;
    if ((r4 | 0) == 144) {
      r5 = 144;
      break;
    } else {
      r1 = r4;
    }
  }
  while (1) {
    HEAP32[(r5 << 2 >> 2) + r3] = 9;
    r1 = r5 + 1 | 0;
    if ((r1 | 0) == 256) {
      break;
    } else {
      r5 = r1;
    }
  }
  HEAP32[r3 + 256] = 7;
  HEAP32[r3 + 257] = 7;
  HEAP32[r3 + 258] = 7;
  HEAP32[r3 + 259] = 7;
  HEAP32[r3 + 260] = 7;
  HEAP32[r3 + 261] = 7;
  HEAP32[r3 + 262] = 7;
  HEAP32[r3 + 263] = 7;
  HEAP32[r3 + 264] = 7;
  HEAP32[r3 + 265] = 7;
  HEAP32[r3 + 266] = 7;
  HEAP32[r3 + 267] = 7;
  HEAP32[r3 + 268] = 7;
  HEAP32[r3 + 269] = 7;
  HEAP32[r3 + 270] = 7;
  HEAP32[r3 + 271] = 7;
  HEAP32[r3 + 272] = 7;
  HEAP32[r3 + 273] = 7;
  HEAP32[r3 + 274] = 7;
  HEAP32[r3 + 275] = 7;
  HEAP32[r3 + 276] = 7;
  HEAP32[r3 + 277] = 7;
  HEAP32[r3 + 278] = 7;
  HEAP32[r3 + 279] = 7;
  HEAP32[r3 + 280] = 8;
  HEAP32[r3 + 281] = 8;
  HEAP32[r3 + 282] = 8;
  HEAP32[r3 + 283] = 8;
  HEAP32[r3 + 284] = 8;
  HEAP32[r3 + 285] = 8;
  HEAP32[r3 + 286] = 8;
  HEAP32[r3 + 287] = 8;
  r3 = 0;
  while (1) {
    HEAP32[r2 + (r3 << 2) >> 2] = 5;
    r5 = r3 + 1 | 0;
    if ((r5 | 0) == 32) {
      break;
    } else {
      r3 = r5;
    }
  }
  return;
}
function _PatchDistanceCodesForBuggyDecoders(r1) {
  var r2, r3, r4, r5;
  r2 = r1 >> 2;
  r1 = 0;
  r3 = 0;
  r4 = 0;
  while (1) {
    if ((r3 | 0) >= 30) {
      break;
    }
    r5 = ((HEAP32[(r3 << 2 >> 2) + r2] | 0) != 0 & 1) + r4 | 0;
    if ((r5 | 0) > 1) {
      r1 = 172;
      break;
    } else {
      r3 = r3 + 1 | 0;
      r4 = r5;
    }
  }
  if (r1 == 172) {
    return;
  }
  if ((r4 | 0) == 1) {
    HEAP32[(((HEAP32[r2] | 0) != 0 & 1) << 2 >> 2) + r2] = 1;
    return;
  } else if ((r4 | 0) == 0) {
    HEAP32[r2 + 1] = 1;
    HEAP32[r2] = 1;
    return;
  } else {
    return;
  }
}
function _ZopfliCacheToSublen(r1, r2, r3, r4) {
  var r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16;
  r5 = 0;
  r6 = _ZopfliMaxCachedSublen(r1, r2, 0);
  if (r3 >>> 0 < 3) {
    return;
  }
  r3 = r2 * 24 & -1;
  r2 = HEAP32[r1 + 8 >> 2];
  r1 = r3 | 1;
  r7 = r3 | 2;
  r8 = 0;
  r9 = 0;
  while (1) {
    r10 = r9 * 3 & -1;
    r11 = HEAP8[r2 + r10 + r3 | 0];
    r12 = r11 & 255;
    r13 = r12 + 3 | 0;
    r14 = HEAPU8[r2 + r7 + r10 | 0] << 8 | HEAPU8[r2 + r1 + r10 | 0];
    L239 : do {
      if (r8 >>> 0 <= r13 >>> 0) {
        r10 = (r11 & 255) + 4 | 0;
        r15 = r8;
        while (1) {
          HEAP16[r4 + (r15 << 1) >> 1] = r14;
          r16 = r15 + 1 | 0;
          if ((r16 | 0) == (r10 | 0)) {
            break L239;
          } else {
            r15 = r16;
          }
        }
      }
    } while (0);
    if ((r13 | 0) == (r6 | 0)) {
      r5 = 181;
      break;
    }
    r14 = r9 + 1 | 0;
    if (r14 >>> 0 < 8) {
      r8 = r12 + 4 | 0;
      r9 = r14;
    } else {
      r5 = 182;
      break;
    }
  }
  if (r5 == 182) {
    return;
  } else if (r5 == 181) {
    return;
  }
}
function _ZopfliCalculateBlockSize(r1, r2, r3, r4, r5) {
  var r6, r7, r8, r9, r10, r11;
  r6 = STACKTOP;
  STACKTOP = STACKTOP + 2560 | 0;
  r7 = r6 + 1280;
  r8 = r6 + 2432;
  if ((r5 - 1 | 0) >>> 0 >= 2) {
    ___assert_func(5245444, 324, 5246576, 5245696);
  }
  if ((r5 | 0) == 1) {
    _GetFixedTree(r7 | 0, r8 | 0);
    r9 = 3;
  } else {
    r5 = r6 | 0;
    r10 = r6 + 1152 | 0;
    _ZopfliLZ77Counts(r1, r2, r3, r4, r5, r10);
    r11 = r7 | 0;
    _ZopfliCalculateBitLengths(r5, 288, 15, r11);
    r5 = r8 | 0;
    _ZopfliCalculateBitLengths(r10, 32, 15, r5);
    _PatchDistanceCodesForBuggyDecoders(r5);
    r9 = (_CalculateTreeSize(r11, r5) >>> 0) + 3;
  }
  r5 = r9 + (_CalculateBlockSymbolSize(r7 | 0, r8 | 0, r1, r2, r3, r4) >>> 0);
  STACKTOP = r6;
  return r5;
}
function _CalculateTreeSize(r1, r2) {
  var r3, r4, r5, r6;
  r3 = STACKTOP;
  STACKTOP = STACKTOP + 12 | 0;
  r4 = r3;
  r5 = r3 + 4;
  r6 = r3 + 8;
  HEAP32[r4 >> 2] = 0;
  HEAP32[r5 >> 2] = 0;
  HEAP8[r6] = 0;
  _AddDynamicTree(r1, r2, r6, r4, r5);
  _free(HEAP32[r4 >> 2]);
  STACKTOP = r3;
  return HEAP8[r6] & 7 | HEAP32[r5 >> 2] << 3;
}
function _CalculateBlockSymbolSize(r1, r2, r3, r4, r5, r6) {
  var r7, r8, r9, r10, r11, r12, r13, r14, r15;
  if (r5 >>> 0 < r6 >>> 0) {
    r7 = 0;
    r8 = r5;
  } else {
    r9 = 0;
    r10 = r1 + 1024 | 0;
    r11 = HEAP32[r10 >> 2];
    r12 = r11 + r9 | 0;
    return r12;
  }
  while (1) {
    r5 = HEAP16[r4 + (r8 << 1) >> 1];
    r13 = HEAPU16[r3 + (r8 << 1) >> 1];
    if (r5 << 16 >> 16 == 0) {
      r14 = HEAP32[r1 + (r13 << 2) >> 2] + r7 | 0;
    } else {
      r15 = r5 & 65535;
      r14 = (((HEAP32[r1 + (_ZopfliGetLengthSymbol(r13) << 2) >> 2] + r7 | 0) + HEAP32[r2 + (_ZopfliGetDistSymbol(r15) << 2) >> 2] | 0) + _ZopfliGetLengthExtraBits(r13) | 0) + _ZopfliGetDistExtraBits(r15) | 0;
    }
    r15 = r8 + 1 | 0;
    if ((r15 | 0) == (r6 | 0)) {
      r9 = r14;
      break;
    } else {
      r7 = r14;
      r8 = r15;
    }
  }
  r10 = r1 + 1024 | 0;
  r11 = HEAP32[r10 >> 2];
  r12 = r11 + r9 | 0;
  return r12;
}
function _ZopfliDeflatePart(r1, r2, r3, r4, r5, r6, r7, r8, r9) {
  if ((HEAP32[r1 + 8 >> 2] | 0) == 0) {
    _DeflateBlock(r1, r2, r3, r4, r5, r6, r7, r8, r9);
    return;
  }
  if ((HEAP32[r1 + 12 >> 2] | 0) == 0) {
    _DeflateSplittingFirst(r1, r2, r3, r4, r5, r6, r7, r8, r9);
    return;
  } else {
    _DeflateSplittingLast(r1, r2, r3, r4, r5, r6, r7, r8, r9);
    return;
  }
}
function _DeflateSplittingLast(r1, r2, r3, r4, r5, r6, r7, r8, r9) {
  var r10, r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26;
  r10 = 0;
  r11 = STACKTOP;
  STACKTOP = STACKTOP + 36 | 0;
  r12 = r11, r13 = r12 >> 2;
  r14 = r11 + 16, r15 = r14 >> 2;
  r16 = r11 + 28;
  r17 = r11 + 32, r18 = r17 >> 2;
  HEAP32[r16 >> 2] = 0;
  HEAP32[r18] = 0;
  do {
    if ((r2 | 0) == 0) {
      _DeflateSplittingFirst(r1, r2, r3, r4, r5, r6, r7, r8, r9);
      r19 = 0;
      r20 = 0;
      r10 = 211;
      break;
    } else {
      r21 = (r2 | 0) == 1;
      r22 = (r2 | 0) == 2;
      if ((r2 - 1 | 0) >>> 0 < 2) {
        r23 = r21;
        r24 = r22;
        break;
      } else {
        r19 = r21;
        r20 = r22;
        r10 = 211;
        break;
      }
    }
  } while (0);
  if (r10 == 211) {
    ___assert_func(5245444, 612, 5246816, 5245696);
    r23 = r19;
    r24 = r20;
  }
  _ZopfliInitLZ77Store(r14);
  HEAP32[r13] = r1;
  HEAP32[r13 + 2] = r5;
  HEAP32[r13 + 3] = r6;
  r13 = _malloc(12);
  r20 = (r12 + 4 | 0) >> 2;
  HEAP32[r20] = r13;
  _ZopfliInitCache(r6 - r5 | 0, r13);
  if (r24) {
    _ZopfliLZ77Optimal(r12, r4, r5, r6, r14);
  } else {
    if (!r23) {
      ___assert_func(5245444, 627, 5246816, 5245324);
    }
    _ZopfliLZ77OptimalFixed(r12, r4, r5, r6, r14);
  }
  if (!r23) {
    _ZopfliBlockSplitLZ77(r1, HEAP32[r15], HEAP32[r15 + 1], HEAP32[r15 + 2], HEAP32[r1 + 16 >> 2], r16, r17);
  }
  r17 = HEAP32[r18];
  r23 = HEAP32[r15 + 2];
  r6 = (r3 | 0) != 0;
  r3 = HEAP32[r15];
  r5 = HEAP32[r15 + 1];
  r15 = HEAP32[r18];
  r18 = HEAP32[r16 >> 2];
  r16 = 0;
  while (1) {
    if ((r16 | 0) == 0) {
      r25 = 0;
    } else {
      r25 = HEAP32[r18 + (r16 - 1 << 2) >> 2];
    }
    if ((r16 | 0) == (r17 | 0)) {
      r26 = r23;
    } else {
      r26 = HEAP32[r18 + (r16 << 2) >> 2];
    }
    _AddLZ77Block(r1, r2, (r16 | 0) == (r17 | 0) & r6 & 1, r3, r5, r25, r26, 0, r7, r8, r9);
    r4 = r16 + 1 | 0;
    if (r4 >>> 0 > r15 >>> 0) {
      break;
    } else {
      r16 = r4;
    }
  }
  _ZopfliCleanCache(HEAP32[r20]);
  _free(HEAP32[r20]);
  _ZopfliCleanLZ77Store(r14);
  STACKTOP = r11;
  return;
}
function _DeflateSplittingFirst(r1, r2, r3, r4, r5, r6, r7, r8, r9) {
  var r10, r11, r12, r13, r14, r15, r16, r17;
  r10 = STACKTOP;
  STACKTOP = STACKTOP + 8 | 0;
  r11 = r10, r12 = r11 >> 2;
  r13 = r10 + 4;
  HEAP32[r12] = 0;
  HEAP32[r13 >> 2] = 0;
  if ((r2 | 0) == 0) {
    _ZopfliBlockSplitSimple(0, r5, r6, 65535, r11, r13);
  } else if ((r2 | 0) != 1) {
    _ZopfliBlockSplit(r1, r4, r5, r6, HEAP32[r1 + 16 >> 2], r11, r13);
  }
  r11 = HEAP32[r13 >> 2];
  r13 = (r3 | 0) != 0;
  r3 = HEAP32[r12];
  r14 = 0;
  while (1) {
    if ((r14 | 0) == 0) {
      r15 = r5;
    } else {
      r15 = HEAP32[r3 + (r14 - 1 << 2) >> 2];
    }
    if ((r14 | 0) == (r11 | 0)) {
      r16 = r6;
    } else {
      r16 = HEAP32[r3 + (r14 << 2) >> 2];
    }
    _DeflateBlock(r1, r2, (r14 | 0) == (r11 | 0) & r13 & 1, r4, r15, r16, r7, r8, r9);
    r17 = r14 + 1 | 0;
    if (r17 >>> 0 > r11 >>> 0) {
      break;
    } else {
      r14 = r17;
    }
  }
  _free(HEAP32[r12]);
  STACKTOP = r10;
  return;
}
function _DeflateBlock(r1, r2, r3, r4, r5, r6, r7, r8, r9) {
  if ((r2 | 0) == 1) {
    _DeflateFixedBlock(r1, r3, r4, r5, r6, r7, r8, r9);
    return;
  } else if ((r2 | 0) == 0) {
    _DeflateNonCompressedBlock(r3, r4, r5, r6, r7, r8, r9);
    return;
  } else if ((r2 | 0) != 2) {
    ___assert_func(5245444, 549, 5246868, 5245116);
  }
  _DeflateDynamicBlock(r1, r3, r4, r5, r6, r7, r8, r9);
  return;
}
function _ZopfliDeflate(r1, r2, r3, r4, r5, r6, r7, r8) {
  var r9, r10, r11;
  if ((r5 | 0) == 0) {
    return;
  }
  r9 = (r3 | 0) != 0;
  r3 = 0;
  while (1) {
    r10 = (r3 + 2e7 | 0) >>> 0 >= r5 >>> 0;
    r11 = (r10 ? r5 - r3 | 0 : 2e7) + r3 | 0;
    _ZopfliDeflatePart(r1, r2, r10 & r9 & 1, r4, r3, r11, r6, r7, r8);
    if (r11 >>> 0 < r5 >>> 0) {
      r3 = r11;
    } else {
      break;
    }
  }
  return;
}
function _DeflateNonCompressedBlock(r1, r2, r3, r4, r5, r6, r7) {
  var r8, r9, r10, r11, r12, r13, r14, r15, r16, r17;
  r8 = r7 >> 2;
  r9 = r6 >> 2;
  r10 = r4 - r3 | 0;
  if (r10 >>> 0 >= 65536) {
    ___assert_func(5245444, 518, 5246840, 5245424);
  }
  _AddBit(r1, r5, r6, r7);
  _AddBit(0, r5, r6, r7);
  _AddBit(0, r5, r6, r7);
  HEAP8[r5] = 0;
  r5 = HEAP32[r8];
  if ((r5 - 1 & r5 | 0) == 0) {
    if ((r5 | 0) == 0) {
      r11 = _malloc(1);
    } else {
      r11 = _realloc(HEAP32[r9], r5 << 1);
    }
    HEAP32[r9] = r11;
  }
  HEAP8[HEAP32[r9] + HEAP32[r8] | 0] = r10 & 255;
  r11 = HEAP32[r8];
  r5 = r11 + 1 | 0;
  HEAP32[r8] = r5;
  if ((r5 & r11 | 0) == 0) {
    if ((r5 | 0) == 0) {
      r12 = _malloc(1);
    } else {
      r12 = _realloc(HEAP32[r9], r5 << 1);
    }
    HEAP32[r9] = r12;
  }
  HEAP8[HEAP32[r9] + HEAP32[r8] | 0] = r10 >>> 8 & 255;
  r12 = HEAP32[r8];
  r5 = r12 + 1 | 0;
  HEAP32[r8] = r5;
  if ((r5 & r12 | 0) == 0) {
    if ((r5 | 0) == 0) {
      r13 = _malloc(1);
    } else {
      r13 = _realloc(HEAP32[r9], r5 << 1);
    }
    HEAP32[r9] = r13;
  }
  r13 = r10 & 65535 ^ 65535;
  HEAP8[HEAP32[r9] + HEAP32[r8] | 0] = r13 & 255;
  r10 = HEAP32[r8];
  r5 = r10 + 1 | 0;
  HEAP32[r8] = r5;
  if ((r5 & r10 | 0) == 0) {
    if ((r5 | 0) == 0) {
      r14 = _malloc(1);
    } else {
      r14 = _realloc(HEAP32[r9], r5 << 1);
    }
    HEAP32[r9] = r14;
  }
  HEAP8[HEAP32[r9] + HEAP32[r8] | 0] = r13 >>> 8 & 255;
  r13 = HEAP32[r8] + 1 | 0;
  HEAP32[r8] = r13;
  if (r3 >>> 0 < r4 >>> 0) {
    r15 = r3;
    r16 = r13;
  } else {
    return;
  }
  while (1) {
    if ((r16 - 1 & r16 | 0) == 0) {
      if ((r16 | 0) == 0) {
        r17 = _malloc(1);
      } else {
        r17 = _realloc(HEAP32[r9], r16 << 1);
      }
      HEAP32[r9] = r17;
    }
    HEAP8[HEAP32[r9] + HEAP32[r8] | 0] = HEAP8[r2 + r15 | 0];
    r13 = HEAP32[r8] + 1 | 0;
    HEAP32[r8] = r13;
    r3 = r15 + 1 | 0;
    if ((r3 | 0) == (r4 | 0)) {
      break;
    } else {
      r15 = r3;
      r16 = r13;
    }
  }
  return;
}
function _DeflateFixedBlock(r1, r2, r3, r4, r5, r6, r7, r8) {
  var r9, r10, r11, r12, r13, r14, r15;
  r9 = STACKTOP;
  STACKTOP = STACKTOP + 28 | 0;
  r10 = r9;
  r11 = r9 + 16, r12 = r11 >> 2;
  r13 = r5 - r4 | 0;
  _ZopfliInitLZ77Store(r11);
  r14 = r10 | 0;
  HEAP32[r14 >> 2] = r1;
  HEAP32[r10 + 8 >> 2] = r4;
  HEAP32[r10 + 12 >> 2] = r5;
  r1 = _malloc(12);
  r15 = (r10 + 4 | 0) >> 2;
  HEAP32[r15] = r1;
  _ZopfliInitCache(r13, r1);
  _ZopfliLZ77OptimalFixed(r10, r3, r4, r5, r11);
  _AddLZ77Block(HEAP32[r14 >> 2], 1, r2, HEAP32[r12], HEAP32[r12 + 1], 0, HEAP32[r12 + 2], r13, r6, r7, r8);
  _ZopfliCleanCache(HEAP32[r15]);
  _free(HEAP32[r15]);
  _ZopfliCleanLZ77Store(r11);
  STACKTOP = r9;
  return;
}
function _DeflateDynamicBlock(r1, r2, r3, r4, r5, r6, r7, r8) {
  var r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19, r20;
  r9 = STACKTOP;
  STACKTOP = STACKTOP + 40 | 0;
  r10 = r9;
  r11 = r9 + 16, r12 = r11 >> 2;
  r13 = r9 + 28, r14 = r13 >> 2;
  r15 = r5 - r4 | 0;
  _ZopfliInitLZ77Store(r11);
  r16 = r10 | 0;
  HEAP32[r16 >> 2] = r1;
  HEAP32[r10 + 8 >> 2] = r4;
  HEAP32[r10 + 12 >> 2] = r5;
  r1 = _malloc(12);
  r17 = (r10 + 4 | 0) >> 2;
  HEAP32[r17] = r1;
  _ZopfliInitCache(r15, r1);
  _ZopfliLZ77Optimal(r10, r3, r4, r5, r11);
  r1 = (r11 + 8 | 0) >> 2;
  do {
    if (HEAP32[r1] >>> 0 < 1e3) {
      _ZopfliInitLZ77Store(r13);
      _ZopfliLZ77OptimalFixed(r10, r3, r4, r5, r13);
      r18 = _ZopfliCalculateBlockSize(HEAP32[r12], HEAP32[r12 + 1], 0, HEAP32[r1], 2);
      if (_ZopfliCalculateBlockSize(HEAP32[r14], HEAP32[r14 + 1], 0, HEAP32[r14 + 2], 1) < r18) {
        _ZopfliCleanLZ77Store(r11);
        r18 = r11 >> 2;
        r19 = r13 >> 2;
        HEAP32[r18] = HEAP32[r19];
        HEAP32[r18 + 1] = HEAP32[r19 + 1];
        HEAP32[r18 + 2] = HEAP32[r19 + 2];
        r20 = 1;
        break;
      } else {
        _ZopfliCleanLZ77Store(r13);
        r20 = 2;
        break;
      }
    } else {
      r20 = 2;
    }
  } while (0);
  _AddLZ77Block(HEAP32[r16 >> 2], r20, r2, HEAP32[r12], HEAP32[r12 + 1], 0, HEAP32[r1], r15, r6, r7, r8);
  _ZopfliCleanCache(HEAP32[r17]);
  _free(HEAP32[r17]);
  _ZopfliCleanLZ77Store(r11);
  STACKTOP = r9;
  return;
}
function _AddLZ77Block(r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11) {
  var r12, r13, r14, r15, r16, r17, r18, r19, r20, r21, r22, r23, r24;
  r12 = 0;
  r13 = STACKTOP;
  STACKTOP = STACKTOP + 3840 | 0;
  r14 = r13;
  r15 = r13 + 1152;
  r16 = r13 + 1280;
  r17 = r13 + 2432;
  r18 = r13 + 2560;
  r19 = r13 + 3712;
  _AddBit(r3, r9, r10, r11);
  _AddBit(r2 & 1, r9, r10, r11);
  _AddBit(r2 >>> 1 & 1, r9, r10, r11);
  do {
    if ((r2 | 0) == 1) {
      _GetFixedTree(r16 | 0, r17 | 0);
      break;
    } else if ((r2 | 0) == 2) {
      r12 = 292;
    } else {
      ___assert_func(5245444, 386, 5246896, 5245116);
      r12 = 292;
      break;
    }
  } while (0);
  L389 : do {
    if (r12 == 292) {
      r2 = r14 | 0;
      r3 = r15 | 0;
      _ZopfliLZ77Counts(r4, r5, r6, r7, r2, r3);
      r20 = r16 | 0;
      _ZopfliCalculateBitLengths(r2, 288, 15, r20);
      r2 = r17 | 0;
      _ZopfliCalculateBitLengths(r3, 32, 15, r2);
      _PatchDistanceCodesForBuggyDecoders(r2);
      r3 = HEAP32[r11 >> 2];
      _AddDynamicTree(r20, r2, r9, r10, r11);
      do {
        if ((HEAP32[r1 >> 2] | 0) == 0) {
          r21 = 0;
        } else {
          _fprintf(HEAP32[_stderr >> 2], 5244816, (tempInt = STACKTOP, STACKTOP = STACKTOP + 4 | 0, HEAP32[tempInt >> 2] = HEAP32[r11 >> 2] - r3 | 0, tempInt));
          r21 = 0;
          break;
        }
      } while (0);
      while (1) {
        do {
          if ((HEAP32[r14 + (r21 << 2) >> 2] | 0) != 0) {
            if ((HEAP32[r16 + (r21 << 2) >> 2] | 0) != 0) {
              break;
            }
            ___assert_func(5245444, 399, 5246896, 5244644);
          }
        } while (0);
        r3 = r21 + 1 | 0;
        if ((r3 | 0) == 288) {
          r22 = 0;
          break;
        } else {
          r21 = r3;
        }
      }
      while (1) {
        do {
          if ((HEAP32[r15 + (r22 << 2) >> 2] | 0) != 0) {
            if ((HEAP32[r17 + (r22 << 2) >> 2] | 0) != 0) {
              break;
            }
            ___assert_func(5245444, 400, 5246896, 5244528);
          }
        } while (0);
        r3 = r22 + 1 | 0;
        if ((r3 | 0) == 32) {
          break L389;
        } else {
          r22 = r3;
        }
      }
    }
  } while (0);
  r22 = r16 | 0;
  r15 = r18 | 0;
  _ZopfliLengthsToSymbols(r22, 288, 15, r15);
  r21 = r17 | 0;
  r17 = r19 | 0;
  _ZopfliLengthsToSymbols(r21, 32, 15, r17);
  r19 = HEAP32[r11 >> 2];
  _AddLZ77Data(r4, r5, r6, r7, r8, r15, r22, r17, r21, r9, r10, r11);
  _AddHuffmanBits(HEAP32[r18 + 1024 >> 2], HEAP32[r16 + 1024 >> 2], r9, r10, r11);
  L406 : do {
    if (r6 >>> 0 < r7 >>> 0) {
      r10 = 0;
      r9 = r6;
      while (1) {
        if (HEAP16[r5 + (r9 << 1) >> 1] << 16 >> 16 == 0) {
          r23 = 1;
        } else {
          r23 = HEAPU16[r4 + (r9 << 1) >> 1];
        }
        r16 = r23 + r10 | 0;
        r18 = r9 + 1 | 0;
        if ((r18 | 0) == (r7 | 0)) {
          r24 = r16;
          break L406;
        } else {
          r10 = r16;
          r9 = r18;
        }
      }
    } else {
      r24 = 0;
    }
  } while (0);
  r7 = HEAP32[r11 >> 2] - r19 | 0;
  if ((HEAP32[r1 >> 2] | 0) == 0) {
    STACKTOP = r13;
    return;
  }
  _fprintf(HEAP32[_stderr >> 2], 5244348, (tempInt = STACKTOP, STACKTOP = STACKTOP + 12 | 0, HEAP32[tempInt >> 2] = r7, HEAP32[tempInt + 4 >> 2] = r7 >>> 10, HEAP32[tempInt + 8 >> 2] = r24, tempInt));
  STACKTOP = r13;
  return;
}
function _AddBit(r1, r2, r3, r4) {
  var r5, r6;
  r5 = r4 >> 2;
  if ((HEAP8[r2] & 7) << 24 >> 24 == 0) {
    r4 = HEAP32[r5];
    if ((r4 - 1 & r4 | 0) == 0) {
      if ((r4 | 0) == 0) {
        r6 = _malloc(1);
      } else {
        r6 = _realloc(HEAP32[r3 >> 2], r4 << 1);
      }
      HEAP32[r3 >> 2] = r6;
    }
    HEAP8[HEAP32[r3 >> 2] + HEAP32[r5] | 0] = 0;
    HEAP32[r5] = HEAP32[r5] + 1 | 0;
  }
  r6 = HEAP32[r3 >> 2] + (HEAP32[r5] - 1) | 0;
  HEAP8[r6] = (HEAPU8[r6] | r1 << (HEAP8[r2] & 7)) & 255;
  HEAP8[r2] = HEAP8[r2] + 1 & 255;
  return;
}
function _AddDynamicTree(r1, r2, r3, r4, r5) {
  var r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31, r32, r33, r34, r35, r36, r37, r38, r39, r40, r41, r42, r43, r44, r45, r46, r47, r48, r49, r50, r51, r52, r53, r54, r55, r56, r57, r58, r59, r60, r61, r62, r63, r64, r65, r66, r67, r68, r69, r70, r71, r72, r73, r74, r75, r76, r77, r78, r79, r80, r81, r82, r83, r84, r85, r86, r87, r88, r89, r90, r91, r92, r93, r94, r95, r96, r97, r98, r99, r100;
  r6 = 0;
  r7 = STACKTOP;
  STACKTOP = STACKTOP + 76 | 0;
  r8 = r7;
  r9 = r8;
  r10 = STACKTOP;
  STACKTOP = STACKTOP + 76 | 0;
  r11 = STACKTOP;
  STACKTOP = STACKTOP + 76 | 0;
  r12 = 29;
  r13 = 316;
  while (1) {
    if ((r12 | 0) == 0) {
      r14 = 29;
      r15 = r13;
      break;
    }
    if ((HEAP32[r1 + (r12 + 256 << 2) >> 2] | 0) == 0) {
      r12 = r12 - 1 | 0;
      r13 = r13 - 1 | 0;
    } else {
      r14 = 29;
      r15 = r13;
      break;
    }
  }
  while (1) {
    if ((r14 | 0) == 0) {
      break;
    }
    if ((HEAP32[r2 + (r14 << 2) >> 2] | 0) == 0) {
      r14 = r14 - 1 | 0;
      r15 = r15 - 1 | 0;
    } else {
      break;
    }
  }
  r13 = r12 + 257 | 0;
  r16 = r14 + (r12 + 258) | 0;
  r17 = _malloc(r16 << 2);
  r18 = r17, r19 = r18 >> 2;
  if ((r17 | 0) == 0) {
    _exit(-1);
  }
  L439 : do {
    if ((r16 | 0) == 0) {
      r6 = 429;
    } else {
      r20 = -257 - r12 | 0;
      r21 = 0;
      while (1) {
        if (r21 >>> 0 < r13 >>> 0) {
          r22 = (r21 << 2) + r1 | 0;
        } else {
          r22 = (r20 + r21 << 2) + r2 | 0;
        }
        r23 = HEAP32[r22 >> 2];
        HEAP32[(r21 << 2 >> 2) + r19] = r23;
        if (r23 >>> 0 >= 16) {
          ___assert_func(5245444, 134, 5246912, 5245604);
        }
        r23 = r21 + 1 | 0;
        if ((r23 | 0) == (r15 | 0)) {
          break;
        } else {
          r21 = r23;
        }
      }
      if ((r16 | 0) == 0) {
        r6 = 429;
        break;
      } else {
        r24 = 0;
        r25 = 0;
        r26 = 0;
        r27 = 0;
        r28 = 0;
      }
      while (1) {
        do {
          if (r28 >>> 0 < r16 >>> 0) {
            r21 = HEAP32[(r28 << 2 >> 2) + r19];
            r20 = r28;
            r23 = 0;
            while (1) {
              if ((r21 | 0) != (HEAP32[(r20 << 2 >> 2) + r19] | 0)) {
                r29 = r23;
                break;
              }
              r30 = r23 + 1 | 0;
              r31 = r20 + 1 | 0;
              if (r31 >>> 0 < r16 >>> 0) {
                r20 = r31;
                r23 = r30;
              } else {
                r29 = r30;
                break;
              }
            }
            if (r29 >>> 0 <= 3) {
              if (r29 >>> 0 <= 2) {
                r6 = 415;
                break;
              }
              if ((HEAP32[(r28 << 2 >> 2) + r19] | 0) != 0) {
                r6 = 415;
                break;
              }
            }
            r23 = ((r28 << 2) + r18 | 0) >> 2;
            do {
              if ((HEAP32[r23] | 0) == 0) {
                if (r29 >>> 0 > 10) {
                  r20 = r29 >>> 0 > 138 ? 138 : r29;
                  if ((r26 - 1 & r26 | 0) == 0) {
                    if ((r26 | 0) == 0) {
                      r32 = _malloc(4);
                    } else {
                      r32 = _realloc(r24, r26 << 3);
                    }
                    r33 = r32;
                  } else {
                    r33 = r24;
                  }
                  HEAP32[r33 + (r26 << 2) >> 2] = 18;
                  r21 = r26 + 1 | 0;
                  if ((r27 - 1 & r27 | 0) == 0) {
                    if ((r27 | 0) == 0) {
                      r34 = _malloc(4);
                    } else {
                      r34 = _realloc(r25, r27 << 3);
                    }
                    r35 = r34;
                  } else {
                    r35 = r25;
                  }
                  HEAP32[r35 + (r27 << 2) >> 2] = r20 - 11 | 0;
                  r36 = r20;
                  r37 = r27 + 1 | 0;
                  r38 = r21;
                  r39 = r35;
                  r40 = r33;
                  break;
                } else {
                  if ((r26 - 1 & r26 | 0) == 0) {
                    if ((r26 | 0) == 0) {
                      r41 = _malloc(4);
                    } else {
                      r41 = _realloc(r24, r26 << 3);
                    }
                    r42 = r41;
                  } else {
                    r42 = r24;
                  }
                  HEAP32[r42 + (r26 << 2) >> 2] = 17;
                  r21 = r26 + 1 | 0;
                  if ((r27 - 1 & r27 | 0) == 0) {
                    if ((r27 | 0) == 0) {
                      r43 = _malloc(4);
                    } else {
                      r43 = _realloc(r25, r27 << 3);
                    }
                    r44 = r43;
                  } else {
                    r44 = r25;
                  }
                  HEAP32[r44 + (r27 << 2) >> 2] = r29 - 3 | 0;
                  r36 = r29;
                  r37 = r27 + 1 | 0;
                  r38 = r21;
                  r39 = r44;
                  r40 = r42;
                  break;
                }
              } else {
                r21 = r29 - 1 | 0;
                if ((r26 - 1 & r26 | 0) == 0) {
                  if ((r26 | 0) == 0) {
                    r45 = _malloc(4);
                  } else {
                    r45 = _realloc(r24, r26 << 3);
                  }
                  r46 = r45;
                } else {
                  r46 = r24;
                }
                HEAP32[r46 + (r26 << 2) >> 2] = HEAP32[r23];
                if ((r27 - 1 & r27 | 0) == 0) {
                  if ((r27 | 0) == 0) {
                    r47 = _malloc(4);
                  } else {
                    r47 = _realloc(r25, r27 << 3);
                  }
                  r48 = r47;
                } else {
                  r48 = r25;
                }
                HEAP32[r48 + (r27 << 2) >> 2] = 0;
                r20 = r27 + 1 | 0;
                r30 = r26 + 1 | 0;
                L479 : do {
                  if (r21 >>> 0 > 5) {
                    r31 = r46;
                    r49 = r48;
                    r50 = r26;
                    r51 = r27;
                    r52 = r21;
                    r53 = r20;
                    r54 = r30;
                    while (1) {
                      if ((r54 & r50 | 0) == 0) {
                        if ((r54 | 0) == 0) {
                          r55 = _malloc(4);
                        } else {
                          r55 = _realloc(r31, r54 << 3);
                        }
                        r56 = r55;
                      } else {
                        r56 = r31;
                      }
                      HEAP32[r56 + (r54 << 2) >> 2] = 16;
                      if ((r53 & r51 | 0) == 0) {
                        if ((r53 | 0) == 0) {
                          r57 = _malloc(4);
                        } else {
                          r57 = _realloc(r49, r53 << 3);
                        }
                        r58 = r57;
                      } else {
                        r58 = r49;
                      }
                      HEAP32[r58 + (r53 << 2) >> 2] = 3;
                      r59 = r52 - 6 | 0;
                      r60 = r53 + 1 | 0;
                      r61 = r54 + 1 | 0;
                      if (r59 >>> 0 > 5) {
                        r31 = r56;
                        r49 = r58;
                        r50 = r54;
                        r51 = r53;
                        r52 = r59;
                        r53 = r60;
                        r54 = r61;
                      } else {
                        r62 = r56;
                        r63 = r58;
                        r64 = r54;
                        r65 = r53;
                        r66 = r59;
                        r67 = r60;
                        r68 = r61;
                        break L479;
                      }
                    }
                  } else {
                    r62 = r46;
                    r63 = r48;
                    r64 = r26;
                    r65 = r27;
                    r66 = r21;
                    r67 = r20;
                    r68 = r30;
                  }
                } while (0);
                if (r66 >>> 0 > 2) {
                  if ((r68 & r64 | 0) == 0) {
                    if ((r68 | 0) == 0) {
                      r69 = _malloc(4);
                    } else {
                      r69 = _realloc(r62, r68 << 3);
                    }
                    r70 = r69;
                  } else {
                    r70 = r62;
                  }
                  HEAP32[r70 + (r68 << 2) >> 2] = 16;
                  r30 = r64 + 2 | 0;
                  if ((r67 & r65 | 0) == 0) {
                    if ((r67 | 0) == 0) {
                      r71 = _malloc(4);
                    } else {
                      r71 = _realloc(r63, r67 << 3);
                    }
                    r72 = r71;
                  } else {
                    r72 = r63;
                  }
                  HEAP32[r72 + (r67 << 2) >> 2] = 0;
                  r73 = r66 - 3 | 0;
                  r74 = r65 + 2 | 0;
                  r75 = r30;
                  r76 = r72;
                  r77 = r70;
                } else {
                  r73 = r66;
                  r74 = r67;
                  r75 = r68;
                  r76 = r63;
                  r77 = r62;
                }
                if ((r73 | 0) == 0) {
                  r36 = r29;
                  r37 = r74;
                  r38 = r75;
                  r39 = r76;
                  r40 = r77;
                  break;
                }
                r30 = r73 + r74 | 0;
                r20 = r77;
                r21 = r76;
                r53 = r75;
                r54 = r74;
                r52 = r73;
                while (1) {
                  if ((r53 - 1 & r53 | 0) == 0) {
                    if ((r53 | 0) == 0) {
                      r78 = _malloc(4);
                    } else {
                      r78 = _realloc(r20, r53 << 3);
                    }
                    r79 = r78;
                  } else {
                    r79 = r20;
                  }
                  HEAP32[r79 + (r53 << 2) >> 2] = HEAP32[r23];
                  r51 = r53 + 1 | 0;
                  if ((r54 - 1 & r54 | 0) == 0) {
                    if ((r54 | 0) == 0) {
                      r80 = _malloc(4);
                    } else {
                      r80 = _realloc(r21, r54 << 3);
                    }
                    r81 = r80;
                  } else {
                    r81 = r21;
                  }
                  HEAP32[r81 + (r54 << 2) >> 2] = 0;
                  r50 = r52 - 1 | 0;
                  if ((r50 | 0) == 0) {
                    break;
                  } else {
                    r20 = r79;
                    r21 = r81;
                    r53 = r51;
                    r54 = r54 + 1 | 0;
                    r52 = r50;
                  }
                }
                r36 = r29;
                r37 = r30;
                r38 = r73 + r75 | 0;
                r39 = r81;
                r40 = r79;
              }
            } while (0);
            r82 = r28 - 1 + r36 | 0;
            r83 = r37;
            r84 = r38;
            r85 = r39;
            r86 = r40;
            break;
          } else {
            r6 = 415;
          }
        } while (0);
        if (r6 == 415) {
          r6 = 0;
          if ((r26 - 1 & r26 | 0) == 0) {
            if ((r26 | 0) == 0) {
              r87 = _malloc(4);
            } else {
              r87 = _realloc(r24, r26 << 3);
            }
            r88 = r87;
          } else {
            r88 = r24;
          }
          HEAP32[r88 + (r26 << 2) >> 2] = HEAP32[(r28 << 2 >> 2) + r19];
          r23 = r26 + 1 | 0;
          if ((r27 - 1 & r27 | 0) == 0) {
            if ((r27 | 0) == 0) {
              r89 = _malloc(4);
            } else {
              r89 = _realloc(r25, r27 << 3);
            }
            r90 = r89;
          } else {
            r90 = r25;
          }
          HEAP32[r90 + (r27 << 2) >> 2] = 0;
          r82 = r28;
          r83 = r27 + 1 | 0;
          r84 = r23;
          r85 = r90;
          r86 = r88;
        }
        if (HEAP32[r86 + (r84 - 1 << 2) >> 2] >>> 0 >= 19) {
          ___assert_func(5245444, 178, 5246912, 5245532);
        }
        r23 = r82 + 1 | 0;
        if (r23 >>> 0 < r16 >>> 0) {
          r24 = r86;
          r25 = r85;
          r26 = r84;
          r27 = r83;
          r28 = r23;
        } else {
          break;
        }
      }
      for (r91 = r9 >> 2, r92 = r91 + 19; r91 < r92; r91++) {
        HEAP32[r91] = 0;
      }
      if ((r84 | 0) == 0) {
        r93 = 0;
        r94 = r85, r95 = r94 >> 2;
        r96 = r86;
        break;
      } else {
        r97 = 0;
      }
      while (1) {
        r23 = (HEAP32[r86 + (r97 << 2) >> 2] << 2) + r8 | 0;
        HEAP32[r23 >> 2] = HEAP32[r23 >> 2] + 1 | 0;
        r23 = r97 + 1 | 0;
        if ((r23 | 0) == (r84 | 0)) {
          r93 = r84;
          r94 = r85, r95 = r94 >> 2;
          r96 = r86;
          break L439;
        } else {
          r97 = r23;
        }
      }
    }
  } while (0);
  if (r6 == 429) {
    for (r91 = r9 >> 2, r92 = r91 + 19; r91 < r92; r91++) {
      HEAP32[r91] = 0;
    }
    r93 = 0;
    r94 = 0, r95 = r94 >> 2;
    r96 = 0;
  }
  r91 = r10 | 0;
  _ZopfliCalculateBitLengths(r8 | 0, 19, 7, r91);
  _ZopfliLengthsToSymbols(r91, 19, 7, r11 | 0);
  r91 = 15;
  r92 = 19;
  while (1) {
    if ((r91 | 0) == 0) {
      break;
    }
    if ((HEAP32[r8 + (HEAP32[(r91 + 3 << 2) + 5250280 >> 2] << 2) >> 2] | 0) == 0) {
      r91 = r91 - 1 | 0;
      r92 = r92 - 1 | 0;
    } else {
      break;
    }
  }
  _AddBits(r12, 5, r3, r4, r5);
  _AddBits(r14, 5, r3, r4, r5);
  _AddBits(r91, 4, r3, r4, r5);
  L595 : do {
    if ((r91 | 0) != -4) {
      r14 = 0;
      while (1) {
        _AddBits(HEAP32[r10 + (HEAP32[(r14 << 2) + 5250280 >> 2] << 2) >> 2], 3, r3, r4, r5);
        r12 = r14 + 1 | 0;
        if ((r12 | 0) == (r92 | 0)) {
          break L595;
        } else {
          r14 = r12;
        }
      }
    }
  } while (0);
  if ((r93 | 0) == 0) {
    _free(r17);
    r98 = r96;
    _free(r98);
    r99 = r94;
    _free(r99);
    STACKTOP = r7;
    return;
  } else {
    r100 = 0;
  }
  while (1) {
    r92 = (r100 << 2) + r96 | 0;
    r91 = HEAP32[r92 >> 2];
    _AddHuffmanBits(HEAP32[r11 + (r91 << 2) >> 2], HEAP32[r10 + (r91 << 2) >> 2], r3, r4, r5);
    r91 = HEAP32[r92 >> 2];
    if ((r91 | 0) == 16) {
      _AddBits(HEAP32[(r100 << 2 >> 2) + r95], 2, r3, r4, r5);
    } else if ((r91 | 0) == 17) {
      _AddBits(HEAP32[(r100 << 2 >> 2) + r95], 3, r3, r4, r5);
    } else if ((r91 | 0) == 18) {
      _AddBits(HEAP32[(r100 << 2 >> 2) + r95], 7, r3, r4, r5);
    }
    r91 = r100 + 1 | 0;
    if ((r91 | 0) == (r93 | 0)) {
      break;
    } else {
      r100 = r91;
    }
  }
  _free(r17);
  r98 = r96;
  _free(r98);
  r99 = r94;
  _free(r99);
  STACKTOP = r7;
  return;
}
function _MakeCRCTable() {
  var r1, r2, r3, r4;
  r1 = 0;
  while (1) {
    r2 = r1 >>> 1;
    r3 = (r1 & 1 | 0) == 0 ? r2 : r2 ^ -306674912;
    r2 = r3 >>> 1;
    r4 = (r3 & 1 | 0) == 0 ? r2 : r2 ^ -306674912;
    r2 = r4 >>> 1;
    r3 = (r4 & 1 | 0) == 0 ? r2 : r2 ^ -306674912;
    r2 = r3 >>> 1;
    r4 = (r3 & 1 | 0) == 0 ? r2 : r2 ^ -306674912;
    r2 = r4 >>> 1;
    r3 = (r4 & 1 | 0) == 0 ? r2 : r2 ^ -306674912;
    r2 = r3 >>> 1;
    r4 = (r3 & 1 | 0) == 0 ? r2 : r2 ^ -306674912;
    r2 = r4 >>> 1;
    r3 = (r4 & 1 | 0) == 0 ? r2 : r2 ^ -306674912;
    r2 = r3 >>> 1;
    HEAP32[(r1 << 2) + 5242916 >> 2] = (r3 & 1 | 0) == 0 ? r2 : r2 ^ -306674912;
    r2 = r1 + 1 | 0;
    if ((r2 | 0) == 256) {
      break;
    } else {
      r1 = r2;
    }
  }
  HEAP8[5242912] = 1;
  return;
}
function _AddLZ77Data(r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12) {
  var r13, r14, r15, r16, r17, r18, r19, r20, r21, r22;
  L614 : do {
    if (r3 >>> 0 < r4 >>> 0) {
      r13 = r3;
      r14 = 0;
      while (1) {
        r15 = HEAP16[r2 + (r13 << 1) >> 1];
        r16 = r15 & 65535;
        r17 = HEAP16[r1 + (r13 << 1) >> 1];
        r18 = r17 & 65535;
        if (r15 << 16 >> 16 == 0) {
          if ((r17 & 65535) >= 256) {
            ___assert_func(5245444, 256, 5246884, 5244228);
          }
          r15 = (r18 << 2) + r7 | 0;
          if ((HEAP32[r15 >> 2] | 0) == 0) {
            ___assert_func(5245444, 257, 5246884, 5244152);
          }
          _AddHuffmanBits(HEAP32[r6 + (r18 << 2) >> 2], HEAP32[r15 >> 2], r10, r11, r12);
          r19 = r14 + 1 | 0;
        } else {
          r15 = _ZopfliGetLengthSymbol(r18);
          r20 = _ZopfliGetDistSymbol(r16);
          if ((r17 - 3 & 65535) >= 286) {
            ___assert_func(5245444, 263, 5246884, 5244088);
          }
          r17 = (r15 << 2) + r7 | 0;
          if ((HEAP32[r17 >> 2] | 0) == 0) {
            ___assert_func(5245444, 264, 5246884, 5245876);
          }
          r21 = (r20 << 2) + r9 | 0;
          if ((HEAP32[r21 >> 2] | 0) == 0) {
            ___assert_func(5245444, 265, 5246884, 5245744);
          }
          _AddHuffmanBits(HEAP32[r6 + (r15 << 2) >> 2], HEAP32[r17 >> 2], r10, r11, r12);
          _AddBits(_ZopfliGetLengthExtraBitsValue(r18), _ZopfliGetLengthExtraBits(r18), r10, r11, r12);
          _AddHuffmanBits(HEAP32[r8 + (r20 << 2) >> 2], HEAP32[r21 >> 2], r10, r11, r12);
          _AddBits(_ZopfliGetDistExtraBitsValue(r16), _ZopfliGetDistExtraBits(r16), r10, r11, r12);
          r19 = r18 + r14 | 0;
        }
        r18 = r13 + 1 | 0;
        if ((r18 | 0) == (r4 | 0)) {
          r22 = r19;
          break L614;
        } else {
          r13 = r18;
          r14 = r19;
        }
      }
    } else {
      r22 = 0;
    }
  } while (0);
  if ((r5 | 0) == 0 | (r22 | 0) == (r5 | 0)) {
    return;
  }
  ___assert_func(5245444, 277, 5246884, 5245636);
  return;
}
function _AddHuffmanBits(r1, r2, r3, r4, r5) {
  var r6, r7, r8, r9, r10;
  r6 = r5 >> 2;
  if ((r2 | 0) == 0) {
    return;
  }
  r5 = r2 - 1 | 0;
  r7 = 0;
  while (1) {
    r8 = r1 >>> ((r5 - r7 | 0) >>> 0) & 1;
    if ((HEAP8[r3] & 7) << 24 >> 24 == 0) {
      r9 = HEAP32[r6];
      if ((r9 - 1 & r9 | 0) == 0) {
        if ((r9 | 0) == 0) {
          r10 = _malloc(1);
        } else {
          r10 = _realloc(HEAP32[r4 >> 2], r9 << 1);
        }
        HEAP32[r4 >> 2] = r10;
      }
      HEAP8[HEAP32[r4 >> 2] + HEAP32[r6] | 0] = 0;
      HEAP32[r6] = HEAP32[r6] + 1 | 0;
    }
    r9 = HEAP32[r4 >> 2] + (HEAP32[r6] - 1) | 0;
    HEAP8[r9] = (HEAPU8[r9] | r8 << (HEAP8[r3] & 7)) & 255;
    HEAP8[r3] = HEAP8[r3] + 1 & 255;
    r8 = r7 + 1 | 0;
    if ((r8 | 0) == (r2 | 0)) {
      break;
    } else {
      r7 = r8;
    }
  }
  return;
}
function _AddBits(r1, r2, r3, r4, r5) {
  var r6, r7, r8, r9;
  r6 = r5 >> 2;
  if ((r2 | 0) == 0) {
    return;
  } else {
    r7 = 0;
  }
  while (1) {
    r5 = r1 >>> (r7 >>> 0) & 1;
    if ((HEAP8[r3] & 7) << 24 >> 24 == 0) {
      r8 = HEAP32[r6];
      if ((r8 - 1 & r8 | 0) == 0) {
        if ((r8 | 0) == 0) {
          r9 = _malloc(1);
        } else {
          r9 = _realloc(HEAP32[r4 >> 2], r8 << 1);
        }
        HEAP32[r4 >> 2] = r9;
      }
      HEAP8[HEAP32[r4 >> 2] + HEAP32[r6] | 0] = 0;
      HEAP32[r6] = HEAP32[r6] + 1 | 0;
    }
    r8 = HEAP32[r4 >> 2] + (HEAP32[r6] - 1) | 0;
    HEAP8[r8] = (HEAPU8[r8] | r5 << (HEAP8[r3] & 7)) & 255;
    HEAP8[r3] = HEAP8[r3] + 1 & 255;
    r5 = r7 + 1 | 0;
    if ((r5 | 0) == (r2 | 0)) {
      break;
    } else {
      r7 = r5;
    }
  }
  return;
}
function _ZopfliGzipCompress(r1, r2, r3, r4, r5) {
  var r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29;
  r6 = r5 >> 2;
  r7 = r4 >> 2;
  r8 = STACKTOP;
  STACKTOP = STACKTOP + 4 | 0;
  r9 = r8;
  r10 = _CRC(r2, r3);
  HEAP8[r9] = 0;
  r11 = HEAP32[r6];
  if ((r11 - 1 & r11 | 0) == 0) {
    if ((r11 | 0) == 0) {
      r12 = _malloc(1);
    } else {
      r12 = _realloc(HEAP32[r7], r11 << 1);
    }
    HEAP32[r7] = r12;
  }
  HEAP8[HEAP32[r7] + HEAP32[r6] | 0] = 31;
  r12 = HEAP32[r6];
  r11 = r12 + 1 | 0;
  HEAP32[r6] = r11;
  if ((r11 & r12 | 0) == 0) {
    if ((r11 | 0) == 0) {
      r13 = _malloc(1);
    } else {
      r13 = _realloc(HEAP32[r7], r11 << 1);
    }
    HEAP32[r7] = r13;
  }
  HEAP8[HEAP32[r7] + HEAP32[r6] | 0] = -117;
  r13 = HEAP32[r6];
  r11 = r13 + 1 | 0;
  HEAP32[r6] = r11;
  if ((r11 & r13 | 0) == 0) {
    if ((r11 | 0) == 0) {
      r14 = _malloc(1);
    } else {
      r14 = _realloc(HEAP32[r7], r11 << 1);
    }
    HEAP32[r7] = r14;
  }
  HEAP8[HEAP32[r7] + HEAP32[r6] | 0] = 8;
  r14 = HEAP32[r6];
  r11 = r14 + 1 | 0;
  HEAP32[r6] = r11;
  if ((r11 & r14 | 0) == 0) {
    if ((r11 | 0) == 0) {
      r15 = _malloc(1);
    } else {
      r15 = _realloc(HEAP32[r7], r11 << 1);
    }
    HEAP32[r7] = r15;
  }
  HEAP8[HEAP32[r7] + HEAP32[r6] | 0] = 0;
  r15 = HEAP32[r6];
  r11 = r15 + 1 | 0;
  HEAP32[r6] = r11;
  if ((r11 & r15 | 0) == 0) {
    if ((r11 | 0) == 0) {
      r16 = _malloc(1);
    } else {
      r16 = _realloc(HEAP32[r7], r11 << 1);
    }
    HEAP32[r7] = r16;
  }
  HEAP8[HEAP32[r7] + HEAP32[r6] | 0] = 0;
  r16 = HEAP32[r6];
  r11 = r16 + 1 | 0;
  HEAP32[r6] = r11;
  if ((r11 & r16 | 0) == 0) {
    if ((r11 | 0) == 0) {
      r17 = _malloc(1);
    } else {
      r17 = _realloc(HEAP32[r7], r11 << 1);
    }
    HEAP32[r7] = r17;
  }
  HEAP8[HEAP32[r7] + HEAP32[r6] | 0] = 0;
  r17 = HEAP32[r6];
  r11 = r17 + 1 | 0;
  HEAP32[r6] = r11;
  if ((r11 & r17 | 0) == 0) {
    if ((r11 | 0) == 0) {
      r18 = _malloc(1);
    } else {
      r18 = _realloc(HEAP32[r7], r11 << 1);
    }
    HEAP32[r7] = r18;
  }
  HEAP8[HEAP32[r7] + HEAP32[r6] | 0] = 0;
  r18 = HEAP32[r6];
  r11 = r18 + 1 | 0;
  HEAP32[r6] = r11;
  if ((r11 & r18 | 0) == 0) {
    if ((r11 | 0) == 0) {
      r19 = _malloc(1);
    } else {
      r19 = _realloc(HEAP32[r7], r11 << 1);
    }
    HEAP32[r7] = r19;
  }
  HEAP8[HEAP32[r7] + HEAP32[r6] | 0] = 0;
  r19 = HEAP32[r6];
  r11 = r19 + 1 | 0;
  HEAP32[r6] = r11;
  if ((r11 & r19 | 0) == 0) {
    if ((r11 | 0) == 0) {
      r20 = _malloc(1);
    } else {
      r20 = _realloc(HEAP32[r7], r11 << 1);
    }
    HEAP32[r7] = r20;
  }
  HEAP8[HEAP32[r7] + HEAP32[r6] | 0] = 2;
  r20 = HEAP32[r6];
  r11 = r20 + 1 | 0;
  HEAP32[r6] = r11;
  if ((r11 & r20 | 0) == 0) {
    if ((r11 | 0) == 0) {
      r21 = _malloc(1);
    } else {
      r21 = _realloc(HEAP32[r7], r11 << 1);
    }
    HEAP32[r7] = r21;
  }
  HEAP8[HEAP32[r7] + HEAP32[r6] | 0] = 3;
  HEAP32[r6] = HEAP32[r6] + 1 | 0;
  _ZopfliDeflate(r1, 2, 1, r2, r3, r9, r4, r5);
  r5 = HEAP32[r6];
  if ((r5 - 1 & r5 | 0) == 0) {
    if ((r5 | 0) == 0) {
      r22 = _malloc(1);
    } else {
      r22 = _realloc(HEAP32[r7], r5 << 1);
    }
    HEAP32[r7] = r22;
  }
  HEAP8[HEAP32[r7] + HEAP32[r6] | 0] = r10 & 255;
  r22 = HEAP32[r6];
  r5 = r22 + 1 | 0;
  HEAP32[r6] = r5;
  if ((r5 & r22 | 0) == 0) {
    if ((r5 | 0) == 0) {
      r23 = _malloc(1);
    } else {
      r23 = _realloc(HEAP32[r7], r5 << 1);
    }
    HEAP32[r7] = r23;
  }
  HEAP8[HEAP32[r7] + HEAP32[r6] | 0] = r10 >>> 8 & 255;
  r23 = HEAP32[r6];
  r5 = r23 + 1 | 0;
  HEAP32[r6] = r5;
  if ((r5 & r23 | 0) == 0) {
    if ((r5 | 0) == 0) {
      r24 = _malloc(1);
    } else {
      r24 = _realloc(HEAP32[r7], r5 << 1);
    }
    HEAP32[r7] = r24;
  }
  HEAP8[HEAP32[r7] + HEAP32[r6] | 0] = r10 >>> 16 & 255;
  r24 = HEAP32[r6];
  r5 = r24 + 1 | 0;
  HEAP32[r6] = r5;
  if ((r5 & r24 | 0) == 0) {
    if ((r5 | 0) == 0) {
      r25 = _malloc(1);
    } else {
      r25 = _realloc(HEAP32[r7], r5 << 1);
    }
    HEAP32[r7] = r25;
  }
  HEAP8[HEAP32[r7] + HEAP32[r6] | 0] = r10 >>> 24 & 255;
  r10 = HEAP32[r6];
  r25 = r10 + 1 | 0;
  HEAP32[r6] = r25;
  if ((r25 & r10 | 0) == 0) {
    if ((r25 | 0) == 0) {
      r26 = _malloc(1);
    } else {
      r26 = _realloc(HEAP32[r7], r25 << 1);
    }
    HEAP32[r7] = r26;
  }
  HEAP8[HEAP32[r7] + HEAP32[r6] | 0] = r3 & 255;
  r26 = HEAP32[r6];
  r25 = r26 + 1 | 0;
  HEAP32[r6] = r25;
  if ((r25 & r26 | 0) == 0) {
    if ((r25 | 0) == 0) {
      r27 = _malloc(1);
    } else {
      r27 = _realloc(HEAP32[r7], r25 << 1);
    }
    HEAP32[r7] = r27;
  }
  HEAP8[HEAP32[r7] + HEAP32[r6] | 0] = r3 >>> 8 & 255;
  r27 = HEAP32[r6];
  r25 = r27 + 1 | 0;
  HEAP32[r6] = r25;
  if ((r25 & r27 | 0) == 0) {
    if ((r25 | 0) == 0) {
      r28 = _malloc(1);
    } else {
      r28 = _realloc(HEAP32[r7], r25 << 1);
    }
    HEAP32[r7] = r28;
  }
  HEAP8[HEAP32[r7] + HEAP32[r6] | 0] = r3 >>> 16 & 255;
  r28 = HEAP32[r6];
  r25 = r28 + 1 | 0;
  HEAP32[r6] = r25;
  if ((r25 & r28 | 0) == 0) {
    if ((r25 | 0) == 0) {
      r29 = _malloc(1);
    } else {
      r29 = _realloc(HEAP32[r7], r25 << 1);
    }
    HEAP32[r7] = r29;
  }
  HEAP8[HEAP32[r7] + HEAP32[r6] | 0] = r3 >>> 24 & 255;
  r7 = HEAP32[r6] + 1 | 0;
  HEAP32[r6] = r7;
  if ((HEAP32[r1 >> 2] | 0) == 0) {
    STACKTOP = r8;
    return;
  }
  _fprintf(HEAP32[_stderr >> 2], 5244936, (tempInt = STACKTOP, STACKTOP = STACKTOP + 16 | 0, HEAP32[tempInt >> 2] = r3, HEAP32[tempInt + 4 >> 2] = r7, HEAPF64[tempDoublePtr >> 3] = ((r3 - r7 | 0) >>> 0) * 100 / (r3 >>> 0), HEAP32[tempInt + 8 >> 2] = HEAP32[tempDoublePtr >> 2], HEAP32[tempInt + 12 >> 2] = HEAP32[tempDoublePtr + 4 >> 2], tempInt));
  STACKTOP = r8;
  return;
}
function _CRC(r1, r2) {
  return _UpdateCRC(r1, r2);
}
function _UpdateCRC(r1, r2) {
  var r3, r4, r5, r6, r7;
  if (!HEAP8[5242912]) {
    _MakeCRCTable();
  }
  if ((r2 | 0) == 0) {
    r3 = 0;
    return r3;
  } else {
    r4 = -1;
    r5 = 0;
  }
  while (1) {
    r6 = HEAP32[((HEAPU8[r1 + r5 | 0] ^ r4 & 255) << 2) + 5242916 >> 2] ^ r4 >>> 8;
    r7 = r5 + 1 | 0;
    if ((r7 | 0) == (r2 | 0)) {
      break;
    } else {
      r4 = r6;
      r5 = r7;
    }
  }
  r3 = r6 ^ -1;
  return r3;
}
function _LeafComparator(r1, r2) {
  return HEAP32[r1 >> 2] - HEAP32[r2 >> 2] | 0;
}
function _UpdateHashValue(r1, r2) {
  var r3;
  r3 = r1 + 12 | 0;
  HEAP32[r3 >> 2] = HEAP32[r3 >> 2] << 5 & 32736 ^ r2 & 255;
  return;
}
function _ExtractBitLengths(r1, r2, r3) {
  var r4, r5, r6;
  if ((r1 | 0) == 0) {
    return;
  } else {
    r4 = r1;
  }
  while (1) {
    r1 = r4 + 8 | 0;
    L823 : do {
      if ((HEAP32[r1 >> 2] | 0) > 0) {
        r5 = 0;
        while (1) {
          r6 = (HEAP32[r2 + (r5 << 4) + 8 >> 2] << 2) + r3 | 0;
          HEAP32[r6 >> 2] = HEAP32[r6 >> 2] + 1 | 0;
          r6 = r5 + 1 | 0;
          if ((r6 | 0) < (HEAP32[r1 >> 2] | 0)) {
            r5 = r6;
          } else {
            break L823;
          }
        }
      }
    } while (0);
    r1 = HEAP32[r4 + 4 >> 2];
    if ((r1 | 0) == 0) {
      break;
    } else {
      r4 = r1;
    }
  }
  return;
}
function _GetFreeNode(r1, r2, r3) {
  var r4, r5, r6, r7, r8, r9, r10, r11, r12;
  r4 = (r3 + 4 | 0) >> 2;
  r5 = (r3 + 8 | 0) >> 2;
  r6 = (r3 | 0) >> 2;
  r3 = (r1 | 0) == 0;
  r7 = r2 << 1;
  r8 = r2 << 1;
  while (1) {
    if (HEAP32[r4] >>> 0 >= ((HEAP32[r5] << 4) + HEAP32[r6] | 0) >>> 0) {
      L833 : do {
        if ((HEAP32[r5] | 0) > 0) {
          r2 = 0;
          while (1) {
            HEAP8[(r2 << 4) + HEAP32[r6] + 12 | 0] = 0;
            r9 = r2 + 1 | 0;
            if ((r9 | 0) < (HEAP32[r5] | 0)) {
              r2 = r9;
            } else {
              break L833;
            }
          }
        }
      } while (0);
      L837 : do {
        if (!(r3 | (r7 | 0) < 1)) {
          r2 = 0;
          while (1) {
            r9 = HEAP32[r1 + (((r2 | 0) / 2 & -1) << 3) + ((r2 | 0) % 2 << 2) >> 2];
            L840 : do {
              if ((r9 | 0) != 0) {
                r10 = r9;
                while (1) {
                  HEAP8[r10 + 12 | 0] = 1;
                  r11 = HEAP32[r10 + 4 >> 2];
                  if ((r11 | 0) == 0) {
                    break L840;
                  } else {
                    r10 = r11;
                  }
                }
              }
            } while (0);
            r9 = r2 + 1 | 0;
            if ((r9 | 0) == (r8 | 0)) {
              break L837;
            } else {
              r2 = r9;
            }
          }
        }
      } while (0);
      HEAP32[r4] = HEAP32[r6];
    }
    r12 = HEAP32[r4];
    r2 = HEAP8[r12 + 12 | 0] << 24 >> 24 == 0;
    HEAP32[r4] = r12 + 16 | 0;
    if (r2) {
      break;
    }
  }
  return r12;
}
function _InitNode(r1, r2, r3, r4) {
  HEAP32[r4 >> 2] = r1;
  HEAP32[r4 + 8 >> 2] = r2;
  HEAP32[r4 + 4 >> 2] = r3;
  HEAP8[r4 + 12 | 0] = 1;
  return;
}
function _ZopfliInitLZ77Store(r1) {
  HEAP32[r1 + 8 >> 2] = 0;
  HEAP32[r1 >> 2] = 0;
  HEAP32[r1 + 4 >> 2] = 0;
  return;
}
function _ZopfliInitHash(r1, r2) {
  var r3, r4, r5, r6, r7, r8, r9, r10;
  HEAP32[r2 + 12 >> 2] = 0;
  r3 = r2 | 0;
  HEAP32[r3 >> 2] = _malloc(262144);
  r4 = r1 << 1;
  r5 = r2 + 4 | 0;
  HEAP32[r5 >> 2] = _malloc(r4);
  r6 = r1 << 2;
  r7 = r2 + 8 | 0;
  HEAP32[r7 >> 2] = _malloc(r6);
  r8 = 0;
  while (1) {
    HEAP32[HEAP32[r3 >> 2] + (r8 << 2) >> 2] = -1;
    r9 = r8 + 1 | 0;
    if ((r9 | 0) == 65536) {
      break;
    } else {
      r8 = r9;
    }
  }
  L853 : do {
    if ((r1 | 0) != 0) {
      r8 = 0;
      while (1) {
        HEAP16[HEAP32[r5 >> 2] + (r8 << 1) >> 1] = r8 & 65535;
        HEAP32[HEAP32[r7 >> 2] + (r8 << 2) >> 2] = -1;
        r3 = r8 + 1 | 0;
        if ((r3 | 0) == (r1 | 0)) {
          break L853;
        } else {
          r8 = r3;
        }
      }
    }
  } while (0);
  r7 = r2 + 32 | 0;
  HEAP32[r7 >> 2] = _malloc(r4);
  L857 : do {
    if ((r1 | 0) != 0) {
      r5 = 0;
      while (1) {
        HEAP16[HEAP32[r7 >> 2] + (r5 << 1) >> 1] = 0;
        r8 = r5 + 1 | 0;
        if ((r8 | 0) == (r1 | 0)) {
          break L857;
        } else {
          r5 = r8;
        }
      }
    }
  } while (0);
  HEAP32[r2 + 28 >> 2] = 0;
  r7 = r2 + 16 | 0;
  HEAP32[r7 >> 2] = _malloc(262144);
  r5 = r2 + 20 | 0;
  HEAP32[r5 >> 2] = _malloc(r4);
  r4 = r2 + 24 | 0;
  HEAP32[r4 >> 2] = _malloc(r6);
  r6 = 0;
  while (1) {
    HEAP32[HEAP32[r7 >> 2] + (r6 << 2) >> 2] = -1;
    r2 = r6 + 1 | 0;
    if ((r2 | 0) == 65536) {
      break;
    } else {
      r6 = r2;
    }
  }
  if ((r1 | 0) == 0) {
    return;
  } else {
    r10 = 0;
  }
  while (1) {
    HEAP16[HEAP32[r5 >> 2] + (r10 << 1) >> 1] = r10 & 65535;
    HEAP32[HEAP32[r4 >> 2] + (r10 << 2) >> 2] = -1;
    r6 = r10 + 1 | 0;
    if ((r6 | 0) == (r1 | 0)) {
      break;
    } else {
      r10 = r6;
    }
  }
  return;
}
function _ZopfliCleanHash(r1) {
  var r2;
  r2 = r1 >> 2;
  _free(HEAP32[r2]);
  _free(HEAP32[r2 + 1]);
  _free(HEAP32[r2 + 2]);
  _free(HEAP32[r2 + 4]);
  _free(HEAP32[r2 + 5]);
  _free(HEAP32[r2 + 6]);
  _free(HEAP32[r2 + 8]);
  return;
}
function _ZopfliUpdateHash(r1, r2, r3, r4) {
  var r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16;
  r5 = 0;
  r6 = r2 & 32767;
  if ((r2 + 3 | 0) >>> 0 > r3 >>> 0) {
    r7 = 0;
  } else {
    r7 = HEAP8[r2 + (r1 + 2) | 0];
  }
  _UpdateHashValue(r4, r7);
  r7 = (r4 + 12 | 0) >> 2;
  r8 = r6 & 65535;
  r9 = r4 + 8 | 0;
  HEAP32[HEAP32[r9 >> 2] + (r8 << 2) >> 2] = HEAP32[r7];
  r10 = HEAP32[r7];
  r11 = r4 | 0;
  r12 = HEAP32[HEAP32[r11 >> 2] + (r10 << 2) >> 2];
  do {
    if ((r12 | 0) == -1) {
      r5 = 639;
    } else {
      if ((HEAP32[HEAP32[r9 >> 2] + (r12 << 2) >> 2] | 0) != (r10 | 0)) {
        r5 = 639;
        break;
      }
      HEAP16[HEAP32[r4 + 4 >> 2] + (r8 << 1) >> 1] = r12 & 65535;
      break;
    }
  } while (0);
  if (r5 == 639) {
    HEAP16[HEAP32[r4 + 4 >> 2] + (r8 << 1) >> 1] = r6;
  }
  HEAP32[HEAP32[r11 >> 2] + (HEAP32[r7] << 2) >> 2] = r8;
  r11 = (r4 + 32 | 0) >> 2;
  r5 = HEAP16[HEAP32[r11] + ((r2 + 32767 & 32767) << 1) >> 1];
  if ((r5 & 65535) > 1) {
    r13 = (r5 & 65535) - 1 | 0;
  } else {
    r13 = 0;
  }
  r5 = r2 + 1 | 0;
  r12 = r1 + r2 | 0;
  r2 = r13;
  while (1) {
    r13 = r5 + r2 | 0;
    if (r13 >>> 0 >= r3 >>> 0) {
      break;
    }
    if (HEAP8[r12] << 24 >> 24 == HEAP8[r1 + r13 | 0] << 24 >> 24 & r2 >>> 0 < 65535) {
      r2 = r2 + 1 | 0;
    } else {
      break;
    }
  }
  HEAP16[HEAP32[r11] + (r8 << 1) >> 1] = r2 & 65535;
  r2 = HEAPU16[HEAP32[r11] + (r8 << 1) >> 1] + 253 & 255 ^ HEAP32[r7];
  r7 = (r4 + 28 | 0) >> 2;
  HEAP32[r7] = r2;
  r11 = r4 + 24 | 0;
  HEAP32[HEAP32[r11 >> 2] + (r8 << 2) >> 2] = r2;
  r2 = HEAP32[r7];
  r1 = (r4 + 16 | 0) >> 2;
  r12 = HEAP32[HEAP32[r1] + (r2 << 2) >> 2];
  do {
    if ((r12 | 0) != -1) {
      if ((HEAP32[HEAP32[r11 >> 2] + (r12 << 2) >> 2] | 0) != (r2 | 0)) {
        break;
      }
      HEAP16[HEAP32[r4 + 20 >> 2] + (r8 << 1) >> 1] = r12 & 65535;
      r14 = HEAP32[r7];
      r15 = HEAP32[r1];
      r16 = (r14 << 2) + r15 | 0;
      HEAP32[r16 >> 2] = r8;
      return;
    }
  } while (0);
  HEAP16[HEAP32[r4 + 20 >> 2] + (r8 << 1) >> 1] = r6;
  r14 = HEAP32[r7];
  r15 = HEAP32[r1];
  r16 = (r14 << 2) + r15 | 0;
  HEAP32[r16 >> 2] = r8;
  return;
}
function _ZopfliWarmupHash(r1, r2, r3, r4) {
  _UpdateHashValue(r4, HEAP8[r1 + r2 | 0]);
  _UpdateHashValue(r4, HEAP8[r2 + (r1 + 1) | 0]);
  return;
}
function _ZopfliLengthLimitedCodeLengths(r1, r2, r3, r4) {
  var r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17;
  r5 = STACKTOP;
  STACKTOP = STACKTOP + 12 | 0;
  r6 = r5;
  r7 = _malloc(r2 << 4);
  r8 = r7;
  L895 : do {
    if ((r2 | 0) > 0) {
      _memset(r4, 0, r2 << 2);
      r9 = 0;
      r10 = 0;
      while (1) {
        r11 = HEAP32[r1 + (r10 << 2) >> 2];
        if ((r11 | 0) == 0) {
          r12 = r9;
        } else {
          HEAP32[r8 + (r9 << 4) >> 2] = r11;
          HEAP32[r8 + (r9 << 4) + 8 >> 2] = r10;
          r12 = r9 + 1 | 0;
        }
        r11 = r10 + 1 | 0;
        if ((r11 | 0) == (r2 | 0)) {
          r13 = r12;
          break L895;
        } else {
          r9 = r12;
          r10 = r11;
        }
      }
    } else {
      r13 = 0;
    }
  } while (0);
  if ((1 << r3 | 0) < (r13 | 0)) {
    _free(r7);
    r14 = 1;
    STACKTOP = r5;
    return r14;
  }
  if ((r13 | 0) == 0) {
    _free(r7);
    r14 = 0;
    STACKTOP = r5;
    return r14;
  } else if ((r13 | 0) == 1) {
    HEAP32[r4 + (HEAP32[r7 + 8 >> 2] << 2) >> 2] = 1;
    _free(r7);
    r14 = 0;
    STACKTOP = r5;
    return r14;
  } else {
    _qsort(r7, r13, 16, 14);
    r12 = Math.imul(r3 << 1, r3 + 1 | 0);
    r2 = (r6 + 8 | 0) >> 2;
    HEAP32[r2] = r12;
    r1 = _malloc(r12 << 4);
    r12 = (r6 | 0) >> 2;
    HEAP32[r12] = r1;
    HEAP32[r6 + 4 >> 2] = r1;
    L913 : do {
      if ((HEAP32[r2] | 0) > 0) {
        r1 = 0;
        while (1) {
          HEAP8[(r1 << 4) + HEAP32[r12] + 12 | 0] = 0;
          r10 = r1 + 1 | 0;
          if ((r10 | 0) < (HEAP32[r2] | 0)) {
            r1 = r10;
          } else {
            break L913;
          }
        }
      }
    } while (0);
    r2 = _malloc(r3 << 3);
    r1 = r2;
    _InitLists(r6, r8, r3, r1);
    r10 = r13 << 1;
    L917 : do {
      if ((r10 - 4 | 0) > 0) {
        r9 = r10 - 5 | 0;
        r11 = r3 - 1 | 0;
        r15 = (r13 << 1) - 4 | 0;
        r16 = 0;
        while (1) {
          _BoundaryPM(r1, r3, r8, r13, r6, r11, (r16 | 0) == (r9 | 0) & 1);
          r17 = r16 + 1 | 0;
          if ((r17 | 0) == (r15 | 0)) {
            break L917;
          } else {
            r16 = r17;
          }
        }
      }
    } while (0);
    _ExtractBitLengths(HEAP32[r1 + (r3 - 1 << 3) + 4 >> 2], r8, r4);
    _free(r2);
    _free(r7);
    _free(HEAP32[r12]);
    r14 = 0;
    STACKTOP = r5;
    return r14;
  }
}
function _InitLists(r1, r2, r3, r4) {
  var r5, r6, r7;
  r5 = _GetFreeNode(0, r3, r1);
  r6 = _GetFreeNode(0, r3, r1);
  _InitNode(HEAP32[r2 >> 2], 1, 0, r5);
  _InitNode(HEAP32[r2 + 16 >> 2], 2, 0, r6);
  if ((r3 | 0) > 0) {
    r7 = 0;
  } else {
    return;
  }
  while (1) {
    HEAP32[r4 + (r7 << 3) >> 2] = r5;
    HEAP32[r4 + (r7 << 3) + 4 >> 2] = r6;
    r2 = r7 + 1 | 0;
    if ((r2 | 0) == (r3 | 0)) {
      break;
    } else {
      r7 = r2;
    }
  }
  return;
}
function _BoundaryPM(r1, r2, r3, r4, r5, r6, r7) {
  var r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21;
  r8 = 0;
  r9 = (r6 << 3) + r1 + 4 | 0;
  r10 = HEAP32[HEAP32[r9 >> 2] + 8 >> 2];
  r11 = (r6 | 0) == 0;
  r12 = (r10 | 0) < (r4 | 0);
  if (r12 | r11 ^ 1) {
    r13 = r6;
    r14 = r7;
    r15 = r9;
    r16 = r10;
    r17 = r11;
    r18 = r12;
  } else {
    return;
  }
  while (1) {
    r19 = _GetFreeNode(r1, r2, r5);
    r20 = HEAP32[r15 >> 2];
    HEAP32[r1 + (r13 << 3) >> 2] = r20;
    HEAP32[r15 >> 2] = r19;
    if (r17) {
      r8 = 681;
      break;
    }
    r12 = r13 - 1 | 0;
    r11 = (r12 << 3) + r1 + 4 | 0;
    r10 = HEAP32[HEAP32[r11 >> 2] >> 2] + HEAP32[HEAP32[r1 + (r12 << 3) >> 2] >> 2] | 0;
    if (r18) {
      r21 = HEAP32[r3 + (r16 << 4) >> 2];
      if (r10 >>> 0 > r21 >>> 0) {
        r8 = 684;
        break;
      }
    }
    _InitNode(r10, r16, HEAP32[r11 >> 2], r19);
    if (r14 << 24 >> 24 != 0) {
      r8 = 690;
      break;
    }
    _BoundaryPM(r1, r2, r3, r4, r5, r12, 0);
    r11 = (r12 << 3) + r1 + 4 | 0;
    r10 = HEAP32[HEAP32[r11 >> 2] + 8 >> 2];
    r9 = (r12 | 0) == 0;
    r7 = (r10 | 0) < (r4 | 0);
    if (r7 | r9 ^ 1) {
      r13 = r12;
      r14 = 0;
      r15 = r11;
      r16 = r10;
      r17 = r9;
      r18 = r7;
    } else {
      r8 = 691;
      break;
    }
  }
  if (r8 == 681) {
    _InitNode(HEAP32[r3 + (r16 << 4) >> 2], r16 + 1 | 0, 0, r19);
    return;
  } else if (r8 == 684) {
    _InitNode(r21, r16 + 1 | 0, HEAP32[r20 + 4 >> 2], r19);
    return;
  } else if (r8 == 690) {
    return;
  } else if (r8 == 691) {
    return;
  }
}
function _ZopfliCleanLZ77Store(r1) {
  _free(HEAP32[r1 >> 2]);
  _free(HEAP32[r1 + 4 >> 2]);
  return;
}
function _ZopfliStoreLitLenDist(r1, r2, r3) {
  var r4, r5, r6, r7, r8, r9, r10;
  r4 = r3 >> 2;
  r5 = (r3 + 8 | 0) >> 2;
  r3 = HEAP32[r5];
  r6 = (r3 - 1 & r3 | 0) != 0;
  do {
    if (r6) {
      HEAP16[HEAP32[r4] + (r3 << 1) >> 1] = r1;
      HEAP32[r5] = HEAP32[r5] + 1 | 0;
    } else {
      r7 = (r3 | 0) == 0;
      if (r7) {
        r8 = _malloc(2);
      } else {
        r8 = _realloc(HEAP32[r4], r3 << 2);
      }
      r9 = r8;
      HEAP32[r4] = r9;
      HEAP16[r9 + (HEAP32[r5] << 1) >> 1] = r1;
      HEAP32[r5] = HEAP32[r5] + 1 | 0;
      if (r6) {
        break;
      }
      if (r7) {
        r10 = _malloc(2);
      } else {
        r10 = _realloc(HEAP32[r4 + 1], r3 << 2);
      }
      HEAP32[r4 + 1] = r10;
    }
  } while (0);
  HEAP16[HEAP32[r4 + 1] + (r3 << 1) >> 1] = r2;
  return;
}
function _ZopfliVerifyLenDist(r1, r2, r3, r4, r5) {
  var r6, r7;
  r6 = 0;
  r7 = r5 & 65535;
  if ((r7 + r3 | 0) >>> 0 > r2 >>> 0) {
    ___assert_func(5244888, 86, 5246444, 5245576);
  }
  r2 = r3 - (r4 & 65535) | 0;
  r4 = 0;
  while (1) {
    if (r4 >>> 0 >= r7 >>> 0) {
      r6 = 713;
      break;
    }
    if (HEAP8[r1 + r2 + r4 | 0] << 24 >> 24 == HEAP8[r1 + r4 + r3 | 0] << 24 >> 24) {
      r4 = r4 + 1 | 0;
    } else {
      break;
    }
  }
  if (r6 == 713) {
    return;
  }
  ___assert_func(5244888, 89, 5246444, 5245076);
  return;
}
function _ZopfliCopyLZ77Store(r1, r2) {
  var r3, r4, r5, r6, r7;
  _ZopfliCleanLZ77Store(r2);
  r3 = (r1 + 8 | 0) >> 2;
  r4 = (r2 | 0) >> 2;
  HEAP32[r4] = _malloc(HEAP32[r3] << 1);
  r5 = _malloc(HEAP32[r3] << 1);
  r6 = r2 + 4 | 0;
  HEAP32[r6 >> 2] = r5;
  if ((HEAP32[r4] | 0) == 0 | (r5 | 0) == 0) {
    _exit(-1);
  }
  HEAP32[r2 + 8 >> 2] = HEAP32[r3];
  if ((HEAP32[r3] | 0) == 0) {
    return;
  }
  r2 = r1 | 0;
  r5 = r1 + 4 | 0;
  r1 = 0;
  while (1) {
    HEAP16[HEAP32[r4] + (r1 << 1) >> 1] = HEAP16[HEAP32[r2 >> 2] + (r1 << 1) >> 1];
    HEAP16[HEAP32[r6 >> 2] + (r1 << 1) >> 1] = HEAP16[HEAP32[r5 >> 2] + (r1 << 1) >> 1];
    r7 = r1 + 1 | 0;
    if (r7 >>> 0 < HEAP32[r3] >>> 0) {
      r1 = r7;
    } else {
      break;
    }
  }
  return;
}
function _GetLengthValue(r1, r2) {
  return (((r2 | 0) > 1024) << 31 >> 31) + r1 | 0;
}
function _GetMatch(r1, r2, r3, r4) {
  var r5, r6, r7, r8, r9, r10, r11, r12, r13, r14;
  r5 = 0;
  L984 : do {
    if (r1 >>> 0 < r4 >>> 0) {
      r6 = r2;
      r7 = r1;
      while (1) {
        if ((HEAP32[r7 >> 2] | 0) != (HEAP32[r6 >> 2] | 0)) {
          r8 = r6;
          r9 = r7;
          break L984;
        }
        r10 = r7 + 4 | 0;
        r11 = r6 + 4 | 0;
        if (r10 >>> 0 < r4 >>> 0) {
          r6 = r11;
          r7 = r10;
        } else {
          r8 = r11;
          r9 = r10;
          break L984;
        }
      }
    } else {
      r8 = r2;
      r9 = r1;
    }
  } while (0);
  if ((r9 | 0) == (r3 | 0)) {
    r12 = r9;
    return r12;
  } else {
    r13 = r8;
    r14 = r9;
  }
  while (1) {
    if (HEAP8[r14] << 24 >> 24 != HEAP8[r13] << 24 >> 24) {
      r12 = r14;
      r5 = 730;
      break;
    }
    r9 = r14 + 1 | 0;
    if ((r9 | 0) == (r3 | 0)) {
      r12 = r9;
      r5 = 732;
      break;
    } else {
      r13 = r13 + 1 | 0;
      r14 = r9;
    }
  }
  if (r5 == 730) {
    return r12;
  } else if (r5 == 732) {
    return r12;
  }
}
function _InitRanState(r1) {
  HEAP32[r1 >> 2] = 1;
  HEAP32[r1 + 4 >> 2] = 2;
  return;
}
function _ZopfliFindLongestMatch(r1, r2, r3, r4, r5, r6, r7, r8, r9) {
  var r10, r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31, r32, r33, r34, r35, r36, r37, r38, r39, r40, r41, r42, r43, r44, r45, r46, r47, r48, r49, r50;
  r10 = STACKTOP;
  STACKTOP = STACKTOP + 4 | 0;
  r11 = r10, r12 = r11 >> 2;
  HEAP32[r12] = r6;
  r6 = r4 & 32767;
  r13 = HEAP32[r2 >> 2];
  r14 = HEAP32[r2 + 4 >> 2];
  r15 = HEAP32[r2 + 8 >> 2];
  r16 = HEAP32[r2 + 12 >> 2];
  if ((_TryGetFromLongestMatchCache(r1, r4, r11, r7, r8, r9) | 0) != 0) {
    if ((HEAPU16[r9 >> 1] + r4 | 0) >>> 0 <= r5 >>> 0) {
      STACKTOP = r10;
      return;
    }
    ___assert_func(5244888, 238, 5246528, 5244792);
    STACKTOP = r10;
    return;
  }
  r11 = HEAP32[r12];
  if (r11 >>> 0 < 259) {
    r17 = r11;
  } else {
    ___assert_func(5244888, 243, 5246528, 5244616);
    r17 = HEAP32[r12];
  }
  if (r17 >>> 0 <= 2) {
    ___assert_func(5244888, 244, 5246528, 5244500);
  }
  r17 = r4 >>> 0 < r5 >>> 0;
  if (!r17) {
    ___assert_func(5244888, 245, 5246528, 5244336);
  }
  r11 = r5 - r4 | 0;
  if (r11 >>> 0 < 3) {
    HEAP16[r9 >> 1] = 0;
    HEAP16[r8 >> 1] = 0;
    STACKTOP = r10;
    return;
  }
  if ((HEAP32[r12] + r4 | 0) >>> 0 > r5 >>> 0) {
    HEAP32[r12] = r11;
  }
  r11 = r3 + r4 | 0;
  r18 = HEAP32[r12] + r4 | 0;
  r19 = r3 + r18 | 0;
  r20 = r3 + (r18 - 8) | 0;
  if ((r16 | 0) >= 65536) {
    ___assert_func(5244888, 261, 5246528, 5244212);
  }
  r18 = HEAP32[r13 + (r16 << 2) >> 2];
  r21 = r18 & 65535;
  r22 = HEAP16[r14 + (r21 << 1) >> 1];
  if ((r21 | 0) != (r6 | 0)) {
    ___assert_func(5244888, 266, 5246528, 5244140);
  }
  r23 = r22 & 65535;
  r24 = r2 + 16 | 0;
  r25 = r2 + 32 | 0;
  r26 = r2 + 28 | 0;
  r27 = r2 + 24 | 0;
  r28 = r2 + 20 | 0;
  r29 = r2 + 32 | 0;
  r2 = r11;
  r30 = (r7 | 0) == 0;
  r31 = r22;
  r22 = r18 & 65535;
  r18 = r16;
  r16 = r15;
  r15 = r14;
  r14 = r13;
  r13 = (r23 >>> 0 < r21 >>> 0 ? r21 : r21 + 32768 | 0) - r23 | 0;
  r23 = 8192;
  r21 = 0;
  r32 = 1;
  L1028 : while (1) {
    if (r13 >>> 0 >= 32768) {
      r33 = r21;
      r34 = r32;
      break;
    }
    r35 = r31 & 65535;
    if (r31 << 16 >> 16 <= -1) {
      ___assert_func(5244888, 274, 5246528, 5243992);
    }
    if (r31 << 16 >> 16 != HEAP16[r15 + ((r22 & 65535) << 1) >> 1] << 16 >> 16) {
      ___assert_func(5244888, 275, 5246528, 5245860);
    }
    if ((HEAP32[r16 + (r35 << 2) >> 2] | 0) != (r18 | 0)) {
      ___assert_func(5244888, 276, 5246528, 5245724);
    }
    do {
      if ((r13 | 0) == 0) {
        r36 = r21;
        r37 = r32;
      } else {
        if (!r17) {
          ___assert_func(5244888, 279, 5246528, 5244336);
        }
        if (r13 >>> 0 > r4 >>> 0) {
          ___assert_func(5244888, 280, 5246528, 5245624);
        }
        r38 = r4 - r13 | 0;
        r39 = r3 + r38 | 0;
        r40 = r32 & 65535;
        r41 = r40 + r4 | 0;
        if (r41 >>> 0 < r5 >>> 0) {
          if (HEAP8[r3 + r41 | 0] << 24 >> 24 != HEAP8[r3 + r38 + r40 | 0] << 24 >> 24) {
            r36 = r21;
            r37 = r32;
            break;
          }
        }
        r40 = HEAP32[r29 >> 2];
        r41 = HEAP16[r40 + (r6 << 1) >> 1];
        do {
          if ((r41 & 65535) > 2) {
            if (HEAP8[r11] << 24 >> 24 != HEAP8[r39] << 24 >> 24) {
              r42 = r39;
              r43 = r11;
              break;
            }
            r44 = HEAP16[r40 + ((r38 & 32767) << 1) >> 1];
            r45 = (r41 & 65535) < (r44 & 65535) ? r41 : r44;
            r44 = HEAP32[r12];
            r46 = ((r45 & 65535) >>> 0 > r44 >>> 0 ? r44 & 65535 : r45) & 65535;
            r42 = r3 + r46 + r38 | 0;
            r43 = r3 + r46 + r4 | 0;
          } else {
            r42 = r39;
            r43 = r11;
          }
        } while (0);
        r39 = _GetMatch(r43, r42, r19, r20) - r2 | 0;
        r38 = r39 & 65535;
        r41 = r39 & 65535;
        if ((r38 & 65535) <= (r32 & 65535)) {
          r36 = r21;
          r37 = r32;
          break;
        }
        L1056 : do {
          if (!r30) {
            r39 = r32 + 1 & 65535;
            if ((r39 & 65535) > (r38 & 65535)) {
              break;
            }
            r40 = r13 & 65535;
            r46 = r39;
            while (1) {
              HEAP16[r7 + ((r46 & 65535) << 1) >> 1] = r40;
              r39 = r46 + 1 & 65535;
              if ((r39 & 65535) > (r38 & 65535)) {
                break L1056;
              } else {
                r46 = r39;
              }
            }
          }
        } while (0);
        r46 = r13 & 65535;
        if (r41 >>> 0 < HEAP32[r12] >>> 0) {
          r36 = r46;
          r37 = r38;
        } else {
          r33 = r46;
          r34 = r38;
          break L1028;
        }
      }
    } while (0);
    r46 = HEAP32[r24 >> 2];
    do {
      if ((r14 | 0) == (r46 | 0)) {
        r47 = r18;
        r48 = r16;
        r49 = r15;
        r50 = r14;
      } else {
        if ((r37 & 65535) < HEAPU16[HEAP32[r25 >> 2] + (r6 << 1) >> 1]) {
          r47 = r18;
          r48 = r16;
          r49 = r15;
          r50 = r14;
          break;
        }
        r40 = HEAP32[r26 >> 2];
        r39 = HEAP32[r27 >> 2];
        if ((r40 | 0) != (HEAP32[r39 + (r35 << 2) >> 2] | 0)) {
          r47 = r18;
          r48 = r16;
          r49 = r15;
          r50 = r14;
          break;
        }
        r47 = r40;
        r48 = r39;
        r49 = HEAP32[r28 >> 2];
        r50 = r46;
      }
    } while (0);
    r46 = HEAP16[r49 + (r35 << 1) >> 1];
    if (r46 << 16 >> 16 == r31 << 16 >> 16) {
      r33 = r36;
      r34 = r37;
      break;
    }
    r39 = ((r46 & 65535) < (r31 & 65535) ? r35 : r35 + 32768 | 0) - (r46 & 65535) + r13 | 0;
    r40 = r23 - 1 | 0;
    if ((r40 | 0) < 1) {
      r33 = r36;
      r34 = r37;
      break;
    } else {
      r22 = r31;
      r31 = r46;
      r18 = r47;
      r16 = r48;
      r15 = r49;
      r14 = r50;
      r13 = r39;
      r23 = r40;
      r21 = r36;
      r32 = r37;
    }
  }
  _StoreInLongestMatchCache(r1, r4, HEAP32[r12], r7, r33, r34);
  r7 = r34 & 65535;
  if (r7 >>> 0 > HEAP32[r12] >>> 0) {
    ___assert_func(5244888, 344, 5246528, 5245556);
  }
  HEAP16[r8 >> 1] = r33;
  HEAP16[r9 >> 1] = r34;
  if ((r7 + r4 | 0) >>> 0 <= r5 >>> 0) {
    STACKTOP = r10;
    return;
  }
  ___assert_func(5244888, 348, 5246528, 5244792);
  STACKTOP = r10;
  return;
}
function _TryGetFromLongestMatchCache(r1, r2, r3, r4, r5, r6) {
  var r7, r8, r9, r10;
  r7 = r6 >> 1;
  r6 = r2 - HEAP32[r1 + 8 >> 2] | 0;
  r2 = (r1 + 4 | 0) >> 2;
  r1 = HEAP32[r2];
  if ((r1 | 0) == 0) {
    r8 = 0;
    return r8;
  }
  do {
    if (HEAP16[HEAP32[r1 >> 2] + (r6 << 1) >> 1] << 16 >> 16 != 0) {
      if (HEAP16[HEAP32[r1 + 4 >> 2] + (r6 << 1) >> 1] << 16 >> 16 == 0) {
        r8 = 0;
      } else {
        break;
      }
      return r8;
    }
  } while (0);
  r1 = HEAP32[r3 >> 2];
  do {
    if ((r1 | 0) == 258) {
      r9 = 0;
    } else {
      r10 = HEAP32[r2];
      if (HEAPU16[HEAP32[r10 >> 2] + (r6 << 1) >> 1] >>> 0 <= r1 >>> 0) {
        r9 = 0;
        break;
      }
      if ((r4 | 0) == 0) {
        r8 = 0;
        return r8;
      } else {
        r9 = _ZopfliMaxCachedSublen(r10, r6, 0) >>> 0 < r1 >>> 0;
        break;
      }
    }
  } while (0);
  r1 = HEAP32[r2];
  if ((r1 | 0) == 0 | r9) {
    r8 = 0;
    return r8;
  }
  r9 = (r4 | 0) != 0;
  do {
    if (r9) {
      r10 = HEAPU16[HEAP32[r1 >> 2] + (r6 << 1) >> 1];
      if (r10 >>> 0 <= _ZopfliMaxCachedSublen(r1, r6, 0) >>> 0) {
        break;
      }
      HEAP32[r3 >> 2] = r10;
      r8 = 0;
      return r8;
    }
  } while (0);
  r1 = HEAP16[HEAP32[HEAP32[r2] >> 2] + (r6 << 1) >> 1];
  HEAP16[r7] = r1;
  r10 = HEAP32[r3 >> 2];
  if ((r1 & 65535) >>> 0 > r10 >>> 0) {
    HEAP16[r7] = r10 & 65535;
  }
  r10 = HEAP32[r2];
  if (!r9) {
    HEAP16[r5 >> 1] = HEAP16[HEAP32[r10 + 4 >> 2] + (r6 << 1) >> 1];
    r8 = 1;
    return r8;
  }
  _ZopfliCacheToSublen(r10, r6, HEAPU16[r7], r4);
  HEAP16[r5 >> 1] = HEAP16[r4 + (HEAPU16[r7] << 1) >> 1];
  if ((HEAP32[r3 >> 2] | 0) != 258) {
    r8 = 1;
    return r8;
  }
  r3 = HEAP16[r7];
  if ((r3 & 65535) <= 2) {
    r8 = 1;
    return r8;
  }
  if (HEAP16[r4 + ((r3 & 65535) << 1) >> 1] << 16 >> 16 == HEAP16[HEAP32[HEAP32[r2] + 4 >> 2] + (r6 << 1) >> 1] << 16 >> 16) {
    r8 = 1;
    return r8;
  }
  ___assert_func(5244888, 172, 5246676, 5245224);
  r8 = 1;
  return r8;
}
function _StoreInLongestMatchCache(r1, r2, r3, r4, r5, r6) {
  var r7, r8, r9;
  r7 = 0;
  r8 = r2 - HEAP32[r1 + 8 >> 2] | 0;
  r2 = (r1 + 4 | 0) >> 2;
  r1 = HEAP32[r2];
  do {
    if ((r1 | 0) == 0) {
      r9 = 0;
    } else {
      if (HEAP16[HEAP32[r1 >> 2] + (r8 << 1) >> 1] << 16 >> 16 == 0) {
        r9 = 1;
        break;
      }
      r9 = HEAP16[HEAP32[r1 + 4 >> 2] + (r8 << 1) >> 1] << 16 >> 16 != 0;
    }
  } while (0);
  r1 = HEAP32[r2];
  if ((r3 | 0) != 258 | (r1 | 0) == 0 | (r4 | 0) == 0 | r9) {
    return;
  }
  do {
    if (HEAP16[HEAP32[r1 >> 2] + (r8 << 1) >> 1] << 16 >> 16 == 1) {
      if (HEAP16[HEAP32[r1 + 4 >> 2] + (r8 << 1) >> 1] << 16 >> 16 == 0) {
        break;
      } else {
        r7 = 827;
        break;
      }
    } else {
      r7 = 827;
    }
  } while (0);
  if (r7 == 827) {
    ___assert_func(5244888, 205, 5246720, 5245364);
  }
  r7 = r6 & 65535;
  r1 = (r6 & 65535) < 3;
  HEAP16[HEAP32[HEAP32[r2] + 4 >> 2] + (r8 << 1) >> 1] = r1 ? 0 : r5;
  HEAP16[HEAP32[HEAP32[r2] >> 2] + (r8 << 1) >> 1] = r1 ? 0 : r6;
  r6 = HEAP32[r2];
  do {
    if (HEAP16[HEAP32[r6 >> 2] + (r8 << 1) >> 1] << 16 >> 16 == 1) {
      if (HEAP16[HEAP32[r6 + 4 >> 2] + (r8 << 1) >> 1] << 16 >> 16 != 0) {
        break;
      }
      ___assert_func(5244888, 208, 5246720, 5245264);
    }
  } while (0);
  _ZopfliSublenToCache(r4, r8, r7, HEAP32[r2]);
  return;
}
function _ZopfliLZ77Greedy(r1, r2, r3, r4, r5) {
  var r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31, r32;
  r6 = 0;
  r7 = STACKTOP;
  STACKTOP = STACKTOP + 564 | 0;
  r8 = r7, r9 = r8 >> 1;
  r10 = r7 + 4, r11 = r10 >> 1;
  r12 = r7 + 8;
  r13 = r7 + 528;
  r14 = r3 >>> 0 > 32768 ? r3 - 32768 | 0 : 0;
  if ((r3 | 0) == (r4 | 0)) {
    STACKTOP = r7;
    return;
  }
  _ZopfliInitHash(32768, r13);
  _ZopfliWarmupHash(r2, r14, 0, r13);
  L1139 : do {
    if (r14 >>> 0 < r3 >>> 0) {
      r15 = r14;
      while (1) {
        _ZopfliUpdateHash(r2, r15, r4, r13);
        r16 = r15 + 1 | 0;
        if ((r16 | 0) == (r3 | 0)) {
          break L1139;
        } else {
          r15 = r16;
        }
      }
    }
  } while (0);
  L1143 : do {
    if (r3 >>> 0 < r4 >>> 0) {
      r14 = r12 | 0;
      r15 = 0;
      r16 = 0;
      r17 = r3;
      r18 = 0;
      while (1) {
        _ZopfliUpdateHash(r2, r17, r4, r13);
        _ZopfliFindLongestMatch(r1, r13, r2, r17, r4, 258, r14, r10, r8);
        r19 = HEAP16[r9];
        r20 = r19 & 65535;
        r21 = HEAPU16[r11];
        r22 = _GetLengthValue(r20, r21);
        do {
          if ((r18 | 0) == 0) {
            if ((r22 | 0) <= 2) {
              r6 = 853;
              break;
            }
            if ((r19 & 65535) < 258) {
              r23 = 1;
              r24 = r17;
              r25 = r21;
              r26 = r20;
              break;
            } else {
              r6 = 852;
              break;
            }
          } else {
            if ((r22 | 0) > (_GetLengthValue(r15, r16) + 1 | 0)) {
              _ZopfliStoreLitLenDist(HEAPU8[r2 + (r17 - 1) | 0], 0, r5);
              if ((r22 - 3 | 0) >>> 0 < 255) {
                r23 = 1;
                r24 = r17;
                r25 = HEAPU16[r11];
                r26 = HEAPU16[r9];
                break;
              } else {
                if ((r22 | 0) > 2) {
                  r6 = 852;
                  break;
                } else {
                  r6 = 853;
                  break;
                }
              }
            }
            r27 = r15 & 65535;
            HEAP16[r9] = r27;
            r28 = r16 & 65535;
            HEAP16[r11] = r28;
            _ZopfliVerifyLenDist(r2, r4, r17 - 1 | 0, r28, r27);
            _ZopfliStoreLitLenDist(HEAP16[r9], HEAP16[r11], r5);
            if (HEAPU16[r9] <= 2) {
              r23 = 0;
              r24 = r17;
              r25 = r16;
              r26 = r15;
              break;
            }
            r27 = HEAP16[r9];
            r28 = r27 & 65535;
            r29 = r27 & 65535;
            r27 = r29 >>> 0 > 3 ? r29 : 3;
            r29 = 2;
            r30 = r17;
            while (1) {
              if (r30 >>> 0 >= r4 >>> 0) {
                ___assert_func(5244888, 410, 5246508, 5245496);
              }
              r31 = r30 + 1 | 0;
              _ZopfliUpdateHash(r2, r31, r4, r13);
              r32 = r29 + 1 | 0;
              if (r32 >>> 0 < r28 >>> 0) {
                r29 = r32;
                r30 = r31;
              } else {
                break;
              }
            }
            r23 = 0;
            r24 = r17 - 2 + r27 | 0;
            r25 = r16;
            r26 = r15;
            break;
          }
        } while (0);
        do {
          if (r6 == 853) {
            r6 = 0;
            HEAP16[r9] = 1;
            _ZopfliStoreLitLenDist(HEAPU8[r2 + r17 | 0], 0, r5);
            r6 = 854;
            break;
          } else if (r6 == 852) {
            r6 = 0;
            _ZopfliVerifyLenDist(r2, r4, r17, HEAP16[r11], HEAP16[r9]);
            _ZopfliStoreLitLenDist(HEAP16[r9], HEAP16[r11], r5);
            r6 = 854;
            break;
          }
        } while (0);
        do {
          if (r6 == 854) {
            r6 = 0;
            if (HEAPU16[r9] <= 1) {
              r23 = 0;
              r24 = r17;
              r25 = r16;
              r26 = r15;
              break;
            }
            r22 = HEAP16[r9];
            r20 = r22 & 65535;
            r21 = r22 & 65535;
            r22 = r21 >>> 0 > 2 ? r21 : 2;
            r21 = 1;
            r19 = r17;
            while (1) {
              if (r19 >>> 0 >= r4 >>> 0) {
                ___assert_func(5244888, 435, 5246508, 5245496);
              }
              r30 = r19 + 1 | 0;
              _ZopfliUpdateHash(r2, r30, r4, r13);
              r29 = r21 + 1 | 0;
              if (r29 >>> 0 < r20 >>> 0) {
                r21 = r29;
                r19 = r30;
              } else {
                break;
              }
            }
            r23 = 0;
            r24 = r17 - 1 + r22 | 0;
            r25 = r16;
            r26 = r15;
          }
        } while (0);
        r19 = r24 + 1 | 0;
        if (r19 >>> 0 < r4 >>> 0) {
          r15 = r26;
          r16 = r25;
          r17 = r19;
          r18 = r23;
        } else {
          break L1143;
        }
      }
    }
  } while (0);
  _ZopfliCleanHash(r13);
  STACKTOP = r7;
  return;
}
function _ZopfliLZ77Counts(r1, r2, r3, r4, r5, r6) {
  var r7, r8, r9, r10, r11;
  r7 = r5;
  for (r8 = r7 >> 2, r9 = r8 + 288; r8 < r9; r8++) {
    HEAP32[r8] = 0;
  }
  r7 = r6;
  for (r8 = r7 >> 2, r9 = r8 + 32; r8 < r9; r8++) {
    HEAP32[r8] = 0;
  }
  if (r3 >>> 0 < r4 >>> 0) {
    r10 = r3;
  } else {
    r11 = r5 + 1024 | 0;
    HEAP32[r11 >> 2] = 1;
    return;
  }
  while (1) {
    r3 = (r10 << 1) + r2 | 0;
    r8 = HEAPU16[r1 + (r10 << 1) >> 1];
    if (HEAP16[r3 >> 1] << 16 >> 16 == 0) {
      r9 = (r8 << 2) + r5 | 0;
      HEAP32[r9 >> 2] = HEAP32[r9 >> 2] + 1 | 0;
    } else {
      r9 = (_ZopfliGetLengthSymbol(r8) << 2) + r5 | 0;
      HEAP32[r9 >> 2] = HEAP32[r9 >> 2] + 1 | 0;
      r9 = (_ZopfliGetDistSymbol(HEAPU16[r3 >> 1]) << 2) + r6 | 0;
      HEAP32[r9 >> 2] = HEAP32[r9 >> 2] + 1 | 0;
    }
    r9 = r10 + 1 | 0;
    if ((r9 | 0) == (r4 | 0)) {
      break;
    } else {
      r10 = r9;
    }
  }
  r11 = r5 + 1024 | 0;
  HEAP32[r11 >> 2] = 1;
  return;
}
function _InitStats(r1) {
  _memset(r1, 0, 3840);
  return;
}
function _ZopfliLZ77Optimal(r1, r2, r3, r4, r5) {
  var r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31;
  r6 = STACKTOP;
  STACKTOP = STACKTOP + 11548 | 0;
  r7 = r6, r8 = r7 >> 2;
  r9 = r6 + 4;
  r10 = r6 + 8;
  r11 = r6 + 20;
  r12 = r6 + 3860;
  r13 = r6 + 7700;
  r14 = r6 + 11540;
  r15 = _malloc((r4 - r3 << 1) + 2 | 0);
  r16 = r15;
  HEAP32[r8] = 0;
  HEAP32[r9 >> 2] = 0;
  if ((r15 | 0) == 0) {
    _exit(-1);
  }
  _InitRanState(r14);
  _InitStats(r11);
  _ZopfliInitLZ77Store(r10);
  _ZopfliLZ77Greedy(r1, r2, r3, r4, r10);
  _GetStatistics(r10, r11);
  r17 = r1 | 0;
  if ((HEAP32[HEAP32[r17 >> 2] + 4 >> 2] | 0) <= 0) {
    _free(r15);
    r18 = HEAP32[r8];
    r19 = r18;
    _free(r19);
    _ZopfliCleanLZ77Store(r10);
    STACKTOP = r6;
    return;
  }
  r20 = r11;
  r21 = r10 | 0;
  r22 = r10 + 4 | 0;
  r23 = r10 + 8 | 0;
  r24 = 0;
  r25 = 1e+30;
  r26 = 0;
  r27 = -1;
  while (1) {
    _ZopfliCleanLZ77Store(r10);
    _ZopfliInitLZ77Store(r10);
    _LZ77OptimalRun(r1, r2, r3, r4, r7, r9, r16, 6, r20, r10);
    r28 = _ZopfliCalculateBlockSize(HEAP32[r21 >> 2], HEAP32[r22 >> 2], 0, HEAP32[r23 >> 2], 2);
    if (r28 < r25) {
      _ZopfliCopyLZ77Store(r10, r5);
      _CopyStats(r11, r12);
      r29 = r28;
    } else {
      r29 = r25;
    }
    _CopyStats(r11, r13);
    _ClearStatFreqs(r11);
    _GetStatistics(r10, r11);
    if ((r27 | 0) != -1) {
      _AddWeighedStatFreqs(r11, r13, r11);
      _CalculateStatistics(r11);
    }
    if ((r24 | 0) > 5 & r28 == r26) {
      _CopyStats(r12, r11);
      _RandomizeStatFreqs(r14, r11);
      _CalculateStatistics(r11);
      r30 = r24;
    } else {
      r30 = r27;
    }
    r31 = r24 + 1 | 0;
    if ((r31 | 0) < (HEAP32[HEAP32[r17 >> 2] + 4 >> 2] | 0)) {
      r24 = r31;
      r25 = r29;
      r26 = r28;
      r27 = r30;
    } else {
      break;
    }
  }
  _free(r15);
  r18 = HEAP32[r8];
  r19 = r18;
  _free(r19);
  _ZopfliCleanLZ77Store(r10);
  STACKTOP = r6;
  return;
}
function _AddWeighedStatFreqs(r1, r2, r3) {
  var r4, r5, r6;
  r4 = 0;
  while (1) {
    r5 = (HEAP32[r1 + (r4 << 2) >> 2] >>> 0) + (HEAP32[r2 + (r4 << 2) >> 2] >>> 0) * .5;
    HEAP32[r3 + (r4 << 2) >> 2] = r5 >= 0 ? Math.floor(r5) : Math.ceil(r5);
    r5 = r4 + 1 | 0;
    if ((r5 | 0) == 288) {
      r6 = 0;
      break;
    } else {
      r4 = r5;
    }
  }
  while (1) {
    r4 = (HEAP32[r1 + (r6 << 2) + 1152 >> 2] >>> 0) + (HEAP32[r2 + (r6 << 2) + 1152 >> 2] >>> 0) * .5;
    HEAP32[r3 + (r6 << 2) + 1152 >> 2] = r4 >= 0 ? Math.floor(r4) : Math.ceil(r4);
    r4 = r6 + 1 | 0;
    if ((r4 | 0) == 32) {
      break;
    } else {
      r6 = r4;
    }
  }
  HEAP32[r3 + 1024 >> 2] = 1;
  return;
}
function _Ran(r1) {
  var r2, r3, r4;
  r2 = (r1 + 4 | 0) >> 2;
  r3 = HEAP32[r2];
  HEAP32[r2] = ((r3 & 65535) * 36969 & -1) + (r3 >>> 16) | 0;
  r3 = r1 | 0;
  r1 = HEAP32[r3 >> 2];
  r4 = ((r1 & 65535) * 18e3 & -1) + (r1 >>> 16) | 0;
  HEAP32[r3 >> 2] = r4;
  return (HEAP32[r2] << 16) + r4 | 0;
}
function _GetStatistics(r1, r2) {
  var r3, r4, r5, r6, r7, r8;
  r3 = r1 + 8 | 0;
  if ((HEAP32[r3 >> 2] | 0) == 0) {
    r4 = r2 + 1024 | 0;
    HEAP32[r4 >> 2] = 1;
    _CalculateStatistics(r2);
    return;
  }
  r5 = r1 + 4 | 0;
  r6 = r1 | 0;
  r1 = 0;
  while (1) {
    r7 = HEAPU16[HEAP32[r6 >> 2] + (r1 << 1) >> 1];
    if (HEAP16[HEAP32[r5 >> 2] + (r1 << 1) >> 1] << 16 >> 16 == 0) {
      r8 = (r7 << 2) + r2 | 0;
      HEAP32[r8 >> 2] = HEAP32[r8 >> 2] + 1 | 0;
    } else {
      r8 = (_ZopfliGetLengthSymbol(r7) << 2) + r2 | 0;
      HEAP32[r8 >> 2] = HEAP32[r8 >> 2] + 1 | 0;
      r8 = (_ZopfliGetDistSymbol(HEAPU16[HEAP32[r5 >> 2] + (r1 << 1) >> 1]) << 2) + r2 + 1152 | 0;
      HEAP32[r8 >> 2] = HEAP32[r8 >> 2] + 1 | 0;
    }
    r8 = r1 + 1 | 0;
    if (r8 >>> 0 < HEAP32[r3 >> 2] >>> 0) {
      r1 = r8;
    } else {
      break;
    }
  }
  r4 = r2 + 1024 | 0;
  HEAP32[r4 >> 2] = 1;
  _CalculateStatistics(r2);
  return;
}
function _LZ77OptimalRun(r1, r2, r3, r4, r5, r6, r7, r8, r9, r10) {
  var r11;
  r11 = _GetBestLengths(r1, r2, r3, r4, r8, r9, r7);
  _free(HEAP32[r5 >> 2]);
  HEAP32[r5 >> 2] = 0;
  HEAP32[r6 >> 2] = 0;
  _TraceBackwards(r4 - r3 | 0, r7, r5, r6);
  _FollowPath(r1, r2, r3, r4, HEAP32[r5 >> 2], HEAP32[r6 >> 2], r10);
  if (r11 < 1e+30) {
    return;
  }
  ___assert_func(5244448, 443, 5246772, 5245336);
  return;
}
function _GetCostStat(r1, r2, r3) {
  var r4, r5, r6, r7;
  if ((r2 | 0) == 0) {
    r4 = (r1 << 3) + r3 + 1280 | 0;
    r5 = (HEAP32[tempDoublePtr >> 2] = HEAP32[r4 >> 2], HEAP32[tempDoublePtr + 4 >> 2] = HEAP32[r4 + 4 >> 2], HEAPF64[tempDoublePtr >> 3]);
    return r5;
  } else {
    r4 = _ZopfliGetLengthSymbol(r1);
    r6 = _ZopfliGetLengthExtraBits(r1);
    r1 = _ZopfliGetDistSymbol(r2);
    r7 = _ZopfliGetDistExtraBits(r2);
    r2 = (r4 << 3) + r3 + 1280 | 0;
    r4 = (r1 << 3) + r3 + 3584 | 0;
    r5 = (r6 | 0) + (HEAP32[tempDoublePtr >> 2] = HEAP32[r2 >> 2], HEAP32[tempDoublePtr + 4 >> 2] = HEAP32[r2 + 4 >> 2], HEAPF64[tempDoublePtr >> 3]) + (r7 | 0) + (HEAP32[tempDoublePtr >> 2] = HEAP32[r4 >> 2], HEAP32[tempDoublePtr + 4 >> 2] = HEAP32[r4 + 4 >> 2], HEAPF64[tempDoublePtr >> 3]);
    return r5;
  }
}
function _CopyStats(r1, r2) {
  _memcpy(r2, r1, 1152);
  _memcpy(r2 + 1152 | 0, r1 + 1152 | 0, 128);
  _memcpy(r2 + 1280 | 0, r1 + 1280 | 0, 2304);
  _memcpy(r2 + 3584 | 0, r1 + 3584 | 0, 256);
  return;
}
function _ClearStatFreqs(r1) {
  var r2, r3, r4;
  r2 = r1;
  for (r3 = r2 >> 2, r4 = r3 + 288; r3 < r4; r3++) {
    HEAP32[r3] = 0;
  }
  r2 = r1 + 1152 | 0;
  for (r3 = r2 >> 2, r4 = r3 + 32; r3 < r4; r3++) {
    HEAP32[r3] = 0;
  }
  return;
}
function _CalculateStatistics(r1) {
  _ZopfliCalculateEntropy(r1 | 0, 288, r1 + 1280 | 0);
  _ZopfliCalculateEntropy(r1 + 1152 | 0, 32, r1 + 3584 | 0);
  return;
}
function _RandomizeStatFreqs(r1, r2) {
  _RandomizeFreqs(r1, r2 | 0, 288);
  _RandomizeFreqs(r1, r2 + 1152 | 0, 32);
  HEAP32[r2 + 1024 >> 2] = 1;
  return;
}
function _GetCostFixed(r1, r2, r3) {
  var r4;
  if ((r2 | 0) == 0) {
    r3 = r1 >>> 0 < 144 ? 8 : 9;
    return r3;
  } else {
    r4 = _ZopfliGetDistExtraBits(r2);
    r3 = (_ZopfliGetLengthExtraBits(r1) | 0) + (r4 | 0) + ((_ZopfliGetLengthSymbol(r1) | 0) < 280 ? 12 : 13);
    return r3;
  }
}
function _RandomizeFreqs(r1, r2, r3) {
  var r4, r5;
  if ((r3 | 0) > 0) {
    r4 = 0;
  } else {
    return;
  }
  while (1) {
    if (((_Ran(r1) >>> 4 >>> 0) % 3 | 0) == 0) {
      HEAP32[r2 + (r4 << 2) >> 2] = HEAP32[r2 + ((_Ran(r1) >>> 0) % (r3 >>> 0) << 2) >> 2];
    }
    r5 = r4 + 1 | 0;
    if ((r5 | 0) == (r3 | 0)) {
      break;
    } else {
      r4 = r5;
    }
  }
  return;
}
function _TraceBackwards(r1, r2, r3, r4) {
  var r5, r6, r7, r8, r9, r10, r11;
  r5 = r4 >> 2;
  r4 = r3 >> 2;
  if ((r1 | 0) == 0) {
    return;
  } else {
    r6 = r1;
  }
  while (1) {
    r1 = HEAP32[r5];
    if ((r1 - 1 & r1 | 0) == 0) {
      if ((r1 | 0) == 0) {
        r7 = _malloc(2);
      } else {
        r7 = _realloc(HEAP32[r4], r1 << 2);
      }
      HEAP32[r4] = r7;
    }
    r1 = ((r6 << 1) + r2 | 0) >> 1;
    HEAP16[HEAP32[r4] + (HEAP32[r5] << 1) >> 1] = HEAP16[r1];
    HEAP32[r5] = HEAP32[r5] + 1 | 0;
    r3 = HEAP16[r1];
    if ((r3 & 65535) >>> 0 > r6 >>> 0) {
      ___assert_func(5244448, 319, 5246704, 5244416);
      r8 = HEAP16[r1];
    } else {
      r8 = r3;
    }
    if ((r8 & 65535) >= 259) {
      ___assert_func(5244448, 320, 5246704, 5244296);
    }
    if (HEAP16[r1] << 16 >> 16 == 0) {
      ___assert_func(5244448, 321, 5246704, 5244184);
    }
    r3 = HEAPU16[r1];
    if ((r6 | 0) == (r3 | 0)) {
      break;
    } else {
      r6 = r6 - r3 | 0;
    }
  }
  r6 = HEAP32[r5];
  if (r6 >>> 0 > 1) {
    r9 = 0;
    r10 = 0;
    r11 = r6;
  } else {
    return;
  }
  while (1) {
    r6 = HEAP32[r4];
    r8 = (r9 << 1) + r6 | 0;
    r2 = HEAP16[r8 >> 1];
    HEAP16[r8 >> 1] = HEAP16[r6 + (r10 - 1 + r11 << 1) >> 1];
    HEAP16[HEAP32[r4] + (r10 - 1 + HEAP32[r5] << 1) >> 1] = r2;
    r2 = r9 + 1 | 0;
    r6 = r9 ^ -1;
    r8 = HEAP32[r5];
    if (r2 >>> 0 < r8 >>> 1 >>> 0) {
      r9 = r2;
      r10 = r6;
      r11 = r8;
    } else {
      break;
    }
  }
  return;
}
function _FollowPath(r1, r2, r3, r4, r5, r6, r7) {
  var r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18;
  r8 = STACKTOP;
  STACKTOP = STACKTOP + 44 | 0;
  r9 = r8;
  r10 = r8 + 36;
  r11 = r8 + 40;
  r12 = r3 >>> 0 > 32768 ? r3 - 32768 | 0 : 0;
  if ((r3 | 0) == (r4 | 0)) {
    STACKTOP = r8;
    return;
  }
  _ZopfliInitHash(32768, r9);
  _ZopfliWarmupHash(r2, r12, 0, r9);
  L1288 : do {
    if (r12 >>> 0 < r3 >>> 0) {
      r13 = r12;
      while (1) {
        _ZopfliUpdateHash(r2, r13, r4, r9);
        r14 = r13 + 1 | 0;
        if ((r14 | 0) == (r3 | 0)) {
          break L1288;
        } else {
          r13 = r14;
        }
      }
    }
  } while (0);
  L1292 : do {
    if ((r6 | 0) != 0) {
      r12 = r3;
      r13 = 0;
      while (1) {
        r14 = HEAP16[r5 + (r13 << 1) >> 1];
        if (r12 >>> 0 >= r4 >>> 0) {
          ___assert_func(5244448, 360, 5246804, 5245064);
        }
        _ZopfliUpdateHash(r2, r12, r4, r9);
        r15 = (r14 & 65535) > 2;
        if (r15) {
          r16 = r14 & 65535;
          _ZopfliFindLongestMatch(r1, r9, r2, r12, r4, r16, 0, r11, r10);
          r17 = HEAP16[r10 >> 1];
          if (r17 << 16 >> 16 != r14 << 16 >> 16 & r15 & (r17 & 65535) > 2) {
            ___assert_func(5244448, 370, 5246804, 5244732);
          }
          _ZopfliVerifyLenDist(r2, r4, r12, HEAP16[r11 >> 1], r14);
          _ZopfliStoreLitLenDist(r14, HEAP16[r11 >> 1], r7);
          r18 = r16;
        } else {
          _ZopfliStoreLitLenDist(HEAPU8[r2 + r12 | 0], 0, r7);
          r18 = 1;
        }
        r16 = r18 + r12 | 0;
        if (r16 >>> 0 > r4 >>> 0) {
          ___assert_func(5244448, 381, 5246804, 5244592);
        }
        L1308 : do {
          if (r18 >>> 0 > 1) {
            r14 = 1;
            while (1) {
              _ZopfliUpdateHash(r2, r14 + r12 | 0, r4, r9);
              r17 = r14 + 1 | 0;
              if ((r17 | 0) == (r18 | 0)) {
                break L1308;
              } else {
                r14 = r17;
              }
            }
          }
        } while (0);
        r14 = r13 + 1 | 0;
        if ((r14 | 0) == (r6 | 0)) {
          break L1292;
        } else {
          r12 = r16;
          r13 = r14;
        }
      }
    }
  } while (0);
  _ZopfliCleanHash(r9);
  STACKTOP = r8;
  return;
}
function _GetCostModelMinCost(r1, r2) {
  var r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14;
  r3 = 3;
  r4 = 0;
  r5 = 1e+30;
  while (1) {
    r6 = FUNCTION_TABLE[r1](r3, 1, r2);
    r7 = r6 < r5;
    r8 = r7 ? r3 : r4;
    r9 = r3 + 1 | 0;
    if ((r9 | 0) == 259) {
      r10 = 0;
      r11 = 0;
      r12 = 1e+30;
      break;
    } else {
      r3 = r9;
      r4 = r8;
      r5 = r7 ? r6 : r5;
    }
  }
  while (1) {
    r5 = (r11 << 2) + 5250160 | 0;
    r4 = FUNCTION_TABLE[r1](3, HEAP32[r5 >> 2], r2);
    if (r4 < r12) {
      r13 = r4;
      r14 = HEAP32[r5 >> 2];
    } else {
      r13 = r12;
      r14 = r10;
    }
    r5 = r11 + 1 | 0;
    if ((r5 | 0) == 30) {
      break;
    } else {
      r10 = r14;
      r11 = r5;
      r12 = r13;
    }
  }
  return FUNCTION_TABLE[r1](r8, r14, r2);
}
function _ZopfliLengthsToSymbols(r1, r2, r3, r4) {
  var r5, r6, r7, r8, r9, r10, r11, r12, r13;
  r5 = (r3 << 2) + 4 | 0;
  r6 = _malloc(r5);
  r7 = r6, r8 = r7 >> 2;
  r9 = _malloc(r5);
  r5 = r9;
  do {
    if ((r2 | 0) == 0) {
      r10 = 0;
    } else {
      _memset(r4, 0, r2 << 2);
      r10 = 0;
      break;
    }
  } while (0);
  while (1) {
    HEAP32[(r10 << 2 >> 2) + r8] = 0;
    r11 = r10 + 1 | 0;
    if (r11 >>> 0 > r3 >>> 0) {
      break;
    } else {
      r10 = r11;
    }
  }
  L1329 : do {
    if ((r2 | 0) != 0) {
      r10 = 0;
      while (1) {
        r11 = (r10 << 2) + r1 | 0;
        if (HEAP32[r11 >> 2] >>> 0 > r3 >>> 0) {
          ___assert_func(5244244, 47, 5246484, 5245200);
        }
        r12 = (HEAP32[r11 >> 2] << 2) + r7 | 0;
        HEAP32[r12 >> 2] = HEAP32[r12 >> 2] + 1 | 0;
        r12 = r10 + 1 | 0;
        if ((r12 | 0) == (r2 | 0)) {
          break L1329;
        } else {
          r10 = r12;
        }
      }
    }
  } while (0);
  HEAP32[r8] = 0;
  L1336 : do {
    if ((r3 | 0) != 0) {
      r7 = 0;
      r10 = 1;
      while (1) {
        r12 = HEAP32[(r10 - 1 << 2 >> 2) + r8] + r7 << 1;
        HEAP32[r5 + (r10 << 2) >> 2] = r12;
        r11 = r10 + 1 | 0;
        if (r11 >>> 0 > r3 >>> 0) {
          break L1336;
        } else {
          r7 = r12;
          r10 = r11;
        }
      }
    }
  } while (0);
  if ((r2 | 0) == 0) {
    _free(r6);
    _free(r9);
    return;
  } else {
    r13 = 0;
  }
  while (1) {
    r3 = HEAP32[r1 + (r13 << 2) >> 2];
    if ((r3 | 0) != 0) {
      r8 = ((r3 << 2) + r5 | 0) >> 2;
      HEAP32[r4 + (r13 << 2) >> 2] = HEAP32[r8];
      HEAP32[r8] = HEAP32[r8] + 1 | 0;
    }
    r8 = r13 + 1 | 0;
    if ((r8 | 0) == (r2 | 0)) {
      break;
    } else {
      r13 = r8;
    }
  }
  _free(r6);
  _free(r9);
  return;
}
function _ZopfliLZ77OptimalFixed(r1, r2, r3, r4, r5) {
  var r6, r7, r8, r9;
  r6 = STACKTOP;
  STACKTOP = STACKTOP + 8 | 0;
  r7 = r6;
  r8 = r6 + 4;
  r9 = _malloc((r4 - r3 << 1) + 2 | 0);
  HEAP32[r7 >> 2] = 0;
  HEAP32[r8 >> 2] = 0;
  if ((r9 | 0) == 0) {
    _exit(-1);
  } else {
    HEAP32[r1 + 8 >> 2] = r3;
    HEAP32[r1 + 12 >> 2] = r4;
    _LZ77OptimalRun(r1, r2, r3, r4, r7, r8, r9, 18, 0, r5);
    _free(r9);
    _free(HEAP32[r7 >> 2]);
    STACKTOP = r6;
    return;
  }
}
function _GetBestLengths(r1, r2, r3, r4, r5, r6, r7) {
  var r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31, r32, r33, r34;
  r8 = STACKTOP;
  STACKTOP = STACKTOP + 564 | 0;
  r9 = r8;
  r10 = r8 + 4;
  r11 = r8 + 8;
  r12 = r8 + 528;
  r13 = r4 - r3 | 0;
  r14 = r3 >>> 0 > 32768 ? r3 - 32768 | 0 : 0;
  r15 = _GetCostModelMinCost(r5, r6);
  if ((r3 | 0) == (r4 | 0)) {
    r16 = 0;
    STACKTOP = r8;
    return r16;
  }
  r17 = r13 + 1 | 0;
  r18 = _malloc(r17 << 2);
  r19 = r18, r20 = r19 >> 2;
  if ((r18 | 0) == 0) {
    _exit(-1);
  }
  _ZopfliInitHash(32768, r12);
  _ZopfliWarmupHash(r2, r14, 0, r12);
  L1359 : do {
    if (r14 >>> 0 < r3 >>> 0) {
      r21 = r14;
      while (1) {
        _ZopfliUpdateHash(r2, r21, r4, r12);
        r22 = r21 + 1 | 0;
        if ((r22 | 0) == (r3 | 0)) {
          break L1359;
        } else {
          r21 = r22;
        }
      }
    }
  } while (0);
  L1363 : do {
    if (r17 >>> 0 > 1) {
      r14 = r4 + 1 - r3 | 0;
      r21 = 1;
      while (1) {
        HEAPF32[(r21 << 2 >> 2) + r20] = 1.0000000150474662e+30;
        r22 = r21 + 1 | 0;
        if ((r22 | 0) == (r14 | 0)) {
          break L1363;
        } else {
          r21 = r22;
        }
      }
    }
  } while (0);
  HEAPF32[r20] = 0;
  HEAP16[r7 >> 1] = 0;
  L1368 : do {
    if (r3 >>> 0 < r4 >>> 0) {
      r17 = r12 + 32 | 0;
      r21 = r3 + 259 | 0;
      r14 = r11 | 0;
      r22 = 258 - r3 | 0;
      r23 = r3;
      while (1) {
        r24 = r23 - r3 | 0;
        _ZopfliUpdateHash(r2, r23, r4, r12);
        r25 = HEAP32[r17 >> 2];
        do {
          if (HEAPU16[r25 + ((r23 & 32767) << 1) >> 1] > 516) {
            if (!(r23 >>> 0 > r21 >>> 0 & (r23 + 517 | 0) >>> 0 < r4 >>> 0)) {
              r26 = r23;
              r27 = r24;
              break;
            }
            if (HEAPU16[r25 + ((r23 + 32510 & 32767) << 1) >> 1] <= 258) {
              r26 = r23;
              r27 = r24;
              break;
            }
            r28 = FUNCTION_TABLE[r5](258, 1, r6);
            r29 = r22 + r23 | 0;
            r30 = r24;
            r31 = 0;
            r32 = r23;
            while (1) {
              r33 = r30 + 258 | 0;
              HEAPF32[(r33 << 2 >> 2) + r20] = r28 + HEAPF32[(r30 << 2 >> 2) + r20];
              HEAP16[r7 + (r33 << 1) >> 1] = 258;
              r33 = r32 + 1 | 0;
              _ZopfliUpdateHash(r2, r33, r4, r12);
              r34 = r31 + 1 | 0;
              if ((r34 | 0) == 258) {
                break;
              } else {
                r30 = r30 + 1 | 0;
                r31 = r34;
                r32 = r33;
              }
            }
            r26 = r23 + 258 | 0;
            r27 = r29;
          } else {
            r26 = r23;
            r27 = r24;
          }
        } while (0);
        _ZopfliFindLongestMatch(r1, r12, r2, r26, r4, 258, r14, r10, r9);
        r24 = r26 + 1 | 0;
        do {
          if (r24 >>> 0 <= r4 >>> 0) {
            r25 = HEAPF32[(r27 << 2 >> 2) + r20] + FUNCTION_TABLE[r5](HEAPU8[r2 + r26 | 0], 0, r6);
            if (r25 < 0) {
              ___assert_func(5244448, 274, 5246788, 5244124);
            }
            r32 = r27 + 1 | 0;
            r31 = (r32 << 2) + r19 | 0;
            if (r25 >= HEAPF32[r31 >> 2]) {
              break;
            }
            HEAPF32[r31 >> 2] = r25;
            HEAP16[r7 + (r32 << 1) >> 1] = 1;
          }
        } while (0);
        L1387 : do {
          if (HEAPU16[r9 >> 1] >= 3) {
            r32 = (r27 << 2) + r19 | 0;
            r25 = HEAPU16[r9 >> 1];
            r31 = 3;
            while (1) {
              if ((r31 + r26 | 0) >>> 0 > r4 >>> 0) {
                break L1387;
              }
              r30 = r31 + r27 | 0;
              r28 = ((r30 << 2) + r19 | 0) >> 2;
              r33 = HEAPF32[r32 >> 2];
              do {
                if (HEAPF32[r28] - r33 > r15) {
                  r34 = r33 + FUNCTION_TABLE[r5](r31, HEAPU16[r11 + (r31 << 1) >> 1], r6);
                  if (r34 < 0) {
                    ___assert_func(5244448, 289, 5246788, 5244124);
                  }
                  if (r34 >= HEAPF32[r28]) {
                    break;
                  }
                  if (r31 >>> 0 >= 259) {
                    ___assert_func(5244448, 291, 5246788, 5243940);
                  }
                  HEAPF32[r28] = r34;
                  HEAP16[r7 + (r30 << 1) >> 1] = r31 & 65535;
                }
              } while (0);
              r30 = r31 + 1 | 0;
              if (r30 >>> 0 > r25 >>> 0) {
                break L1387;
              } else {
                r31 = r30;
              }
            }
          }
        } while (0);
        if (r24 >>> 0 < r4 >>> 0) {
          r23 = r24;
        } else {
          break L1368;
        }
      }
    }
  } while (0);
  r4 = (r13 << 2) + r19 | 0;
  if (HEAPF32[r4 >> 2] < 0) {
    ___assert_func(5244448, 298, 5246788, 5245836);
  }
  r19 = HEAPF32[r4 >> 2];
  _ZopfliCleanHash(r12);
  _free(r18);
  r16 = r19;
  STACKTOP = r8;
  return r16;
}
function _get_output_buffer() {
  return HEAP32[1310721];
}
function _get_output_buffer_size() {
  return HEAP32[1310720];
}
function _ZopfliGetLengthExtraBits(r1) {
  return HEAP32[(r1 << 2) + 5248088 >> 2];
}
function _ZopfliGetLengthExtraBitsValue(r1) {
  return HEAP32[(r1 << 2) + 5249124 >> 2];
}
function _ZopfliGetLengthSymbol(r1) {
  return HEAP32[(r1 << 2) + 5247052 >> 2];
}
function _ZopfliInitOptions(r1) {
  var r2;
  r2 = r1 >> 2;
  HEAP32[r2] = 0;
  HEAP32[r2 + 1] = 15;
  HEAP32[r2 + 2] = 1;
  HEAP32[r2 + 3] = 0;
  HEAP32[r2 + 4] = 15;
  return;
}
function _adler32(r1, r2) {
  var r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21, r22;
  if ((r2 | 0) == 0) {
    r3 = 1;
    r4 = 0;
    r5 = r4 | r3;
    return r5;
  } else {
    r6 = r1;
    r7 = r2;
    r8 = 1;
    r9 = 0;
  }
  while (1) {
    r2 = r7 >>> 0 > 5550 ? 5550 : r7;
    r1 = r7 - r2 | 0;
    if ((r2 | 0) == 0) {
      r10 = r6;
      r11 = r8;
      r12 = r9;
    } else {
      r13 = r7 >>> 0 < 5550;
      r14 = r6;
      r15 = r8;
      r16 = r9;
      r17 = r2;
      while (1) {
        r18 = HEAPU8[r14] + r15 | 0;
        r19 = r18 + r16 | 0;
        r20 = r17 - 1 | 0;
        if ((r20 | 0) == 0) {
          break;
        } else {
          r14 = r14 + 1 | 0;
          r15 = r18;
          r16 = r19;
          r17 = r20;
        }
      }
      r10 = r6 + (r13 ? r7 : 5550) | 0;
      r11 = r18;
      r12 = r19;
    }
    r21 = (r11 >>> 0) % 65521;
    r22 = (r12 >>> 0) % 65521;
    if ((r7 | 0) == (r2 | 0)) {
      break;
    } else {
      r6 = r10;
      r7 = r1;
      r8 = r21;
      r9 = r22;
    }
  }
  r3 = r21;
  r4 = r22 << 16;
  r5 = r4 | r3;
  return r5;
}
function _ZopfliCalculateEntropy(r1, r2, r3) {
  var r4, r5, r6, r7, r8, r9, r10;
  r4 = 0;
  do {
    if ((r2 | 0) == 0) {
      r4 = 1053;
    } else {
      r5 = 0;
      r6 = 0;
      while (1) {
        r7 = HEAP32[r1 + (r5 << 2) >> 2] + r6 | 0;
        r8 = r5 + 1 | 0;
        if ((r8 | 0) == (r2 | 0)) {
          break;
        } else {
          r5 = r8;
          r6 = r7;
        }
      }
      if ((r7 | 0) == 0) {
        r4 = 1053;
        break;
      }
      r9 = Math.log(r7 >>> 0);
      break;
    }
  } while (0);
  if (r4 == 1053) {
    r9 = Math.log(r2 >>> 0);
  }
  r4 = r9 * 1.4426950408889;
  if ((r2 | 0) == 0) {
    return;
  } else {
    r10 = 0;
  }
  while (1) {
    r9 = HEAP32[r1 + (r10 << 2) >> 2];
    if ((r9 | 0) == 0) {
      r7 = (r10 << 3) + r3 | 0;
      HEAPF64[tempDoublePtr >> 3] = r4, HEAP32[r7 >> 2] = HEAP32[tempDoublePtr >> 2], HEAP32[r7 + 4 >> 2] = HEAP32[tempDoublePtr + 4 >> 2];
    } else {
      r7 = r4 - Math.log(r9 >>> 0) * 1.4426950408889;
      r9 = (r10 << 3) + r3 | 0;
      HEAPF64[tempDoublePtr >> 3] = r7, HEAP32[r9 >> 2] = HEAP32[tempDoublePtr >> 2], HEAP32[r9 + 4 >> 2] = HEAP32[tempDoublePtr + 4 >> 2];
    }
    r9 = ((r10 << 3) + r3 | 0) >> 2;
    r7 = (HEAP32[tempDoublePtr >> 2] = HEAP32[r9], HEAP32[tempDoublePtr + 4 >> 2] = HEAP32[r9 + 1], HEAPF64[tempDoublePtr >> 3]);
    do {
      if (r7 < 0 & r7 > -1e-5) {
        HEAPF64[tempDoublePtr >> 3] = 0, HEAP32[r9] = HEAP32[tempDoublePtr >> 2], HEAP32[r9 + 1] = HEAP32[tempDoublePtr + 4 >> 2];
      } else {
        if (r7 >= 0) {
          break;
        }
        ___assert_func(5244244, 92, 5246552, 5245044);
      }
    } while (0);
    r7 = r10 + 1 | 0;
    if ((r7 | 0) == (r2 | 0)) {
      break;
    } else {
      r10 = r7;
    }
  }
  return;
}
function _ZopfliCalculateBitLengths(r1, r2, r3, r4) {
  if ((_ZopfliLengthLimitedCodeLengths(r1, r2, r3, r4) | 0) == 0) {
    return;
  }
  ___assert_func(5244244, 100, 5246604, 5244724);
  return;
}
function _ZopfliGetDistExtraBits(r1) {
  var r2;
  if ((r1 | 0) < 5) {
    r2 = 0;
    return r2;
  }
  r2 = (_llvm_ctlz_i32(r1 - 1 | 0, 0) ^ 31) - 1 | 0;
  return r2;
}
function _ZopfliGetDistExtraBitsValue(r1) {
  var r2, r3;
  if ((r1 | 0) < 5) {
    r2 = 0;
    return r2;
  }
  r3 = _llvm_ctlz_i32(r1 - 1 | 0, 0) ^ 31;
  r2 = (1 << r3 - 1) - 1 & (-1 << r3) + (r1 - 1);
  return r2;
}
function _ZopfliGetDistSymbol(r1) {
  var r2, r3;
  r2 = r1 - 1 | 0;
  if ((r1 | 0) < 5) {
    r3 = r2;
    return r3;
  }
  r1 = _llvm_ctlz_i32(r2, 0) ^ 31;
  r3 = r2 >>> ((r1 - 1 | 0) >>> 0) & 1 | r1 << 1;
  return r3;
}
function _ZopfliZlibCompress(r1, r2, r3, r4, r5) {
  var r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17;
  r6 = r5 >> 2;
  r7 = r4 >> 2;
  r8 = STACKTOP;
  STACKTOP = STACKTOP + 4 | 0;
  r9 = r8;
  HEAP8[r9] = 0;
  r10 = _adler32(r2, r3);
  r11 = HEAP32[r6];
  if ((r11 - 1 & r11 | 0) == 0) {
    if ((r11 | 0) == 0) {
      r12 = _malloc(1);
    } else {
      r12 = _realloc(HEAP32[r7], r11 << 1);
    }
    HEAP32[r7] = r12;
  }
  HEAP8[HEAP32[r7] + HEAP32[r6] | 0] = 120;
  r12 = HEAP32[r6];
  r11 = r12 + 1 | 0;
  HEAP32[r6] = r11;
  if ((r11 & r12 | 0) == 0) {
    if ((r11 | 0) == 0) {
      r13 = _malloc(1);
    } else {
      r13 = _realloc(HEAP32[r7], r11 << 1);
    }
    HEAP32[r7] = r13;
  }
  HEAP8[HEAP32[r7] + HEAP32[r6] | 0] = 1;
  HEAP32[r6] = HEAP32[r6] + 1 | 0;
  _ZopfliDeflate(r1, 2, 1, r2, r3, r9, r4, r5);
  r5 = HEAP32[r6];
  if ((r5 - 1 & r5 | 0) == 0) {
    if ((r5 | 0) == 0) {
      r14 = _malloc(1);
    } else {
      r14 = _realloc(HEAP32[r7], r5 << 1);
    }
    HEAP32[r7] = r14;
  }
  HEAP8[HEAP32[r7] + HEAP32[r6] | 0] = r10 >>> 24 & 255;
  r14 = HEAP32[r6];
  r5 = r14 + 1 | 0;
  HEAP32[r6] = r5;
  if ((r5 & r14 | 0) == 0) {
    if ((r5 | 0) == 0) {
      r15 = _malloc(1);
    } else {
      r15 = _realloc(HEAP32[r7], r5 << 1);
    }
    HEAP32[r7] = r15;
  }
  HEAP8[HEAP32[r7] + HEAP32[r6] | 0] = r10 >>> 16 & 255;
  r15 = HEAP32[r6];
  r5 = r15 + 1 | 0;
  HEAP32[r6] = r5;
  if ((r5 & r15 | 0) == 0) {
    if ((r5 | 0) == 0) {
      r16 = _malloc(1);
    } else {
      r16 = _realloc(HEAP32[r7], r5 << 1);
    }
    HEAP32[r7] = r16;
  }
  HEAP8[HEAP32[r7] + HEAP32[r6] | 0] = r10 >>> 8 & 255;
  r16 = HEAP32[r6];
  r5 = r16 + 1 | 0;
  HEAP32[r6] = r5;
  if ((r5 & r16 | 0) == 0) {
    if ((r5 | 0) == 0) {
      r17 = _malloc(1);
    } else {
      r17 = _realloc(HEAP32[r7], r5 << 1);
    }
    HEAP32[r7] = r17;
  }
  HEAP8[HEAP32[r7] + HEAP32[r6] | 0] = r10 & 255;
  r10 = HEAP32[r6] + 1 | 0;
  HEAP32[r6] = r10;
  if ((HEAP32[r1 >> 2] | 0) == 0) {
    STACKTOP = r8;
    return;
  }
  _fprintf(HEAP32[_stderr >> 2], 5244024, (tempInt = STACKTOP, STACKTOP = STACKTOP + 16 | 0, HEAP32[tempInt >> 2] = r3, HEAP32[tempInt + 4 >> 2] = r10, HEAPF64[tempDoublePtr >> 3] = ((r3 - r10 | 0) >>> 0) * 100 / (r3 >>> 0), HEAP32[tempInt + 8 >> 2] = HEAP32[tempDoublePtr >> 2], HEAP32[tempInt + 12 >> 2] = HEAP32[tempDoublePtr + 4 >> 2], tempInt));
  STACKTOP = r8;
  return;
}
function _create_options(r1, r2) {
  var r3, r4;
  r3 = STACKTOP;
  STACKTOP = STACKTOP + 20 | 0;
  r4 = r3;
  _ZopfliInitOptions(r4);
  HEAP32[r4 + 4 >> 2] = r2;
  r2 = r1 >> 2;
  r1 = r4 >> 2;
  HEAP32[r2] = HEAP32[r1];
  HEAP32[r2 + 1] = HEAP32[r1 + 1];
  HEAP32[r2 + 2] = HEAP32[r1 + 2];
  HEAP32[r2 + 3] = HEAP32[r1 + 3];
  HEAP32[r2 + 4] = HEAP32[r1 + 4];
  STACKTOP = r3;
  return;
}
function _compress_deflate(r1, r2) {
  var r3, r4, r5, r6, r7;
  r3 = STACKTOP;
  STACKTOP = STACKTOP + 24 | 0;
  r4 = r3;
  r5 = r3 + 20;
  HEAP8[r5] = 0;
  r6 = _fopen(5244016, 5245196);
  r7 = _malloc(r1);
  _fread(r7, 1, r1, r6);
  _create_options(r4, r2);
  _ZopfliDeflate(r4, 2, 1, r7, r1, r5, 5242884, 5242880);
  STACKTOP = r3;
  return;
}
function _compress_zlib(r1, r2) {
  var r3, r4, r5, r6;
  r3 = STACKTOP;
  STACKTOP = STACKTOP + 20 | 0;
  r4 = r3;
  r5 = _fopen(5244016, 5245196);
  r6 = _malloc(r1);
  _fread(r6, 1, r1, r5);
  _create_options(r4, r2);
  _ZopfliZlibCompress(r4, r6, r1, 5242884, 5242880);
  STACKTOP = r3;
  return;
}
function _compress_gzip(r1, r2) {
  var r3, r4, r5, r6;
  r3 = STACKTOP;
  STACKTOP = STACKTOP + 20 | 0;
  r4 = r3;
  r5 = _fopen(5244016, 5245196);
  r6 = _malloc(r1);
  _fread(r6, 1, r1, r5);
  _create_options(r4, r2);
  _ZopfliGzipCompress(r4, r6, r1, 5242884, 5242880);
  STACKTOP = r3;
  return;
}
function _malloc(r1) {
  var r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18;
  do {
    if (r1 >>> 0 < 245) {
      if (r1 >>> 0 < 11) {
        r2 = 16;
      } else {
        r2 = r1 + 11 & -8;
      }
      r3 = r2 >>> 3;
      r4 = HEAP32[1311493];
      r5 = r4 >>> (r3 >>> 0);
      if ((r5 & 3 | 0) != 0) {
        r6 = (r5 & 1 ^ 1) + r3 | 0;
        r7 = r6 << 1;
        r8 = (r7 << 2) + 5246012 | 0;
        r9 = (r7 + 2 << 2) + 5246012 | 0;
        r7 = HEAP32[r9 >> 2];
        r10 = r7 + 8 | 0;
        r11 = HEAP32[r10 >> 2];
        do {
          if ((r8 | 0) == (r11 | 0)) {
            HEAP32[1311493] = r4 & (1 << r6 ^ -1);
          } else {
            if (r11 >>> 0 < HEAP32[1311497] >>> 0) {
              _abort();
            }
            r12 = r11 + 12 | 0;
            if ((HEAP32[r12 >> 2] | 0) == (r7 | 0)) {
              HEAP32[r12 >> 2] = r8;
              HEAP32[r9 >> 2] = r11;
              break;
            } else {
              _abort();
            }
          }
        } while (0);
        r11 = r6 << 3;
        HEAP32[r7 + 4 >> 2] = r11 | 3;
        r9 = r7 + (r11 | 4) | 0;
        HEAP32[r9 >> 2] = HEAP32[r9 >> 2] | 1;
        r13 = r10;
        return r13;
      }
      if (r2 >>> 0 <= HEAP32[1311495] >>> 0) {
        r14 = r2;
        break;
      }
      if ((r5 | 0) == 0) {
        if ((HEAP32[1311494] | 0) == 0) {
          r14 = r2;
          break;
        }
        r9 = _tmalloc_small(r2);
        if ((r9 | 0) == 0) {
          r14 = r2;
          break;
        } else {
          r13 = r9;
        }
        return r13;
      }
      r9 = 2 << r3;
      r11 = r5 << r3 & (r9 | -r9);
      r9 = (r11 & -r11) - 1 | 0;
      r11 = r9 >>> 12 & 16;
      r8 = r9 >>> (r11 >>> 0);
      r9 = r8 >>> 5 & 8;
      r12 = r8 >>> (r9 >>> 0);
      r8 = r12 >>> 2 & 4;
      r15 = r12 >>> (r8 >>> 0);
      r12 = r15 >>> 1 & 2;
      r16 = r15 >>> (r12 >>> 0);
      r15 = r16 >>> 1 & 1;
      r17 = (r9 | r11 | r8 | r12 | r15) + (r16 >>> (r15 >>> 0)) | 0;
      r15 = r17 << 1;
      r16 = (r15 << 2) + 5246012 | 0;
      r12 = (r15 + 2 << 2) + 5246012 | 0;
      r15 = HEAP32[r12 >> 2];
      r8 = r15 + 8 | 0;
      r11 = HEAP32[r8 >> 2];
      do {
        if ((r16 | 0) == (r11 | 0)) {
          HEAP32[1311493] = r4 & (1 << r17 ^ -1);
        } else {
          if (r11 >>> 0 < HEAP32[1311497] >>> 0) {
            _abort();
          }
          r9 = r11 + 12 | 0;
          if ((HEAP32[r9 >> 2] | 0) == (r15 | 0)) {
            HEAP32[r9 >> 2] = r16;
            HEAP32[r12 >> 2] = r11;
            break;
          } else {
            _abort();
          }
        }
      } while (0);
      r11 = r17 << 3;
      r12 = r11 - r2 | 0;
      HEAP32[r15 + 4 >> 2] = r2 | 3;
      r16 = r15;
      r4 = r16 + r2 | 0;
      HEAP32[r16 + (r2 | 4) >> 2] = r12 | 1;
      HEAP32[r16 + r11 >> 2] = r12;
      r11 = HEAP32[1311495];
      if ((r11 | 0) != 0) {
        r16 = HEAP32[1311498];
        r3 = r11 >>> 3;
        r11 = r3 << 1;
        r5 = (r11 << 2) + 5246012 | 0;
        r10 = HEAP32[1311493];
        r7 = 1 << r3;
        do {
          if ((r10 & r7 | 0) == 0) {
            HEAP32[1311493] = r10 | r7;
            r18 = r5;
          } else {
            r3 = HEAP32[(r11 + 2 << 2) + 5246012 >> 2];
            if (r3 >>> 0 >= HEAP32[1311497] >>> 0) {
              r18 = r3;
              break;
            }
            _abort();
          }
        } while (0);
        HEAP32[(r11 + 2 << 2) + 5246012 >> 2] = r16;
        HEAP32[r18 + 12 >> 2] = r16;
        HEAP32[r16 + 8 >> 2] = r18;
        HEAP32[r16 + 12 >> 2] = r5;
      }
      HEAP32[1311495] = r12;
      HEAP32[1311498] = r4;
      r13 = r8;
      return r13;
    } else {
      if (r1 >>> 0 > 4294967231) {
        r14 = -1;
        break;
      }
      r7 = r1 + 11 & -8;
      if ((HEAP32[1311494] | 0) == 0) {
        r14 = r7;
        break;
      }
      r10 = _tmalloc_large(r7);
      if ((r10 | 0) == 0) {
        r14 = r7;
        break;
      } else {
        r13 = r10;
      }
      return r13;
    }
  } while (0);
  r1 = HEAP32[1311495];
  if (r14 >>> 0 > r1 >>> 0) {
    r18 = HEAP32[1311496];
    if (r14 >>> 0 < r18 >>> 0) {
      r2 = r18 - r14 | 0;
      HEAP32[1311496] = r2;
      r18 = HEAP32[1311499];
      r10 = r18;
      HEAP32[1311499] = r10 + r14 | 0;
      HEAP32[r14 + (r10 + 4) >> 2] = r2 | 1;
      HEAP32[r18 + 4 >> 2] = r14 | 3;
      r13 = r18 + 8 | 0;
      return r13;
    } else {
      r13 = _sys_alloc(r14);
      return r13;
    }
  } else {
    r18 = r1 - r14 | 0;
    r2 = HEAP32[1311498];
    if (r18 >>> 0 > 15) {
      r10 = r2;
      HEAP32[1311498] = r10 + r14 | 0;
      HEAP32[1311495] = r18;
      HEAP32[r14 + (r10 + 4) >> 2] = r18 | 1;
      HEAP32[r10 + r1 >> 2] = r18;
      HEAP32[r2 + 4 >> 2] = r14 | 3;
    } else {
      HEAP32[1311495] = 0;
      HEAP32[1311498] = 0;
      HEAP32[r2 + 4 >> 2] = r1 | 3;
      r14 = r1 + (r2 + 4) | 0;
      HEAP32[r14 >> 2] = HEAP32[r14 >> 2] | 1;
    }
    r13 = r2 + 8 | 0;
    return r13;
  }
}
function _tmalloc_small(r1) {
  var r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21;
  r2 = HEAP32[1311494];
  r3 = (r2 & -r2) - 1 | 0;
  r2 = r3 >>> 12 & 16;
  r4 = r3 >>> (r2 >>> 0);
  r3 = r4 >>> 5 & 8;
  r5 = r4 >>> (r3 >>> 0);
  r4 = r5 >>> 2 & 4;
  r6 = r5 >>> (r4 >>> 0);
  r5 = r6 >>> 1 & 2;
  r7 = r6 >>> (r5 >>> 0);
  r6 = r7 >>> 1 & 1;
  r8 = HEAP32[((r3 | r2 | r4 | r5 | r6) + (r7 >>> (r6 >>> 0)) << 2) + 5246276 >> 2];
  r6 = r8;
  r7 = r8, r5 = r7 >> 2;
  r4 = (HEAP32[r8 + 4 >> 2] & -8) - r1 | 0;
  while (1) {
    r8 = HEAP32[r6 + 16 >> 2];
    if ((r8 | 0) == 0) {
      r2 = HEAP32[r6 + 20 >> 2];
      if ((r2 | 0) == 0) {
        break;
      } else {
        r9 = r2;
      }
    } else {
      r9 = r8;
    }
    r8 = (HEAP32[r9 + 4 >> 2] & -8) - r1 | 0;
    r2 = r8 >>> 0 < r4 >>> 0;
    r6 = r9;
    r7 = r2 ? r9 : r7, r5 = r7 >> 2;
    r4 = r2 ? r8 : r4;
  }
  r9 = r7;
  r6 = HEAP32[1311497];
  if (r9 >>> 0 < r6 >>> 0) {
    _abort();
  }
  r8 = r9 + r1 | 0;
  r2 = r8;
  if (r9 >>> 0 >= r8 >>> 0) {
    _abort();
  }
  r8 = HEAP32[r5 + 6];
  r3 = HEAP32[r5 + 3];
  L1597 : do {
    if ((r3 | 0) == (r7 | 0)) {
      r10 = r7 + 20 | 0;
      r11 = HEAP32[r10 >> 2];
      do {
        if ((r11 | 0) == 0) {
          r12 = r7 + 16 | 0;
          r13 = HEAP32[r12 >> 2];
          if ((r13 | 0) == 0) {
            r14 = 0, r15 = r14 >> 2;
            break L1597;
          } else {
            r16 = r13;
            r17 = r12;
            break;
          }
        } else {
          r16 = r11;
          r17 = r10;
        }
      } while (0);
      while (1) {
        r10 = r16 + 20 | 0;
        if ((HEAP32[r10 >> 2] | 0) == 0) {
          r11 = r16 + 16 | 0;
          if ((HEAP32[r11 >> 2] | 0) == 0) {
            break;
          } else {
            r18 = r11;
          }
        } else {
          r18 = r10;
        }
        r16 = HEAP32[r18 >> 2];
        r17 = r18;
      }
      if (r17 >>> 0 < HEAP32[1311497] >>> 0) {
        _abort();
      } else {
        HEAP32[r17 >> 2] = 0;
        r14 = r16, r15 = r14 >> 2;
        break;
      }
    } else {
      r10 = HEAP32[r5 + 2];
      if (r10 >>> 0 < r6 >>> 0) {
        _abort();
      }
      r11 = r10 + 12 | 0;
      if ((HEAP32[r11 >> 2] | 0) != (r7 | 0)) {
        _abort();
      }
      r12 = r3 + 8 | 0;
      if ((HEAP32[r12 >> 2] | 0) == (r7 | 0)) {
        HEAP32[r11 >> 2] = r3;
        HEAP32[r12 >> 2] = r10;
        r14 = r3, r15 = r14 >> 2;
        break;
      } else {
        _abort();
      }
    }
  } while (0);
  L1621 : do {
    if ((r8 | 0) != 0) {
      r3 = r7 + 28 | 0;
      r6 = (HEAP32[r3 >> 2] << 2) + 5246276 | 0;
      do {
        if ((r7 | 0) == (HEAP32[r6 >> 2] | 0)) {
          HEAP32[r6 >> 2] = r14;
          if ((r14 | 0) != 0) {
            break;
          }
          HEAP32[1311494] = HEAP32[1311494] & (1 << HEAP32[r3 >> 2] ^ -1);
          break L1621;
        } else {
          if (r8 >>> 0 < HEAP32[1311497] >>> 0) {
            _abort();
          }
          r16 = r8 + 16 | 0;
          if ((HEAP32[r16 >> 2] | 0) == (r7 | 0)) {
            HEAP32[r16 >> 2] = r14;
          } else {
            HEAP32[r8 + 20 >> 2] = r14;
          }
          if ((r14 | 0) == 0) {
            break L1621;
          }
        }
      } while (0);
      if (r14 >>> 0 < HEAP32[1311497] >>> 0) {
        _abort();
      }
      HEAP32[r15 + 6] = r8;
      r3 = HEAP32[r5 + 4];
      do {
        if ((r3 | 0) != 0) {
          if (r3 >>> 0 < HEAP32[1311497] >>> 0) {
            _abort();
          } else {
            HEAP32[r15 + 4] = r3;
            HEAP32[r3 + 24 >> 2] = r14;
            break;
          }
        }
      } while (0);
      r3 = HEAP32[r5 + 5];
      if ((r3 | 0) == 0) {
        break;
      }
      if (r3 >>> 0 < HEAP32[1311497] >>> 0) {
        _abort();
      } else {
        HEAP32[r15 + 5] = r3;
        HEAP32[r3 + 24 >> 2] = r14;
        break;
      }
    }
  } while (0);
  if (r4 >>> 0 < 16) {
    r14 = r4 + r1 | 0;
    HEAP32[r5 + 1] = r14 | 3;
    r15 = r14 + (r9 + 4) | 0;
    HEAP32[r15 >> 2] = HEAP32[r15 >> 2] | 1;
    r19 = r7 + 8 | 0;
    r20 = r19;
    return r20;
  }
  HEAP32[r5 + 1] = r1 | 3;
  HEAP32[r1 + (r9 + 4) >> 2] = r4 | 1;
  HEAP32[r9 + r4 + r1 >> 2] = r4;
  r1 = HEAP32[1311495];
  if ((r1 | 0) != 0) {
    r9 = HEAP32[1311498];
    r5 = r1 >>> 3;
    r1 = r5 << 1;
    r15 = (r1 << 2) + 5246012 | 0;
    r14 = HEAP32[1311493];
    r8 = 1 << r5;
    do {
      if ((r14 & r8 | 0) == 0) {
        HEAP32[1311493] = r14 | r8;
        r21 = r15;
      } else {
        r5 = HEAP32[(r1 + 2 << 2) + 5246012 >> 2];
        if (r5 >>> 0 >= HEAP32[1311497] >>> 0) {
          r21 = r5;
          break;
        }
        _abort();
      }
    } while (0);
    HEAP32[(r1 + 2 << 2) + 5246012 >> 2] = r9;
    HEAP32[r21 + 12 >> 2] = r9;
    HEAP32[r9 + 8 >> 2] = r21;
    HEAP32[r9 + 12 >> 2] = r15;
  }
  HEAP32[1311495] = r4;
  HEAP32[1311498] = r2;
  r19 = r7 + 8 | 0;
  r20 = r19;
  return r20;
}
function _tmalloc_large(r1) {
  var r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31, r32, r33, r34, r35;
  r2 = r1 >> 2;
  r3 = 0;
  r4 = -r1 | 0;
  r5 = r1 >>> 8;
  do {
    if ((r5 | 0) == 0) {
      r6 = 0;
    } else {
      if (r1 >>> 0 > 16777215) {
        r6 = 31;
        break;
      }
      r7 = (r5 + 1048320 | 0) >>> 16 & 8;
      r8 = r5 << r7;
      r9 = (r8 + 520192 | 0) >>> 16 & 4;
      r10 = r8 << r9;
      r8 = (r10 + 245760 | 0) >>> 16 & 2;
      r11 = 14 - (r9 | r7 | r8) + (r10 << r8 >>> 15) | 0;
      r6 = r1 >>> ((r11 + 7 | 0) >>> 0) & 1 | r11 << 1;
    }
  } while (0);
  r5 = HEAP32[(r6 << 2) + 5246276 >> 2];
  L1667 : do {
    if ((r5 | 0) == 0) {
      r12 = 0;
      r13 = r4;
      r14 = 0;
    } else {
      if ((r6 | 0) == 31) {
        r15 = 0;
      } else {
        r15 = 25 - (r6 >>> 1) | 0;
      }
      r11 = 0;
      r8 = r4;
      r10 = r5, r7 = r10 >> 2;
      r9 = r1 << r15;
      r16 = 0;
      while (1) {
        r17 = HEAP32[r7 + 1] & -8;
        r18 = r17 - r1 | 0;
        if (r18 >>> 0 < r8 >>> 0) {
          if ((r17 | 0) == (r1 | 0)) {
            r12 = r10;
            r13 = r18;
            r14 = r10;
            break L1667;
          } else {
            r19 = r10;
            r20 = r18;
          }
        } else {
          r19 = r11;
          r20 = r8;
        }
        r18 = HEAP32[r7 + 5];
        r17 = HEAP32[((r9 >>> 31 << 2) + 16 >> 2) + r7];
        r21 = (r18 | 0) == 0 | (r18 | 0) == (r17 | 0) ? r16 : r18;
        if ((r17 | 0) == 0) {
          r12 = r19;
          r13 = r20;
          r14 = r21;
          break L1667;
        } else {
          r11 = r19;
          r8 = r20;
          r10 = r17, r7 = r10 >> 2;
          r9 = r9 << 1;
          r16 = r21;
        }
      }
    }
  } while (0);
  do {
    if ((r14 | 0) == 0 & (r12 | 0) == 0) {
      r20 = 2 << r6;
      r19 = HEAP32[1311494] & (r20 | -r20);
      if ((r19 | 0) == 0) {
        r22 = r14;
        break;
      }
      r20 = (r19 & -r19) - 1 | 0;
      r19 = r20 >>> 12 & 16;
      r15 = r20 >>> (r19 >>> 0);
      r20 = r15 >>> 5 & 8;
      r5 = r15 >>> (r20 >>> 0);
      r15 = r5 >>> 2 & 4;
      r4 = r5 >>> (r15 >>> 0);
      r5 = r4 >>> 1 & 2;
      r16 = r4 >>> (r5 >>> 0);
      r4 = r16 >>> 1 & 1;
      r22 = HEAP32[((r20 | r19 | r15 | r5 | r4) + (r16 >>> (r4 >>> 0)) << 2) + 5246276 >> 2];
    } else {
      r22 = r14;
    }
  } while (0);
  L1682 : do {
    if ((r22 | 0) == 0) {
      r23 = r13;
      r24 = r12, r25 = r24 >> 2;
    } else {
      r14 = r22, r6 = r14 >> 2;
      r4 = r13;
      r16 = r12;
      while (1) {
        r5 = (HEAP32[r6 + 1] & -8) - r1 | 0;
        r15 = r5 >>> 0 < r4 >>> 0;
        r19 = r15 ? r5 : r4;
        r5 = r15 ? r14 : r16;
        r15 = HEAP32[r6 + 4];
        if ((r15 | 0) != 0) {
          r14 = r15, r6 = r14 >> 2;
          r4 = r19;
          r16 = r5;
          continue;
        }
        r15 = HEAP32[r6 + 5];
        if ((r15 | 0) == 0) {
          r23 = r19;
          r24 = r5, r25 = r24 >> 2;
          break L1682;
        } else {
          r14 = r15, r6 = r14 >> 2;
          r4 = r19;
          r16 = r5;
        }
      }
    }
  } while (0);
  if ((r24 | 0) == 0) {
    r26 = 0;
    return r26;
  }
  if (r23 >>> 0 >= (HEAP32[1311495] - r1 | 0) >>> 0) {
    r26 = 0;
    return r26;
  }
  r12 = r24, r13 = r12 >> 2;
  r22 = HEAP32[1311497];
  if (r12 >>> 0 < r22 >>> 0) {
    _abort();
  }
  r16 = r12 + r1 | 0;
  r4 = r16;
  if (r12 >>> 0 >= r16 >>> 0) {
    _abort();
  }
  r14 = HEAP32[r25 + 6];
  r6 = HEAP32[r25 + 3];
  L1699 : do {
    if ((r6 | 0) == (r24 | 0)) {
      r5 = r24 + 20 | 0;
      r19 = HEAP32[r5 >> 2];
      do {
        if ((r19 | 0) == 0) {
          r15 = r24 + 16 | 0;
          r20 = HEAP32[r15 >> 2];
          if ((r20 | 0) == 0) {
            r27 = 0, r28 = r27 >> 2;
            break L1699;
          } else {
            r29 = r20;
            r30 = r15;
            break;
          }
        } else {
          r29 = r19;
          r30 = r5;
        }
      } while (0);
      while (1) {
        r5 = r29 + 20 | 0;
        if ((HEAP32[r5 >> 2] | 0) == 0) {
          r19 = r29 + 16 | 0;
          if ((HEAP32[r19 >> 2] | 0) == 0) {
            break;
          } else {
            r31 = r19;
          }
        } else {
          r31 = r5;
        }
        r29 = HEAP32[r31 >> 2];
        r30 = r31;
      }
      if (r30 >>> 0 < HEAP32[1311497] >>> 0) {
        _abort();
      } else {
        HEAP32[r30 >> 2] = 0;
        r27 = r29, r28 = r27 >> 2;
        break;
      }
    } else {
      r5 = HEAP32[r25 + 2];
      if (r5 >>> 0 < r22 >>> 0) {
        _abort();
      }
      r19 = r5 + 12 | 0;
      if ((HEAP32[r19 >> 2] | 0) != (r24 | 0)) {
        _abort();
      }
      r15 = r6 + 8 | 0;
      if ((HEAP32[r15 >> 2] | 0) == (r24 | 0)) {
        HEAP32[r19 >> 2] = r6;
        HEAP32[r15 >> 2] = r5;
        r27 = r6, r28 = r27 >> 2;
        break;
      } else {
        _abort();
      }
    }
  } while (0);
  L1723 : do {
    if ((r14 | 0) != 0) {
      r6 = r24 + 28 | 0;
      r22 = (HEAP32[r6 >> 2] << 2) + 5246276 | 0;
      do {
        if ((r24 | 0) == (HEAP32[r22 >> 2] | 0)) {
          HEAP32[r22 >> 2] = r27;
          if ((r27 | 0) != 0) {
            break;
          }
          HEAP32[1311494] = HEAP32[1311494] & (1 << HEAP32[r6 >> 2] ^ -1);
          break L1723;
        } else {
          if (r14 >>> 0 < HEAP32[1311497] >>> 0) {
            _abort();
          }
          r29 = r14 + 16 | 0;
          if ((HEAP32[r29 >> 2] | 0) == (r24 | 0)) {
            HEAP32[r29 >> 2] = r27;
          } else {
            HEAP32[r14 + 20 >> 2] = r27;
          }
          if ((r27 | 0) == 0) {
            break L1723;
          }
        }
      } while (0);
      if (r27 >>> 0 < HEAP32[1311497] >>> 0) {
        _abort();
      }
      HEAP32[r28 + 6] = r14;
      r6 = HEAP32[r25 + 4];
      do {
        if ((r6 | 0) != 0) {
          if (r6 >>> 0 < HEAP32[1311497] >>> 0) {
            _abort();
          } else {
            HEAP32[r28 + 4] = r6;
            HEAP32[r6 + 24 >> 2] = r27;
            break;
          }
        }
      } while (0);
      r6 = HEAP32[r25 + 5];
      if ((r6 | 0) == 0) {
        break;
      }
      if (r6 >>> 0 < HEAP32[1311497] >>> 0) {
        _abort();
      } else {
        HEAP32[r28 + 5] = r6;
        HEAP32[r6 + 24 >> 2] = r27;
        break;
      }
    }
  } while (0);
  do {
    if (r23 >>> 0 < 16) {
      r27 = r23 + r1 | 0;
      HEAP32[r25 + 1] = r27 | 3;
      r28 = r27 + (r12 + 4) | 0;
      HEAP32[r28 >> 2] = HEAP32[r28 >> 2] | 1;
    } else {
      HEAP32[r25 + 1] = r1 | 3;
      HEAP32[r2 + (r13 + 1)] = r23 | 1;
      HEAP32[(r23 >> 2) + r13 + r2] = r23;
      r28 = r23 >>> 3;
      if (r23 >>> 0 < 256) {
        r27 = r28 << 1;
        r14 = (r27 << 2) + 5246012 | 0;
        r6 = HEAP32[1311493];
        r22 = 1 << r28;
        do {
          if ((r6 & r22 | 0) == 0) {
            HEAP32[1311493] = r6 | r22;
            r32 = r14;
          } else {
            r28 = HEAP32[(r27 + 2 << 2) + 5246012 >> 2];
            if (r28 >>> 0 >= HEAP32[1311497] >>> 0) {
              r32 = r28;
              break;
            }
            _abort();
          }
        } while (0);
        HEAP32[(r27 + 2 << 2) + 5246012 >> 2] = r4;
        HEAP32[r32 + 12 >> 2] = r4;
        HEAP32[r2 + (r13 + 2)] = r32;
        HEAP32[r2 + (r13 + 3)] = r14;
        break;
      }
      r22 = r16;
      r6 = r23 >>> 8;
      do {
        if ((r6 | 0) == 0) {
          r33 = 0;
        } else {
          if (r23 >>> 0 > 16777215) {
            r33 = 31;
            break;
          }
          r28 = (r6 + 1048320 | 0) >>> 16 & 8;
          r29 = r6 << r28;
          r30 = (r29 + 520192 | 0) >>> 16 & 4;
          r31 = r29 << r30;
          r29 = (r31 + 245760 | 0) >>> 16 & 2;
          r5 = 14 - (r30 | r28 | r29) + (r31 << r29 >>> 15) | 0;
          r33 = r23 >>> ((r5 + 7 | 0) >>> 0) & 1 | r5 << 1;
        }
      } while (0);
      r6 = (r33 << 2) + 5246276 | 0;
      HEAP32[r2 + (r13 + 7)] = r33;
      HEAP32[r2 + (r13 + 5)] = 0;
      HEAP32[r2 + (r13 + 4)] = 0;
      r14 = HEAP32[1311494];
      r27 = 1 << r33;
      if ((r14 & r27 | 0) == 0) {
        HEAP32[1311494] = r14 | r27;
        HEAP32[r6 >> 2] = r22;
        HEAP32[r2 + (r13 + 6)] = r6;
        HEAP32[r2 + (r13 + 3)] = r22;
        HEAP32[r2 + (r13 + 2)] = r22;
        break;
      }
      if ((r33 | 0) == 31) {
        r34 = 0;
      } else {
        r34 = 25 - (r33 >>> 1) | 0;
      }
      r27 = r23 << r34;
      r14 = HEAP32[r6 >> 2];
      while (1) {
        if ((HEAP32[r14 + 4 >> 2] & -8 | 0) == (r23 | 0)) {
          break;
        }
        r35 = (r27 >>> 31 << 2) + r14 + 16 | 0;
        r6 = HEAP32[r35 >> 2];
        if ((r6 | 0) == 0) {
          r3 = 1307;
          break;
        } else {
          r27 = r27 << 1;
          r14 = r6;
        }
      }
      if (r3 == 1307) {
        if (r35 >>> 0 < HEAP32[1311497] >>> 0) {
          _abort();
        } else {
          HEAP32[r35 >> 2] = r22;
          HEAP32[r2 + (r13 + 6)] = r14;
          HEAP32[r2 + (r13 + 3)] = r22;
          HEAP32[r2 + (r13 + 2)] = r22;
          break;
        }
      }
      r27 = r14 + 8 | 0;
      r6 = HEAP32[r27 >> 2];
      r5 = HEAP32[1311497];
      if (r14 >>> 0 < r5 >>> 0) {
        _abort();
      }
      if (r6 >>> 0 < r5 >>> 0) {
        _abort();
      } else {
        HEAP32[r6 + 12 >> 2] = r22;
        HEAP32[r27 >> 2] = r22;
        HEAP32[r2 + (r13 + 2)] = r6;
        HEAP32[r2 + (r13 + 3)] = r14;
        HEAP32[r2 + (r13 + 6)] = 0;
        break;
      }
    }
  } while (0);
  r26 = r24 + 8 | 0;
  return r26;
}
function _sys_alloc(r1) {
  var r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26;
  r2 = 0;
  if ((HEAP32[1310722] | 0) == 0) {
    _init_mparams();
  }
  r3 = r1 + 48 | 0;
  r4 = HEAP32[1310724];
  r5 = r4 + (r1 + 47) & -r4;
  if (r5 >>> 0 <= r1 >>> 0) {
    r6 = 0;
    return r6;
  }
  r4 = HEAP32[1311603];
  do {
    if ((r4 | 0) != 0) {
      r7 = HEAP32[1311601];
      r8 = r7 + r5 | 0;
      if (r8 >>> 0 <= r7 >>> 0 | r8 >>> 0 > r4 >>> 0) {
        r6 = 0;
      } else {
        break;
      }
      return r6;
    }
  } while (0);
  L1800 : do {
    if ((HEAP32[1311604] & 4 | 0) == 0) {
      r4 = HEAP32[1311499];
      do {
        if ((r4 | 0) == 0) {
          r2 = 1335;
        } else {
          r8 = _segment_holding(r4);
          if ((r8 | 0) == 0) {
            r2 = 1335;
            break;
          }
          r7 = HEAP32[1310724];
          r9 = r1 + 47 - HEAP32[1311496] + r7 & -r7;
          if (r9 >>> 0 >= 2147483647) {
            r10 = 0;
            break;
          }
          r7 = _sbrk(r9);
          r11 = (r7 | 0) == (HEAP32[r8 >> 2] + HEAP32[r8 + 4 >> 2] | 0);
          r12 = r11 ? r7 : -1;
          r13 = r11 ? r9 : 0;
          r14 = r7;
          r15 = r9;
          r2 = 1344;
          break;
        }
      } while (0);
      do {
        if (r2 == 1335) {
          r4 = _sbrk(0);
          if ((r4 | 0) == -1) {
            r10 = 0;
            break;
          }
          r9 = r4;
          r7 = HEAP32[1310723];
          r11 = r7 - 1 | 0;
          if ((r11 & r9 | 0) == 0) {
            r16 = r5;
          } else {
            r16 = r5 - r9 + (r11 + r9 & -r7) | 0;
          }
          r7 = HEAP32[1311601];
          r9 = r7 + r16 | 0;
          if (!(r16 >>> 0 > r1 >>> 0 & r16 >>> 0 < 2147483647)) {
            r10 = 0;
            break;
          }
          r11 = HEAP32[1311603];
          if ((r11 | 0) != 0) {
            if (r9 >>> 0 <= r7 >>> 0 | r9 >>> 0 > r11 >>> 0) {
              r10 = 0;
              break;
            }
          }
          r11 = _sbrk(r16);
          r9 = (r11 | 0) == (r4 | 0);
          r12 = r9 ? r4 : -1;
          r13 = r9 ? r16 : 0;
          r14 = r11;
          r15 = r16;
          r2 = 1344;
          break;
        }
      } while (0);
      L1816 : do {
        if (r2 == 1344) {
          r11 = -r15 | 0;
          if ((r12 | 0) != -1) {
            r17 = r13;
            r18 = r12;
            r2 = 1355;
            break L1800;
          }
          do {
            if ((r14 | 0) != -1 & r15 >>> 0 < 2147483647 & r15 >>> 0 < r3 >>> 0) {
              r9 = HEAP32[1310724];
              r4 = r1 + 47 - r15 + r9 & -r9;
              if (r4 >>> 0 >= 2147483647) {
                r19 = r15;
                break;
              }
              if ((_sbrk(r4) | 0) == -1) {
                _sbrk(r11);
                r10 = r13;
                break L1816;
              } else {
                r19 = r4 + r15 | 0;
                break;
              }
            } else {
              r19 = r15;
            }
          } while (0);
          if ((r14 | 0) == -1) {
            r10 = r13;
          } else {
            r17 = r19;
            r18 = r14;
            r2 = 1355;
            break L1800;
          }
        }
      } while (0);
      HEAP32[1311604] = HEAP32[1311604] | 4;
      r20 = r10;
      r2 = 1352;
      break;
    } else {
      r20 = 0;
      r2 = 1352;
    }
  } while (0);
  do {
    if (r2 == 1352) {
      if (r5 >>> 0 >= 2147483647) {
        break;
      }
      r10 = _sbrk(r5);
      r14 = _sbrk(0);
      if (!((r14 | 0) != -1 & (r10 | 0) != -1 & r10 >>> 0 < r14 >>> 0)) {
        break;
      }
      r19 = r14 - r10 | 0;
      r14 = r19 >>> 0 > (r1 + 40 | 0) >>> 0;
      r13 = r14 ? r10 : -1;
      if ((r13 | 0) == -1) {
        break;
      } else {
        r17 = r14 ? r19 : r20;
        r18 = r13;
        r2 = 1355;
        break;
      }
    }
  } while (0);
  do {
    if (r2 == 1355) {
      r20 = HEAP32[1311601] + r17 | 0;
      HEAP32[1311601] = r20;
      if (r20 >>> 0 > HEAP32[1311602] >>> 0) {
        HEAP32[1311602] = r20;
      }
      L1836 : do {
        if ((HEAP32[1311499] | 0) == 0) {
          r20 = HEAP32[1311497];
          if ((r20 | 0) == 0 | r18 >>> 0 < r20 >>> 0) {
            HEAP32[1311497] = r18;
          }
          HEAP32[1311605] = r18;
          HEAP32[1311606] = r17;
          HEAP32[1311608] = 0;
          HEAP32[1311502] = HEAP32[1310722];
          HEAP32[1311501] = -1;
          _init_bins();
          _init_top(r18, r17 - 40 | 0);
        } else {
          r20 = 5246420, r5 = r20 >> 2;
          while (1) {
            r21 = HEAP32[r5];
            r22 = r20 + 4 | 0;
            r23 = HEAP32[r22 >> 2];
            r24 = r21 + r23 | 0;
            if ((r18 | 0) == (r24 | 0)) {
              r2 = 1363;
              break;
            }
            r13 = HEAP32[r5 + 2];
            if ((r13 | 0) == 0) {
              break;
            } else {
              r20 = r13, r5 = r20 >> 2;
            }
          }
          do {
            if (r2 == 1363) {
              if ((HEAP32[r5 + 3] & 8 | 0) != 0) {
                break;
              }
              r20 = HEAP32[1311499];
              if (!(r20 >>> 0 >= r21 >>> 0 & r20 >>> 0 < r24 >>> 0)) {
                break;
              }
              HEAP32[r22 >> 2] = r23 + r17 | 0;
              _init_top(HEAP32[1311499], HEAP32[1311496] + r17 | 0);
              break L1836;
            }
          } while (0);
          if (r18 >>> 0 < HEAP32[1311497] >>> 0) {
            HEAP32[1311497] = r18;
          }
          r5 = r18 + r17 | 0;
          r20 = 5246420;
          while (1) {
            r25 = r20 | 0;
            r26 = HEAP32[r25 >> 2];
            if ((r26 | 0) == (r5 | 0)) {
              r2 = 1371;
              break;
            }
            r13 = HEAP32[r20 + 8 >> 2];
            if ((r13 | 0) == 0) {
              break;
            } else {
              r20 = r13;
            }
          }
          do {
            if (r2 == 1371) {
              if ((HEAP32[r20 + 12 >> 2] & 8 | 0) != 0) {
                break;
              }
              HEAP32[r25 >> 2] = r18;
              r5 = r20 + 4 | 0;
              HEAP32[r5 >> 2] = HEAP32[r5 >> 2] + r17 | 0;
              r6 = _prepend_alloc(r18, r26, r1);
              return r6;
            }
          } while (0);
          _add_segment(r18, r17);
        }
      } while (0);
      r20 = HEAP32[1311496];
      if (r20 >>> 0 <= r1 >>> 0) {
        break;
      }
      r5 = r20 - r1 | 0;
      HEAP32[1311496] = r5;
      r20 = HEAP32[1311499];
      r13 = r20;
      HEAP32[1311499] = r13 + r1 | 0;
      HEAP32[r1 + (r13 + 4) >> 2] = r5 | 1;
      HEAP32[r20 + 4 >> 2] = r1 | 3;
      r6 = r20 + 8 | 0;
      return r6;
    }
  } while (0);
  HEAP32[___errno_location() >> 2] = 12;
  r6 = 0;
  return r6;
}
function _free(r1) {
  var r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31, r32, r33, r34, r35, r36, r37, r38, r39, r40, r41, r42, r43, r44;
  r2 = r1 >> 2;
  r3 = 0;
  if ((r1 | 0) == 0) {
    return;
  }
  r4 = r1 - 8 | 0;
  r5 = r4;
  r6 = HEAP32[1311497];
  if (r4 >>> 0 < r6 >>> 0) {
    _abort();
  }
  r7 = HEAP32[r1 - 4 >> 2];
  r8 = r7 & 3;
  if ((r8 | 0) == 1) {
    _abort();
  }
  r9 = r7 & -8, r10 = r9 >> 2;
  r11 = r1 + (r9 - 8) | 0;
  r12 = r11;
  L1875 : do {
    if ((r7 & 1 | 0) == 0) {
      r13 = HEAP32[r4 >> 2];
      if ((r8 | 0) == 0) {
        return;
      }
      r14 = -8 - r13 | 0, r15 = r14 >> 2;
      r16 = r1 + r14 | 0;
      r17 = r16;
      r18 = r13 + r9 | 0;
      if (r16 >>> 0 < r6 >>> 0) {
        _abort();
      }
      if ((r17 | 0) == (HEAP32[1311498] | 0)) {
        r19 = (r1 + (r9 - 4) | 0) >> 2;
        if ((HEAP32[r19] & 3 | 0) != 3) {
          r20 = r17, r21 = r20 >> 2;
          r22 = r18;
          break;
        }
        HEAP32[1311495] = r18;
        HEAP32[r19] = HEAP32[r19] & -2;
        HEAP32[r15 + (r2 + 1)] = r18 | 1;
        HEAP32[r11 >> 2] = r18;
        return;
      }
      r19 = r13 >>> 3;
      if (r13 >>> 0 < 256) {
        r13 = HEAP32[r15 + (r2 + 2)];
        r23 = HEAP32[r15 + (r2 + 3)];
        r24 = (r19 << 3) + 5246012 | 0;
        do {
          if ((r13 | 0) != (r24 | 0)) {
            if (r13 >>> 0 < r6 >>> 0) {
              _abort();
            }
            if ((HEAP32[r13 + 12 >> 2] | 0) == (r17 | 0)) {
              break;
            }
            _abort();
          }
        } while (0);
        if ((r23 | 0) == (r13 | 0)) {
          HEAP32[1311493] = HEAP32[1311493] & (1 << r19 ^ -1);
          r20 = r17, r21 = r20 >> 2;
          r22 = r18;
          break;
        }
        do {
          if ((r23 | 0) != (r24 | 0)) {
            if (r23 >>> 0 < HEAP32[1311497] >>> 0) {
              _abort();
            }
            if ((HEAP32[r23 + 8 >> 2] | 0) == (r17 | 0)) {
              break;
            }
            _abort();
          }
        } while (0);
        HEAP32[r13 + 12 >> 2] = r23;
        HEAP32[r23 + 8 >> 2] = r13;
        r20 = r17, r21 = r20 >> 2;
        r22 = r18;
        break;
      }
      r24 = r16;
      r19 = HEAP32[r15 + (r2 + 6)];
      r25 = HEAP32[r15 + (r2 + 3)];
      L1908 : do {
        if ((r25 | 0) == (r24 | 0)) {
          r26 = r14 + (r1 + 20) | 0;
          r27 = HEAP32[r26 >> 2];
          do {
            if ((r27 | 0) == 0) {
              r28 = r14 + (r1 + 16) | 0;
              r29 = HEAP32[r28 >> 2];
              if ((r29 | 0) == 0) {
                r30 = 0, r31 = r30 >> 2;
                break L1908;
              } else {
                r32 = r29;
                r33 = r28;
                break;
              }
            } else {
              r32 = r27;
              r33 = r26;
            }
          } while (0);
          while (1) {
            r26 = r32 + 20 | 0;
            if ((HEAP32[r26 >> 2] | 0) == 0) {
              r27 = r32 + 16 | 0;
              if ((HEAP32[r27 >> 2] | 0) == 0) {
                break;
              } else {
                r34 = r27;
              }
            } else {
              r34 = r26;
            }
            r32 = HEAP32[r34 >> 2];
            r33 = r34;
          }
          if (r33 >>> 0 < HEAP32[1311497] >>> 0) {
            _abort();
          } else {
            HEAP32[r33 >> 2] = 0;
            r30 = r32, r31 = r30 >> 2;
            break;
          }
        } else {
          r26 = HEAP32[r15 + (r2 + 2)];
          if (r26 >>> 0 < r6 >>> 0) {
            _abort();
          }
          r27 = r26 + 12 | 0;
          if ((HEAP32[r27 >> 2] | 0) != (r24 | 0)) {
            _abort();
          }
          r28 = r25 + 8 | 0;
          if ((HEAP32[r28 >> 2] | 0) == (r24 | 0)) {
            HEAP32[r27 >> 2] = r25;
            HEAP32[r28 >> 2] = r26;
            r30 = r25, r31 = r30 >> 2;
            break;
          } else {
            _abort();
          }
        }
      } while (0);
      if ((r19 | 0) == 0) {
        r20 = r17, r21 = r20 >> 2;
        r22 = r18;
        break;
      }
      r25 = r14 + (r1 + 28) | 0;
      r16 = (HEAP32[r25 >> 2] << 2) + 5246276 | 0;
      do {
        if ((r24 | 0) == (HEAP32[r16 >> 2] | 0)) {
          HEAP32[r16 >> 2] = r30;
          if ((r30 | 0) != 0) {
            break;
          }
          HEAP32[1311494] = HEAP32[1311494] & (1 << HEAP32[r25 >> 2] ^ -1);
          r20 = r17, r21 = r20 >> 2;
          r22 = r18;
          break L1875;
        } else {
          if (r19 >>> 0 < HEAP32[1311497] >>> 0) {
            _abort();
          }
          r13 = r19 + 16 | 0;
          if ((HEAP32[r13 >> 2] | 0) == (r24 | 0)) {
            HEAP32[r13 >> 2] = r30;
          } else {
            HEAP32[r19 + 20 >> 2] = r30;
          }
          if ((r30 | 0) == 0) {
            r20 = r17, r21 = r20 >> 2;
            r22 = r18;
            break L1875;
          }
        }
      } while (0);
      if (r30 >>> 0 < HEAP32[1311497] >>> 0) {
        _abort();
      }
      HEAP32[r31 + 6] = r19;
      r24 = HEAP32[r15 + (r2 + 4)];
      do {
        if ((r24 | 0) != 0) {
          if (r24 >>> 0 < HEAP32[1311497] >>> 0) {
            _abort();
          } else {
            HEAP32[r31 + 4] = r24;
            HEAP32[r24 + 24 >> 2] = r30;
            break;
          }
        }
      } while (0);
      r24 = HEAP32[r15 + (r2 + 5)];
      if ((r24 | 0) == 0) {
        r20 = r17, r21 = r20 >> 2;
        r22 = r18;
        break;
      }
      if (r24 >>> 0 < HEAP32[1311497] >>> 0) {
        _abort();
      } else {
        HEAP32[r31 + 5] = r24;
        HEAP32[r24 + 24 >> 2] = r30;
        r20 = r17, r21 = r20 >> 2;
        r22 = r18;
        break;
      }
    } else {
      r20 = r5, r21 = r20 >> 2;
      r22 = r9;
    }
  } while (0);
  r5 = r20, r30 = r5 >> 2;
  if (r5 >>> 0 >= r11 >>> 0) {
    _abort();
  }
  r5 = r1 + (r9 - 4) | 0;
  r31 = HEAP32[r5 >> 2];
  if ((r31 & 1 | 0) == 0) {
    _abort();
  }
  do {
    if ((r31 & 2 | 0) == 0) {
      if ((r12 | 0) == (HEAP32[1311499] | 0)) {
        r6 = HEAP32[1311496] + r22 | 0;
        HEAP32[1311496] = r6;
        HEAP32[1311499] = r20;
        HEAP32[r21 + 1] = r6 | 1;
        if ((r20 | 0) == (HEAP32[1311498] | 0)) {
          HEAP32[1311498] = 0;
          HEAP32[1311495] = 0;
        }
        if (r6 >>> 0 <= HEAP32[1311500] >>> 0) {
          return;
        }
        _sys_trim(0);
        return;
      }
      if ((r12 | 0) == (HEAP32[1311498] | 0)) {
        r6 = HEAP32[1311495] + r22 | 0;
        HEAP32[1311495] = r6;
        HEAP32[1311498] = r20;
        HEAP32[r21 + 1] = r6 | 1;
        HEAP32[(r6 >> 2) + r30] = r6;
        return;
      }
      r6 = (r31 & -8) + r22 | 0;
      r32 = r31 >>> 3;
      L1982 : do {
        if (r31 >>> 0 < 256) {
          r33 = HEAP32[r2 + r10];
          r34 = HEAP32[((r9 | 4) >> 2) + r2];
          r8 = (r32 << 3) + 5246012 | 0;
          do {
            if ((r33 | 0) != (r8 | 0)) {
              if (r33 >>> 0 < HEAP32[1311497] >>> 0) {
                _abort();
              }
              if ((HEAP32[r33 + 12 >> 2] | 0) == (r12 | 0)) {
                break;
              }
              _abort();
            }
          } while (0);
          if ((r34 | 0) == (r33 | 0)) {
            HEAP32[1311493] = HEAP32[1311493] & (1 << r32 ^ -1);
            break;
          }
          do {
            if ((r34 | 0) != (r8 | 0)) {
              if (r34 >>> 0 < HEAP32[1311497] >>> 0) {
                _abort();
              }
              if ((HEAP32[r34 + 8 >> 2] | 0) == (r12 | 0)) {
                break;
              }
              _abort();
            }
          } while (0);
          HEAP32[r33 + 12 >> 2] = r34;
          HEAP32[r34 + 8 >> 2] = r33;
        } else {
          r8 = r11;
          r4 = HEAP32[r10 + (r2 + 4)];
          r7 = HEAP32[((r9 | 4) >> 2) + r2];
          L2002 : do {
            if ((r7 | 0) == (r8 | 0)) {
              r24 = r9 + (r1 + 12) | 0;
              r19 = HEAP32[r24 >> 2];
              do {
                if ((r19 | 0) == 0) {
                  r25 = r9 + (r1 + 8) | 0;
                  r16 = HEAP32[r25 >> 2];
                  if ((r16 | 0) == 0) {
                    r35 = 0, r36 = r35 >> 2;
                    break L2002;
                  } else {
                    r37 = r16;
                    r38 = r25;
                    break;
                  }
                } else {
                  r37 = r19;
                  r38 = r24;
                }
              } while (0);
              while (1) {
                r24 = r37 + 20 | 0;
                if ((HEAP32[r24 >> 2] | 0) == 0) {
                  r19 = r37 + 16 | 0;
                  if ((HEAP32[r19 >> 2] | 0) == 0) {
                    break;
                  } else {
                    r39 = r19;
                  }
                } else {
                  r39 = r24;
                }
                r37 = HEAP32[r39 >> 2];
                r38 = r39;
              }
              if (r38 >>> 0 < HEAP32[1311497] >>> 0) {
                _abort();
              } else {
                HEAP32[r38 >> 2] = 0;
                r35 = r37, r36 = r35 >> 2;
                break;
              }
            } else {
              r24 = HEAP32[r2 + r10];
              if (r24 >>> 0 < HEAP32[1311497] >>> 0) {
                _abort();
              }
              r19 = r24 + 12 | 0;
              if ((HEAP32[r19 >> 2] | 0) != (r8 | 0)) {
                _abort();
              }
              r25 = r7 + 8 | 0;
              if ((HEAP32[r25 >> 2] | 0) == (r8 | 0)) {
                HEAP32[r19 >> 2] = r7;
                HEAP32[r25 >> 2] = r24;
                r35 = r7, r36 = r35 >> 2;
                break;
              } else {
                _abort();
              }
            }
          } while (0);
          if ((r4 | 0) == 0) {
            break;
          }
          r7 = r9 + (r1 + 20) | 0;
          r33 = (HEAP32[r7 >> 2] << 2) + 5246276 | 0;
          do {
            if ((r8 | 0) == (HEAP32[r33 >> 2] | 0)) {
              HEAP32[r33 >> 2] = r35;
              if ((r35 | 0) != 0) {
                break;
              }
              HEAP32[1311494] = HEAP32[1311494] & (1 << HEAP32[r7 >> 2] ^ -1);
              break L1982;
            } else {
              if (r4 >>> 0 < HEAP32[1311497] >>> 0) {
                _abort();
              }
              r34 = r4 + 16 | 0;
              if ((HEAP32[r34 >> 2] | 0) == (r8 | 0)) {
                HEAP32[r34 >> 2] = r35;
              } else {
                HEAP32[r4 + 20 >> 2] = r35;
              }
              if ((r35 | 0) == 0) {
                break L1982;
              }
            }
          } while (0);
          if (r35 >>> 0 < HEAP32[1311497] >>> 0) {
            _abort();
          }
          HEAP32[r36 + 6] = r4;
          r8 = HEAP32[r10 + (r2 + 2)];
          do {
            if ((r8 | 0) != 0) {
              if (r8 >>> 0 < HEAP32[1311497] >>> 0) {
                _abort();
              } else {
                HEAP32[r36 + 4] = r8;
                HEAP32[r8 + 24 >> 2] = r35;
                break;
              }
            }
          } while (0);
          r8 = HEAP32[r10 + (r2 + 3)];
          if ((r8 | 0) == 0) {
            break;
          }
          if (r8 >>> 0 < HEAP32[1311497] >>> 0) {
            _abort();
          } else {
            HEAP32[r36 + 5] = r8;
            HEAP32[r8 + 24 >> 2] = r35;
            break;
          }
        }
      } while (0);
      HEAP32[r21 + 1] = r6 | 1;
      HEAP32[(r6 >> 2) + r30] = r6;
      if ((r20 | 0) != (HEAP32[1311498] | 0)) {
        r40 = r6;
        break;
      }
      HEAP32[1311495] = r6;
      return;
    } else {
      HEAP32[r5 >> 2] = r31 & -2;
      HEAP32[r21 + 1] = r22 | 1;
      HEAP32[(r22 >> 2) + r30] = r22;
      r40 = r22;
    }
  } while (0);
  r22 = r40 >>> 3;
  if (r40 >>> 0 < 256) {
    r30 = r22 << 1;
    r31 = (r30 << 2) + 5246012 | 0;
    r5 = HEAP32[1311493];
    r35 = 1 << r22;
    do {
      if ((r5 & r35 | 0) == 0) {
        HEAP32[1311493] = r5 | r35;
        r41 = r31;
      } else {
        r22 = HEAP32[(r30 + 2 << 2) + 5246012 >> 2];
        if (r22 >>> 0 >= HEAP32[1311497] >>> 0) {
          r41 = r22;
          break;
        }
        _abort();
      }
    } while (0);
    HEAP32[(r30 + 2 << 2) + 5246012 >> 2] = r20;
    HEAP32[r41 + 12 >> 2] = r20;
    HEAP32[r21 + 2] = r41;
    HEAP32[r21 + 3] = r31;
    return;
  }
  r31 = r20;
  r41 = r40 >>> 8;
  do {
    if ((r41 | 0) == 0) {
      r42 = 0;
    } else {
      if (r40 >>> 0 > 16777215) {
        r42 = 31;
        break;
      }
      r30 = (r41 + 1048320 | 0) >>> 16 & 8;
      r35 = r41 << r30;
      r5 = (r35 + 520192 | 0) >>> 16 & 4;
      r22 = r35 << r5;
      r35 = (r22 + 245760 | 0) >>> 16 & 2;
      r36 = 14 - (r5 | r30 | r35) + (r22 << r35 >>> 15) | 0;
      r42 = r40 >>> ((r36 + 7 | 0) >>> 0) & 1 | r36 << 1;
    }
  } while (0);
  r41 = (r42 << 2) + 5246276 | 0;
  HEAP32[r21 + 7] = r42;
  HEAP32[r21 + 5] = 0;
  HEAP32[r21 + 4] = 0;
  r36 = HEAP32[1311494];
  r35 = 1 << r42;
  do {
    if ((r36 & r35 | 0) == 0) {
      HEAP32[1311494] = r36 | r35;
      HEAP32[r41 >> 2] = r31;
      HEAP32[r21 + 6] = r41;
      HEAP32[r21 + 3] = r20;
      HEAP32[r21 + 2] = r20;
    } else {
      if ((r42 | 0) == 31) {
        r43 = 0;
      } else {
        r43 = 25 - (r42 >>> 1) | 0;
      }
      r22 = r40 << r43;
      r30 = HEAP32[r41 >> 2];
      while (1) {
        if ((HEAP32[r30 + 4 >> 2] & -8 | 0) == (r40 | 0)) {
          break;
        }
        r44 = (r22 >>> 31 << 2) + r30 + 16 | 0;
        r5 = HEAP32[r44 >> 2];
        if ((r5 | 0) == 0) {
          r3 = 1513;
          break;
        } else {
          r22 = r22 << 1;
          r30 = r5;
        }
      }
      if (r3 == 1513) {
        if (r44 >>> 0 < HEAP32[1311497] >>> 0) {
          _abort();
        } else {
          HEAP32[r44 >> 2] = r31;
          HEAP32[r21 + 6] = r30;
          HEAP32[r21 + 3] = r20;
          HEAP32[r21 + 2] = r20;
          break;
        }
      }
      r22 = r30 + 8 | 0;
      r6 = HEAP32[r22 >> 2];
      r5 = HEAP32[1311497];
      if (r30 >>> 0 < r5 >>> 0) {
        _abort();
      }
      if (r6 >>> 0 < r5 >>> 0) {
        _abort();
      } else {
        HEAP32[r6 + 12 >> 2] = r31;
        HEAP32[r22 >> 2] = r31;
        HEAP32[r21 + 2] = r6;
        HEAP32[r21 + 3] = r30;
        HEAP32[r21 + 6] = 0;
        break;
      }
    }
  } while (0);
  r21 = HEAP32[1311501] - 1 | 0;
  HEAP32[1311501] = r21;
  if ((r21 | 0) != 0) {
    return;
  }
  _release_unused_segments();
  return;
}
function _release_unused_segments() {
  var r1, r2;
  r1 = 5246428;
  while (1) {
    r2 = HEAP32[r1 >> 2];
    if ((r2 | 0) == 0) {
      break;
    } else {
      r1 = r2 + 8 | 0;
    }
  }
  HEAP32[1311501] = -1;
  return;
}
function _sys_trim(r1) {
  var r2, r3, r4, r5, r6, r7, r8, r9, r10;
  if ((HEAP32[1310722] | 0) == 0) {
    _init_mparams();
  }
  if (r1 >>> 0 >= 4294967232) {
    r2 = 0;
    r3 = r2 & 1;
    return r3;
  }
  r4 = HEAP32[1311499];
  if ((r4 | 0) == 0) {
    r2 = 0;
    r3 = r2 & 1;
    return r3;
  }
  r5 = HEAP32[1311496];
  do {
    if (r5 >>> 0 > (r1 + 40 | 0) >>> 0) {
      r6 = HEAP32[1310724];
      r7 = Math.imul(Math.floor(((-40 - r1 - 1 + r5 + r6 | 0) >>> 0) / (r6 >>> 0)) - 1 | 0, r6);
      r8 = _segment_holding(r4), r9 = r8 >> 2;
      if ((HEAP32[r9 + 3] & 8 | 0) != 0) {
        break;
      }
      r10 = _sbrk(0);
      if ((r10 | 0) != (HEAP32[r9] + HEAP32[r9 + 1] | 0)) {
        break;
      }
      r9 = _sbrk(-(r7 >>> 0 > 2147483646 ? -2147483648 - r6 | 0 : r7) | 0);
      r7 = _sbrk(0);
      if (!((r9 | 0) != -1 & r7 >>> 0 < r10 >>> 0)) {
        break;
      }
      r9 = r10 - r7 | 0;
      if ((r10 | 0) == (r7 | 0)) {
        break;
      }
      r6 = r8 + 4 | 0;
      HEAP32[r6 >> 2] = HEAP32[r6 >> 2] - r9 | 0;
      HEAP32[1311601] = HEAP32[1311601] - r9 | 0;
      _init_top(HEAP32[1311499], HEAP32[1311496] - r9 | 0);
      r2 = (r10 | 0) != (r7 | 0);
      r3 = r2 & 1;
      return r3;
    }
  } while (0);
  if (HEAP32[1311496] >>> 0 <= HEAP32[1311500] >>> 0) {
    r2 = 0;
    r3 = r2 & 1;
    return r3;
  }
  HEAP32[1311500] = -1;
  r2 = 0;
  r3 = r2 & 1;
  return r3;
}
function _calloc(r1, r2) {
  var r3, r4;
  do {
    if ((r1 | 0) == 0) {
      r3 = 0;
    } else {
      r4 = Math.imul(r2, r1);
      if ((r2 | r1) >>> 0 <= 65535) {
        r3 = r4;
        break;
      }
      r3 = (Math.floor((r4 >>> 0) / (r1 >>> 0)) | 0) == (r2 | 0) ? r4 : -1;
    }
  } while (0);
  r2 = _malloc(r3);
  if ((r2 | 0) == 0) {
    return r2;
  }
  if ((HEAP32[r2 - 4 >> 2] & 3 | 0) == 0) {
    return r2;
  }
  _memset(r2, 0, r3);
  return r2;
}
Module["_calloc"] = _calloc;
function _realloc(r1, r2) {
  var r3, r4, r5, r6;
  if ((r1 | 0) == 0) {
    r3 = _malloc(r2);
    return r3;
  }
  if (r2 >>> 0 > 4294967231) {
    HEAP32[___errno_location() >> 2] = 12;
    r3 = 0;
    return r3;
  }
  if (r2 >>> 0 < 11) {
    r4 = 16;
  } else {
    r4 = r2 + 11 & -8;
  }
  r5 = _try_realloc_chunk(r1 - 8 | 0, r4);
  if ((r5 | 0) != 0) {
    r3 = r5 + 8 | 0;
    return r3;
  }
  r5 = _malloc(r2);
  if ((r5 | 0) == 0) {
    r3 = 0;
    return r3;
  }
  r4 = HEAP32[r1 - 4 >> 2];
  r6 = (r4 & -8) - ((r4 & 3 | 0) == 0 ? 8 : 4) | 0;
  _memcpy(r5, r1, r6 >>> 0 < r2 >>> 0 ? r6 : r2);
  _free(r1);
  r3 = r5;
  return r3;
}
Module["_realloc"] = _realloc;
function _realloc_in_place(r1, r2) {
  var r3;
  if ((r1 | 0) == 0) {
    return 0;
  }
  if (r2 >>> 0 > 4294967231) {
    HEAP32[___errno_location() >> 2] = 12;
    return 0;
  }
  if (r2 >>> 0 < 11) {
    r3 = 16;
  } else {
    r3 = r2 + 11 & -8;
  }
  r2 = r1 - 8 | 0;
  return (_try_realloc_chunk(r2, r3) | 0) == (r2 | 0) ? r1 : 0;
}
function _memalign(r1, r2) {
  var r3;
  if (r1 >>> 0 < 9) {
    r3 = _malloc(r2);
    return r3;
  } else {
    r3 = _internal_memalign(r1, r2);
    return r3;
  }
}
function _internal_memalign(r1, r2) {
  var r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14;
  r3 = r1 >>> 0 < 16 ? 16 : r1;
  L2171 : do {
    if ((r3 - 1 & r3 | 0) == 0) {
      r4 = r3;
    } else {
      r1 = 16;
      while (1) {
        if (r1 >>> 0 < r3 >>> 0) {
          r1 = r1 << 1;
        } else {
          r4 = r1;
          break L2171;
        }
      }
    }
  } while (0);
  if ((-64 - r4 | 0) >>> 0 <= r2 >>> 0) {
    HEAP32[___errno_location() >> 2] = 12;
    r5 = 0;
    return r5;
  }
  if (r2 >>> 0 < 11) {
    r6 = 16;
  } else {
    r6 = r2 + 11 & -8;
  }
  r2 = _malloc(r6 + (r4 + 12) | 0);
  if ((r2 | 0) == 0) {
    r5 = 0;
    return r5;
  }
  r3 = r2 - 8 | 0;
  r1 = r3;
  r7 = r4 - 1 | 0;
  do {
    if ((r2 & r7 | 0) == 0) {
      r8 = r1;
    } else {
      r9 = r2 + r7 & -r4;
      r10 = r9 - 8 | 0;
      r11 = r3;
      if ((r10 - r11 | 0) >>> 0 > 15) {
        r12 = r10;
      } else {
        r12 = r9 + (r4 - 8) | 0;
      }
      r9 = r12;
      r10 = r12 - r11 | 0;
      r11 = (r2 - 4 | 0) >> 2;
      r13 = HEAP32[r11];
      r14 = (r13 & -8) - r10 | 0;
      if ((r13 & 3 | 0) == 0) {
        HEAP32[r12 >> 2] = HEAP32[r3 >> 2] + r10 | 0;
        HEAP32[r12 + 4 >> 2] = r14;
        r8 = r9;
        break;
      } else {
        r13 = r12 + 4 | 0;
        HEAP32[r13 >> 2] = r14 | HEAP32[r13 >> 2] & 1 | 2;
        r13 = r14 + (r12 + 4) | 0;
        HEAP32[r13 >> 2] = HEAP32[r13 >> 2] | 1;
        HEAP32[r11] = r10 | HEAP32[r11] & 1 | 2;
        r11 = r2 + (r10 - 4) | 0;
        HEAP32[r11 >> 2] = HEAP32[r11 >> 2] | 1;
        _dispose_chunk(r1, r10);
        r8 = r9;
        break;
      }
    }
  } while (0);
  r1 = r8 + 4 | 0;
  r2 = HEAP32[r1 >> 2];
  do {
    if ((r2 & 3 | 0) != 0) {
      r12 = r2 & -8;
      if (r12 >>> 0 <= (r6 + 16 | 0) >>> 0) {
        break;
      }
      r3 = r12 - r6 | 0;
      r4 = r8;
      HEAP32[r1 >> 2] = r6 | r2 & 1 | 2;
      HEAP32[r4 + (r6 | 4) >> 2] = r3 | 3;
      r7 = r4 + (r12 | 4) | 0;
      HEAP32[r7 >> 2] = HEAP32[r7 >> 2] | 1;
      _dispose_chunk(r4 + r6 | 0, r3);
    }
  } while (0);
  r5 = r8 + 8 | 0;
  return r5;
}
function _posix_memalign(r1, r2, r3) {
  var r4, r5, r6;
  do {
    if ((r2 | 0) == 8) {
      r4 = _malloc(r3);
    } else {
      r5 = r2 >>> 2;
      if ((r2 & 3 | 0) != 0 | (r5 | 0) == 0) {
        r6 = 22;
        return r6;
      }
      if ((r5 + 1073741823 & r5 | 0) != 0) {
        r6 = 22;
        return r6;
      }
      if ((-64 - r2 | 0) >>> 0 < r3 >>> 0) {
        r6 = 12;
        return r6;
      } else {
        r4 = _internal_memalign(r2 >>> 0 < 16 ? 16 : r2, r3);
        break;
      }
    }
  } while (0);
  if ((r4 | 0) == 0) {
    r6 = 12;
    return r6;
  }
  HEAP32[r1 >> 2] = r4;
  r6 = 0;
  return r6;
}
function _valloc(r1) {
  if ((HEAP32[1310722] | 0) == 0) {
    _init_mparams();
  }
  return _memalign(HEAP32[1310723], r1);
}
function _try_realloc_chunk(r1, r2) {
  var r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29;
  r3 = (r1 + 4 | 0) >> 2;
  r4 = HEAP32[r3];
  r5 = r4 & -8, r6 = r5 >> 2;
  r7 = r1, r8 = r7 >> 2;
  r9 = r7 + r5 | 0;
  r10 = r9;
  r11 = HEAP32[1311497];
  if (r7 >>> 0 < r11 >>> 0) {
    _abort();
  }
  r12 = r4 & 3;
  if (!((r12 | 0) != 1 & r7 >>> 0 < r9 >>> 0)) {
    _abort();
  }
  r13 = (r7 + (r5 | 4) | 0) >> 2;
  r14 = HEAP32[r13];
  if ((r14 & 1 | 0) == 0) {
    _abort();
  }
  if ((r12 | 0) == 0) {
    r15 = _mmap_resize(r1, r2);
    return r15;
  }
  if (r5 >>> 0 >= r2 >>> 0) {
    r12 = r5 - r2 | 0;
    if (r12 >>> 0 <= 15) {
      r15 = r1;
      return r15;
    }
    HEAP32[r3] = r4 & 1 | r2 | 2;
    HEAP32[(r2 + 4 >> 2) + r8] = r12 | 3;
    HEAP32[r13] = HEAP32[r13] | 1;
    _dispose_chunk(r7 + r2 | 0, r12);
    r15 = r1;
    return r15;
  }
  if ((r10 | 0) == (HEAP32[1311499] | 0)) {
    r12 = HEAP32[1311496] + r5 | 0;
    if (r12 >>> 0 <= r2 >>> 0) {
      r15 = 0;
      return r15;
    }
    r13 = r12 - r2 | 0;
    HEAP32[r3] = r4 & 1 | r2 | 2;
    HEAP32[(r2 + 4 >> 2) + r8] = r13 | 1;
    HEAP32[1311499] = r7 + r2 | 0;
    HEAP32[1311496] = r13;
    r15 = r1;
    return r15;
  }
  if ((r10 | 0) == (HEAP32[1311498] | 0)) {
    r13 = HEAP32[1311495] + r5 | 0;
    if (r13 >>> 0 < r2 >>> 0) {
      r15 = 0;
      return r15;
    }
    r12 = r13 - r2 | 0;
    if (r12 >>> 0 > 15) {
      HEAP32[r3] = r4 & 1 | r2 | 2;
      HEAP32[(r2 + 4 >> 2) + r8] = r12 | 1;
      HEAP32[(r13 >> 2) + r8] = r12;
      r16 = r13 + (r7 + 4) | 0;
      HEAP32[r16 >> 2] = HEAP32[r16 >> 2] & -2;
      r17 = r7 + r2 | 0;
      r18 = r12;
    } else {
      HEAP32[r3] = r4 & 1 | r13 | 2;
      r4 = r13 + (r7 + 4) | 0;
      HEAP32[r4 >> 2] = HEAP32[r4 >> 2] | 1;
      r17 = 0;
      r18 = 0;
    }
    HEAP32[1311495] = r18;
    HEAP32[1311498] = r17;
    r15 = r1;
    return r15;
  }
  if ((r14 & 2 | 0) != 0) {
    r15 = 0;
    return r15;
  }
  r17 = (r14 & -8) + r5 | 0;
  if (r17 >>> 0 < r2 >>> 0) {
    r15 = 0;
    return r15;
  }
  r18 = r17 - r2 | 0;
  r4 = r14 >>> 3;
  L2266 : do {
    if (r14 >>> 0 < 256) {
      r13 = HEAP32[r6 + (r8 + 2)];
      r12 = HEAP32[r6 + (r8 + 3)];
      r16 = (r4 << 3) + 5246012 | 0;
      do {
        if ((r13 | 0) != (r16 | 0)) {
          if (r13 >>> 0 < r11 >>> 0) {
            _abort();
          }
          if ((HEAP32[r13 + 12 >> 2] | 0) == (r10 | 0)) {
            break;
          }
          _abort();
        }
      } while (0);
      if ((r12 | 0) == (r13 | 0)) {
        HEAP32[1311493] = HEAP32[1311493] & (1 << r4 ^ -1);
        break;
      }
      do {
        if ((r12 | 0) != (r16 | 0)) {
          if (r12 >>> 0 < HEAP32[1311497] >>> 0) {
            _abort();
          }
          if ((HEAP32[r12 + 8 >> 2] | 0) == (r10 | 0)) {
            break;
          }
          _abort();
        }
      } while (0);
      HEAP32[r13 + 12 >> 2] = r12;
      HEAP32[r12 + 8 >> 2] = r13;
    } else {
      r16 = r9;
      r19 = HEAP32[r6 + (r8 + 6)];
      r20 = HEAP32[r6 + (r8 + 3)];
      L2268 : do {
        if ((r20 | 0) == (r16 | 0)) {
          r21 = r5 + (r7 + 20) | 0;
          r22 = HEAP32[r21 >> 2];
          do {
            if ((r22 | 0) == 0) {
              r23 = r5 + (r7 + 16) | 0;
              r24 = HEAP32[r23 >> 2];
              if ((r24 | 0) == 0) {
                r25 = 0, r26 = r25 >> 2;
                break L2268;
              } else {
                r27 = r24;
                r28 = r23;
                break;
              }
            } else {
              r27 = r22;
              r28 = r21;
            }
          } while (0);
          while (1) {
            r21 = r27 + 20 | 0;
            if ((HEAP32[r21 >> 2] | 0) == 0) {
              r22 = r27 + 16 | 0;
              if ((HEAP32[r22 >> 2] | 0) == 0) {
                break;
              } else {
                r29 = r22;
              }
            } else {
              r29 = r21;
            }
            r27 = HEAP32[r29 >> 2];
            r28 = r29;
          }
          if (r28 >>> 0 < HEAP32[1311497] >>> 0) {
            _abort();
          } else {
            HEAP32[r28 >> 2] = 0;
            r25 = r27, r26 = r25 >> 2;
            break;
          }
        } else {
          r21 = HEAP32[r6 + (r8 + 2)];
          if (r21 >>> 0 < r11 >>> 0) {
            _abort();
          }
          r22 = r21 + 12 | 0;
          if ((HEAP32[r22 >> 2] | 0) != (r16 | 0)) {
            _abort();
          }
          r23 = r20 + 8 | 0;
          if ((HEAP32[r23 >> 2] | 0) == (r16 | 0)) {
            HEAP32[r22 >> 2] = r20;
            HEAP32[r23 >> 2] = r21;
            r25 = r20, r26 = r25 >> 2;
            break;
          } else {
            _abort();
          }
        }
      } while (0);
      if ((r19 | 0) == 0) {
        break;
      }
      r20 = r5 + (r7 + 28) | 0;
      r13 = (HEAP32[r20 >> 2] << 2) + 5246276 | 0;
      do {
        if ((r16 | 0) == (HEAP32[r13 >> 2] | 0)) {
          HEAP32[r13 >> 2] = r25;
          if ((r25 | 0) != 0) {
            break;
          }
          HEAP32[1311494] = HEAP32[1311494] & (1 << HEAP32[r20 >> 2] ^ -1);
          break L2266;
        } else {
          if (r19 >>> 0 < HEAP32[1311497] >>> 0) {
            _abort();
          }
          r12 = r19 + 16 | 0;
          if ((HEAP32[r12 >> 2] | 0) == (r16 | 0)) {
            HEAP32[r12 >> 2] = r25;
          } else {
            HEAP32[r19 + 20 >> 2] = r25;
          }
          if ((r25 | 0) == 0) {
            break L2266;
          }
        }
      } while (0);
      if (r25 >>> 0 < HEAP32[1311497] >>> 0) {
        _abort();
      }
      HEAP32[r26 + 6] = r19;
      r16 = HEAP32[r6 + (r8 + 4)];
      do {
        if ((r16 | 0) != 0) {
          if (r16 >>> 0 < HEAP32[1311497] >>> 0) {
            _abort();
          } else {
            HEAP32[r26 + 4] = r16;
            HEAP32[r16 + 24 >> 2] = r25;
            break;
          }
        }
      } while (0);
      r16 = HEAP32[r6 + (r8 + 5)];
      if ((r16 | 0) == 0) {
        break;
      }
      if (r16 >>> 0 < HEAP32[1311497] >>> 0) {
        _abort();
      } else {
        HEAP32[r26 + 5] = r16;
        HEAP32[r16 + 24 >> 2] = r25;
        break;
      }
    }
  } while (0);
  if (r18 >>> 0 < 16) {
    HEAP32[r3] = r17 | HEAP32[r3] & 1 | 2;
    r25 = r7 + (r17 | 4) | 0;
    HEAP32[r25 >> 2] = HEAP32[r25 >> 2] | 1;
    r15 = r1;
    return r15;
  } else {
    HEAP32[r3] = HEAP32[r3] & 1 | r2 | 2;
    HEAP32[(r2 + 4 >> 2) + r8] = r18 | 3;
    r8 = r7 + (r17 | 4) | 0;
    HEAP32[r8 >> 2] = HEAP32[r8 >> 2] | 1;
    _dispose_chunk(r7 + r2 | 0, r18);
    r15 = r1;
    return r15;
  }
}
function _malloc_footprint() {
  return HEAP32[1311601];
}
function _malloc_max_footprint() {
  return HEAP32[1311602];
}
function _malloc_footprint_limit() {
  var r1;
  r1 = HEAP32[1311603];
  return (r1 | 0) == 0 ? -1 : r1;
}
function _malloc_set_footprint_limit(r1) {
  var r2, r3;
  if ((r1 | 0) == -1) {
    r2 = 0;
  } else {
    r3 = HEAP32[1310724];
    r2 = r1 - 1 + r3 & -r3;
  }
  HEAP32[1311603] = r2;
  return r2;
}
function _malloc_usable_size(r1) {
  var r2, r3;
  if ((r1 | 0) == 0) {
    r2 = 0;
    return r2;
  }
  r3 = HEAP32[r1 - 4 >> 2];
  r1 = r3 & 3;
  if ((r1 | 0) == 1) {
    r2 = 0;
    return r2;
  }
  r2 = (r3 & -8) - ((r1 | 0) == 0 ? 8 : 4) | 0;
  return r2;
}
function _pvalloc(r1) {
  var r2;
  if ((HEAP32[1310722] | 0) == 0) {
    _init_mparams();
  }
  r2 = HEAP32[1310723];
  return _memalign(r2, r1 - 1 + r2 & -r2);
}
function _independent_calloc(r1, r2, r3) {
  var r4, r5;
  r4 = STACKTOP;
  STACKTOP = STACKTOP + 4 | 0;
  r5 = r4;
  HEAP32[r5 >> 2] = r2;
  r2 = _ialloc(r1, r5, 3, r3);
  STACKTOP = r4;
  return r2;
}
function _ialloc(r1, r2, r3, r4) {
  var r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19, r20;
  if ((HEAP32[1310722] | 0) == 0) {
    _init_mparams();
  }
  r5 = (r1 | 0) == 0;
  do {
    if ((r4 | 0) == 0) {
      if (r5) {
        r6 = _malloc(0);
        return r6;
      } else {
        r7 = r1 << 2;
        if (r7 >>> 0 < 11) {
          r8 = 0;
          r9 = 16;
          break;
        }
        r8 = 0;
        r9 = r7 + 11 & -8;
        break;
      }
    } else {
      if (r5) {
        r6 = r4;
      } else {
        r8 = r4;
        r9 = 0;
        break;
      }
      return r6;
    }
  } while (0);
  L2376 : do {
    if ((r3 & 1 | 0) == 0) {
      if ((r1 | 0) == 0) {
        r10 = 0;
        r11 = 0;
        break;
      } else {
        r12 = 0;
        r13 = 0;
      }
      while (1) {
        r4 = HEAP32[r2 + (r13 << 2) >> 2];
        if (r4 >>> 0 < 11) {
          r14 = 16;
        } else {
          r14 = r4 + 11 & -8;
        }
        r4 = r14 + r12 | 0;
        r5 = r13 + 1 | 0;
        if ((r5 | 0) == (r1 | 0)) {
          r10 = 0;
          r11 = r4;
          break L2376;
        } else {
          r12 = r4;
          r13 = r5;
        }
      }
    } else {
      r5 = HEAP32[r2 >> 2];
      if (r5 >>> 0 < 11) {
        r15 = 16;
      } else {
        r15 = r5 + 11 & -8;
      }
      r10 = r15;
      r11 = Math.imul(r15, r1);
    }
  } while (0);
  r15 = _malloc(r9 - 4 + r11 | 0);
  if ((r15 | 0) == 0) {
    r6 = 0;
    return r6;
  }
  r13 = r15 - 8 | 0;
  r12 = HEAP32[r15 - 4 >> 2] & -8;
  if ((r3 & 2 | 0) != 0) {
    _memset(r15, 0, -4 - r9 + r12 | 0);
  }
  if ((r8 | 0) == 0) {
    HEAP32[r15 + (r11 - 4) >> 2] = r12 - r11 | 3;
    r16 = r15 + r11 | 0;
    r17 = r11;
  } else {
    r16 = r8;
    r17 = r12;
  }
  HEAP32[r16 >> 2] = r15;
  r15 = r1 - 1 | 0;
  L2397 : do {
    if ((r15 | 0) == 0) {
      r18 = r13;
      r19 = r17;
    } else {
      r1 = (r10 | 0) == 0;
      r12 = r13;
      r8 = r17;
      r11 = 0;
      while (1) {
        do {
          if (r1) {
            r9 = HEAP32[r2 + (r11 << 2) >> 2];
            if (r9 >>> 0 < 11) {
              r20 = 16;
              break;
            }
            r20 = r9 + 11 & -8;
          } else {
            r20 = r10;
          }
        } while (0);
        r9 = r8 - r20 | 0;
        HEAP32[r12 + 4 >> 2] = r20 | 3;
        r3 = r12 + r20 | 0;
        r14 = r11 + 1 | 0;
        HEAP32[r16 + (r14 << 2) >> 2] = r20 + (r12 + 8) | 0;
        if ((r14 | 0) == (r15 | 0)) {
          r18 = r3;
          r19 = r9;
          break L2397;
        } else {
          r12 = r3;
          r8 = r9;
          r11 = r14;
        }
      }
    }
  } while (0);
  HEAP32[r18 + 4 >> 2] = r19 | 3;
  r6 = r16;
  return r6;
}
function _independent_comalloc(r1, r2, r3) {
  return _ialloc(r1, r2, 0, r3);
}
function _bulk_free(r1, r2) {
  _internal_bulk_free(r1, r2);
  return 0;
}
function _malloc_trim(r1) {
  if ((HEAP32[1310722] | 0) == 0) {
    _init_mparams();
  }
  return _sys_trim(r1);
}
function _mallinfo(r1) {
  _internal_mallinfo(r1);
  return;
}
function _internal_mallinfo(r1) {
  var r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31, r32, r33;
  r2 = r1 >> 2;
  if ((HEAP32[1310722] | 0) == 0) {
    _init_mparams();
  }
  if ((HEAP32[1311499] | 0) == 0) {
    r3 = 0;
    r4 = 0;
    r5 = 0;
    r6 = 0;
    r7 = 0;
    r8 = 0;
    r9 = 0;
  } else {
    r10 = HEAP32[1311496] + 40 | 0;
    r11 = HEAP32[1311499];
    r12 = 1;
    r13 = r10;
    r14 = r10;
    r10 = 5246420;
    while (1) {
      r15 = (r10 | 0) >> 2;
      r16 = HEAP32[r15];
      r17 = r16 + 8 | 0;
      if ((r17 & 7 | 0) == 0) {
        r18 = 0;
      } else {
        r18 = -r17 & 7;
      }
      r17 = r16 + r18 | 0;
      r16 = HEAP32[r15];
      L2425 : do {
        if (r17 >>> 0 < r16 >>> 0) {
          r19 = r12;
          r20 = r13;
          r21 = r14;
        } else {
          r22 = HEAP32[r10 + 4 >> 2];
          r23 = r12;
          r24 = r13;
          r25 = r14;
          r26 = r17;
          r27 = r16;
          while (1) {
            if (r26 >>> 0 >= (r27 + r22 | 0) >>> 0 | (r26 | 0) == (r11 | 0)) {
              r19 = r23;
              r20 = r24;
              r21 = r25;
              break L2425;
            }
            r28 = r26 + 4 | 0;
            r29 = HEAP32[r28 >> 2];
            if ((r29 | 0) == 7) {
              r19 = r23;
              r20 = r24;
              r21 = r25;
              break L2425;
            }
            r30 = r29 & -8;
            r31 = r30 + r25 | 0;
            if ((r29 & 3 | 0) == 1) {
              r32 = r30 + r24 | 0;
              r33 = r23 + 1 | 0;
            } else {
              r32 = r24;
              r33 = r23;
            }
            r30 = r26 + (HEAP32[r28 >> 2] & -8) | 0;
            r28 = HEAP32[r15];
            if (r30 >>> 0 < r28 >>> 0) {
              r19 = r33;
              r20 = r32;
              r21 = r31;
              break L2425;
            } else {
              r23 = r33;
              r24 = r32;
              r25 = r31;
              r26 = r30;
              r27 = r28;
            }
          }
        }
      } while (0);
      r15 = HEAP32[r10 + 8 >> 2];
      if ((r15 | 0) == 0) {
        break;
      } else {
        r12 = r19;
        r13 = r20;
        r14 = r21;
        r10 = r15;
      }
    }
    r10 = HEAP32[1311601];
    r3 = HEAP32[1311496];
    r4 = r21;
    r5 = r19;
    r6 = r10 - r21 | 0;
    r7 = HEAP32[1311602];
    r8 = r20;
    r9 = r10 - r20 | 0;
  }
  HEAP32[r2] = r4;
  HEAP32[r2 + 1] = r5;
  r5 = r1 + 8 | 0;
  HEAP32[r5 >> 2] = 0;
  HEAP32[r5 + 4 >> 2] = 0;
  HEAP32[r2 + 4] = r6;
  HEAP32[r2 + 5] = r7;
  HEAP32[r2 + 6] = 0;
  HEAP32[r2 + 7] = r9;
  HEAP32[r2 + 8] = r8;
  HEAP32[r2 + 9] = r3;
  return;
}
function _malloc_stats() {
  _internal_malloc_stats();
  return;
}
function _internal_malloc_stats() {
  var r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21;
  r1 = STACKTOP;
  if ((HEAP32[1310722] | 0) == 0) {
    _init_mparams();
  }
  L2442 : do {
    if ((HEAP32[1311499] | 0) == 0) {
      r2 = 0;
      r3 = 0;
      r4 = 0;
    } else {
      r5 = HEAP32[1311602];
      r6 = HEAP32[1311601];
      r7 = HEAP32[1311499];
      r8 = r6 - 40 - HEAP32[1311496] | 0;
      r9 = 5246420;
      while (1) {
        r10 = (r9 | 0) >> 2;
        r11 = HEAP32[r10];
        r12 = r11 + 8 | 0;
        if ((r12 & 7 | 0) == 0) {
          r13 = 0;
        } else {
          r13 = -r12 & 7;
        }
        r12 = r11 + r13 | 0;
        r11 = HEAP32[r10];
        L2449 : do {
          if (r12 >>> 0 < r11 >>> 0) {
            r14 = r8;
          } else {
            r15 = HEAP32[r9 + 4 >> 2];
            r16 = r8;
            r17 = r12;
            r18 = r11;
            while (1) {
              if (r17 >>> 0 >= (r18 + r15 | 0) >>> 0 | (r17 | 0) == (r7 | 0)) {
                r14 = r16;
                break L2449;
              }
              r19 = r17 + 4 | 0;
              r20 = HEAP32[r19 >> 2];
              if ((r20 | 0) == 7) {
                r14 = r16;
                break L2449;
              }
              if ((r20 & 3 | 0) == 1) {
                r21 = r16 - (r20 & -8) | 0;
              } else {
                r21 = r16;
              }
              r20 = r17 + (HEAP32[r19 >> 2] & -8) | 0;
              r19 = HEAP32[r10];
              if (r20 >>> 0 < r19 >>> 0) {
                r14 = r21;
                break L2449;
              } else {
                r16 = r21;
                r17 = r20;
                r18 = r19;
              }
            }
          }
        } while (0);
        r10 = HEAP32[r9 + 8 >> 2];
        if ((r10 | 0) == 0) {
          r2 = r14;
          r3 = r6;
          r4 = r5;
          break L2442;
        } else {
          r8 = r14;
          r9 = r10;
        }
      }
    }
  } while (0);
  _fprintf(HEAP32[_stderr >> 2], 5243964, (tempInt = STACKTOP, STACKTOP = STACKTOP + 4 | 0, HEAP32[tempInt >> 2] = r4, tempInt));
  _fprintf(HEAP32[_stderr >> 2], 5245168, (tempInt = STACKTOP, STACKTOP = STACKTOP + 4 | 0, HEAP32[tempInt >> 2] = r3, tempInt));
  _fprintf(HEAP32[_stderr >> 2], 5245016, (tempInt = STACKTOP, STACKTOP = STACKTOP + 4 | 0, HEAP32[tempInt >> 2] = r2, tempInt));
  STACKTOP = r1;
  return;
}
function _mallopt(r1, r2) {
  return _change_mparam(r1, r2);
}
function _change_mparam(r1, r2) {
  var r3;
  if ((HEAP32[1310722] | 0) == 0) {
    _init_mparams();
  }
  do {
    if ((r1 | 0) == -2) {
      if (HEAP32[1310723] >>> 0 > r2 >>> 0) {
        r3 = 0;
        break;
      }
      if ((r2 - 1 & r2 | 0) != 0) {
        r3 = 0;
        break;
      }
      HEAP32[1310724] = r2;
      r3 = 1;
    } else if ((r1 | 0) == -1) {
      HEAP32[1310726] = r2;
      r3 = 1;
    } else if ((r1 | 0) == -3) {
      HEAP32[1310725] = r2;
      r3 = 1;
    } else {
      r3 = 0;
    }
  } while (0);
  return r3;
}
function _init_mparams() {
  var r1;
  if ((HEAP32[1310722] | 0) != 0) {
    return;
  }
  r1 = _sysconf(8);
  if ((r1 - 1 & r1 | 0) != 0) {
    _abort();
  }
  HEAP32[1310724] = r1;
  HEAP32[1310723] = r1;
  HEAP32[1310725] = -1;
  HEAP32[1310726] = 2097152;
  HEAP32[1310727] = 0;
  HEAP32[1311604] = 0;
  HEAP32[1310722] = _time(0) & -16 ^ 1431655768;
  return;
}
function _internal_bulk_free(r1, r2) {
  var r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14;
  r3 = 0;
  r4 = (r2 << 2) + r1 | 0;
  L2481 : do {
    if ((r2 | 0) != 0) {
      r5 = r1;
      L2482 : while (1) {
        r6 = HEAP32[r5 >> 2];
        L2484 : do {
          if ((r6 | 0) != 0) {
            r7 = r6 - 8 | 0;
            r8 = r7;
            r9 = (r6 - 4 | 0) >> 2;
            r10 = HEAP32[r9] & -8;
            HEAP32[r5 >> 2] = 0;
            if (r7 >>> 0 < HEAP32[1311497] >>> 0) {
              r3 = 1865;
              break L2482;
            }
            r7 = HEAP32[r9];
            if ((r7 & 3 | 0) == 1) {
              r3 = 1864;
              break L2482;
            }
            r11 = r5 + 4 | 0;
            r12 = r7 - 8 & -8;
            do {
              if ((r11 | 0) != (r4 | 0)) {
                if ((HEAP32[r11 >> 2] | 0) != (r12 + (r6 + 8) | 0)) {
                  break;
                }
                r13 = (HEAP32[r6 + (r12 | 4) >> 2] & -8) + r10 | 0;
                HEAP32[r9] = r7 & 1 | r13 | 2;
                r14 = r6 + (r13 - 4) | 0;
                HEAP32[r14 >> 2] = HEAP32[r14 >> 2] | 1;
                HEAP32[r11 >> 2] = r6;
                break L2484;
              }
            } while (0);
            _dispose_chunk(r8, r10);
          }
        } while (0);
        r6 = r5 + 4 | 0;
        if ((r6 | 0) == (r4 | 0)) {
          break L2481;
        } else {
          r5 = r6;
        }
      }
      if (r3 == 1865) {
        _abort();
      } else if (r3 == 1864) {
        _abort();
      }
    }
  } while (0);
  if (HEAP32[1311496] >>> 0 <= HEAP32[1311500] >>> 0) {
    return;
  }
  _sys_trim(0);
  return;
}
function _mmap_resize(r1, r2) {
  var r3, r4;
  r3 = HEAP32[r1 + 4 >> 2] & -8;
  if (r2 >>> 0 < 256) {
    r4 = 0;
    return r4;
  }
  do {
    if (r3 >>> 0 >= (r2 + 4 | 0) >>> 0) {
      if ((r3 - r2 | 0) >>> 0 > HEAP32[1310724] << 1 >>> 0) {
        break;
      } else {
        r4 = r1;
      }
      return r4;
    }
  } while (0);
  r4 = 0;
  return r4;
}
function _segment_holding(r1) {
  var r2, r3, r4, r5, r6;
  r2 = 0;
  r3 = 5246420, r4 = r3 >> 2;
  while (1) {
    r5 = HEAP32[r4];
    if (r5 >>> 0 <= r1 >>> 0) {
      if ((r5 + HEAP32[r4 + 1] | 0) >>> 0 > r1 >>> 0) {
        r6 = r3;
        r2 = 1882;
        break;
      }
    }
    r5 = HEAP32[r4 + 2];
    if ((r5 | 0) == 0) {
      r6 = 0;
      r2 = 1881;
      break;
    } else {
      r3 = r5, r4 = r3 >> 2;
    }
  }
  if (r2 == 1881) {
    return r6;
  } else if (r2 == 1882) {
    return r6;
  }
}
function _dispose_chunk(r1, r2) {
  var r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31, r32, r33, r34, r35, r36, r37, r38, r39, r40, r41, r42;
  r3 = r2 >> 2;
  r4 = 0;
  r5 = r1, r6 = r5 >> 2;
  r7 = r5 + r2 | 0;
  r8 = r7;
  r9 = HEAP32[r1 + 4 >> 2];
  L2520 : do {
    if ((r9 & 1 | 0) == 0) {
      r10 = HEAP32[r1 >> 2];
      if ((r9 & 3 | 0) == 0) {
        return;
      }
      r11 = r5 + -r10 | 0;
      r12 = r11;
      r13 = r10 + r2 | 0;
      r14 = HEAP32[1311497];
      if (r11 >>> 0 < r14 >>> 0) {
        _abort();
      }
      if ((r12 | 0) == (HEAP32[1311498] | 0)) {
        r15 = (r2 + (r5 + 4) | 0) >> 2;
        if ((HEAP32[r15] & 3 | 0) != 3) {
          r16 = r12, r17 = r16 >> 2;
          r18 = r13;
          break;
        }
        HEAP32[1311495] = r13;
        HEAP32[r15] = HEAP32[r15] & -2;
        HEAP32[(4 - r10 >> 2) + r6] = r13 | 1;
        HEAP32[r7 >> 2] = r13;
        return;
      }
      r15 = r10 >>> 3;
      if (r10 >>> 0 < 256) {
        r19 = HEAP32[(8 - r10 >> 2) + r6];
        r20 = HEAP32[(12 - r10 >> 2) + r6];
        r21 = (r15 << 3) + 5246012 | 0;
        do {
          if ((r19 | 0) != (r21 | 0)) {
            if (r19 >>> 0 < r14 >>> 0) {
              _abort();
            }
            if ((HEAP32[r19 + 12 >> 2] | 0) == (r12 | 0)) {
              break;
            }
            _abort();
          }
        } while (0);
        if ((r20 | 0) == (r19 | 0)) {
          HEAP32[1311493] = HEAP32[1311493] & (1 << r15 ^ -1);
          r16 = r12, r17 = r16 >> 2;
          r18 = r13;
          break;
        }
        do {
          if ((r20 | 0) != (r21 | 0)) {
            if (r20 >>> 0 < HEAP32[1311497] >>> 0) {
              _abort();
            }
            if ((HEAP32[r20 + 8 >> 2] | 0) == (r12 | 0)) {
              break;
            }
            _abort();
          }
        } while (0);
        HEAP32[r19 + 12 >> 2] = r20;
        HEAP32[r20 + 8 >> 2] = r19;
        r16 = r12, r17 = r16 >> 2;
        r18 = r13;
        break;
      }
      r21 = r11;
      r15 = HEAP32[(24 - r10 >> 2) + r6];
      r22 = HEAP32[(12 - r10 >> 2) + r6];
      L2553 : do {
        if ((r22 | 0) == (r21 | 0)) {
          r23 = 16 - r10 | 0;
          r24 = r23 + (r5 + 4) | 0;
          r25 = HEAP32[r24 >> 2];
          do {
            if ((r25 | 0) == 0) {
              r26 = r5 + r23 | 0;
              r27 = HEAP32[r26 >> 2];
              if ((r27 | 0) == 0) {
                r28 = 0, r29 = r28 >> 2;
                break L2553;
              } else {
                r30 = r27;
                r31 = r26;
                break;
              }
            } else {
              r30 = r25;
              r31 = r24;
            }
          } while (0);
          while (1) {
            r24 = r30 + 20 | 0;
            if ((HEAP32[r24 >> 2] | 0) == 0) {
              r25 = r30 + 16 | 0;
              if ((HEAP32[r25 >> 2] | 0) == 0) {
                break;
              } else {
                r32 = r25;
              }
            } else {
              r32 = r24;
            }
            r30 = HEAP32[r32 >> 2];
            r31 = r32;
          }
          if (r31 >>> 0 < HEAP32[1311497] >>> 0) {
            _abort();
          } else {
            HEAP32[r31 >> 2] = 0;
            r28 = r30, r29 = r28 >> 2;
            break;
          }
        } else {
          r24 = HEAP32[(8 - r10 >> 2) + r6];
          if (r24 >>> 0 < r14 >>> 0) {
            _abort();
          }
          r25 = r24 + 12 | 0;
          if ((HEAP32[r25 >> 2] | 0) != (r21 | 0)) {
            _abort();
          }
          r23 = r22 + 8 | 0;
          if ((HEAP32[r23 >> 2] | 0) == (r21 | 0)) {
            HEAP32[r25 >> 2] = r22;
            HEAP32[r23 >> 2] = r24;
            r28 = r22, r29 = r28 >> 2;
            break;
          } else {
            _abort();
          }
        }
      } while (0);
      if ((r15 | 0) == 0) {
        r16 = r12, r17 = r16 >> 2;
        r18 = r13;
        break;
      }
      r22 = r5 + (28 - r10) | 0;
      r14 = (HEAP32[r22 >> 2] << 2) + 5246276 | 0;
      do {
        if ((r21 | 0) == (HEAP32[r14 >> 2] | 0)) {
          HEAP32[r14 >> 2] = r28;
          if ((r28 | 0) != 0) {
            break;
          }
          HEAP32[1311494] = HEAP32[1311494] & (1 << HEAP32[r22 >> 2] ^ -1);
          r16 = r12, r17 = r16 >> 2;
          r18 = r13;
          break L2520;
        } else {
          if (r15 >>> 0 < HEAP32[1311497] >>> 0) {
            _abort();
          }
          r11 = r15 + 16 | 0;
          if ((HEAP32[r11 >> 2] | 0) == (r21 | 0)) {
            HEAP32[r11 >> 2] = r28;
          } else {
            HEAP32[r15 + 20 >> 2] = r28;
          }
          if ((r28 | 0) == 0) {
            r16 = r12, r17 = r16 >> 2;
            r18 = r13;
            break L2520;
          }
        }
      } while (0);
      if (r28 >>> 0 < HEAP32[1311497] >>> 0) {
        _abort();
      }
      HEAP32[r29 + 6] = r15;
      r21 = 16 - r10 | 0;
      r22 = HEAP32[(r21 >> 2) + r6];
      do {
        if ((r22 | 0) != 0) {
          if (r22 >>> 0 < HEAP32[1311497] >>> 0) {
            _abort();
          } else {
            HEAP32[r29 + 4] = r22;
            HEAP32[r22 + 24 >> 2] = r28;
            break;
          }
        }
      } while (0);
      r22 = HEAP32[(r21 + 4 >> 2) + r6];
      if ((r22 | 0) == 0) {
        r16 = r12, r17 = r16 >> 2;
        r18 = r13;
        break;
      }
      if (r22 >>> 0 < HEAP32[1311497] >>> 0) {
        _abort();
      } else {
        HEAP32[r29 + 5] = r22;
        HEAP32[r22 + 24 >> 2] = r28;
        r16 = r12, r17 = r16 >> 2;
        r18 = r13;
        break;
      }
    } else {
      r16 = r1, r17 = r16 >> 2;
      r18 = r2;
    }
  } while (0);
  r1 = HEAP32[1311497];
  if (r7 >>> 0 < r1 >>> 0) {
    _abort();
  }
  r28 = r2 + (r5 + 4) | 0;
  r29 = HEAP32[r28 >> 2];
  do {
    if ((r29 & 2 | 0) == 0) {
      if ((r8 | 0) == (HEAP32[1311499] | 0)) {
        r30 = HEAP32[1311496] + r18 | 0;
        HEAP32[1311496] = r30;
        HEAP32[1311499] = r16;
        HEAP32[r17 + 1] = r30 | 1;
        if ((r16 | 0) != (HEAP32[1311498] | 0)) {
          return;
        }
        HEAP32[1311498] = 0;
        HEAP32[1311495] = 0;
        return;
      }
      if ((r8 | 0) == (HEAP32[1311498] | 0)) {
        r30 = HEAP32[1311495] + r18 | 0;
        HEAP32[1311495] = r30;
        HEAP32[1311498] = r16;
        HEAP32[r17 + 1] = r30 | 1;
        HEAP32[(r30 >> 2) + r17] = r30;
        return;
      }
      r30 = (r29 & -8) + r18 | 0;
      r31 = r29 >>> 3;
      L2621 : do {
        if (r29 >>> 0 < 256) {
          r32 = HEAP32[r3 + (r6 + 2)];
          r9 = HEAP32[r3 + (r6 + 3)];
          r22 = (r31 << 3) + 5246012 | 0;
          do {
            if ((r32 | 0) != (r22 | 0)) {
              if (r32 >>> 0 < r1 >>> 0) {
                _abort();
              }
              if ((HEAP32[r32 + 12 >> 2] | 0) == (r8 | 0)) {
                break;
              }
              _abort();
            }
          } while (0);
          if ((r9 | 0) == (r32 | 0)) {
            HEAP32[1311493] = HEAP32[1311493] & (1 << r31 ^ -1);
            break;
          }
          do {
            if ((r9 | 0) != (r22 | 0)) {
              if (r9 >>> 0 < HEAP32[1311497] >>> 0) {
                _abort();
              }
              if ((HEAP32[r9 + 8 >> 2] | 0) == (r8 | 0)) {
                break;
              }
              _abort();
            }
          } while (0);
          HEAP32[r32 + 12 >> 2] = r9;
          HEAP32[r9 + 8 >> 2] = r32;
        } else {
          r22 = r7;
          r10 = HEAP32[r3 + (r6 + 6)];
          r15 = HEAP32[r3 + (r6 + 3)];
          L2623 : do {
            if ((r15 | 0) == (r22 | 0)) {
              r14 = r2 + (r5 + 20) | 0;
              r11 = HEAP32[r14 >> 2];
              do {
                if ((r11 | 0) == 0) {
                  r19 = r2 + (r5 + 16) | 0;
                  r20 = HEAP32[r19 >> 2];
                  if ((r20 | 0) == 0) {
                    r33 = 0, r34 = r33 >> 2;
                    break L2623;
                  } else {
                    r35 = r20;
                    r36 = r19;
                    break;
                  }
                } else {
                  r35 = r11;
                  r36 = r14;
                }
              } while (0);
              while (1) {
                r14 = r35 + 20 | 0;
                if ((HEAP32[r14 >> 2] | 0) == 0) {
                  r11 = r35 + 16 | 0;
                  if ((HEAP32[r11 >> 2] | 0) == 0) {
                    break;
                  } else {
                    r37 = r11;
                  }
                } else {
                  r37 = r14;
                }
                r35 = HEAP32[r37 >> 2];
                r36 = r37;
              }
              if (r36 >>> 0 < HEAP32[1311497] >>> 0) {
                _abort();
              } else {
                HEAP32[r36 >> 2] = 0;
                r33 = r35, r34 = r33 >> 2;
                break;
              }
            } else {
              r14 = HEAP32[r3 + (r6 + 2)];
              if (r14 >>> 0 < r1 >>> 0) {
                _abort();
              }
              r11 = r14 + 12 | 0;
              if ((HEAP32[r11 >> 2] | 0) != (r22 | 0)) {
                _abort();
              }
              r19 = r15 + 8 | 0;
              if ((HEAP32[r19 >> 2] | 0) == (r22 | 0)) {
                HEAP32[r11 >> 2] = r15;
                HEAP32[r19 >> 2] = r14;
                r33 = r15, r34 = r33 >> 2;
                break;
              } else {
                _abort();
              }
            }
          } while (0);
          if ((r10 | 0) == 0) {
            break;
          }
          r15 = r2 + (r5 + 28) | 0;
          r32 = (HEAP32[r15 >> 2] << 2) + 5246276 | 0;
          do {
            if ((r22 | 0) == (HEAP32[r32 >> 2] | 0)) {
              HEAP32[r32 >> 2] = r33;
              if ((r33 | 0) != 0) {
                break;
              }
              HEAP32[1311494] = HEAP32[1311494] & (1 << HEAP32[r15 >> 2] ^ -1);
              break L2621;
            } else {
              if (r10 >>> 0 < HEAP32[1311497] >>> 0) {
                _abort();
              }
              r9 = r10 + 16 | 0;
              if ((HEAP32[r9 >> 2] | 0) == (r22 | 0)) {
                HEAP32[r9 >> 2] = r33;
              } else {
                HEAP32[r10 + 20 >> 2] = r33;
              }
              if ((r33 | 0) == 0) {
                break L2621;
              }
            }
          } while (0);
          if (r33 >>> 0 < HEAP32[1311497] >>> 0) {
            _abort();
          }
          HEAP32[r34 + 6] = r10;
          r22 = HEAP32[r3 + (r6 + 4)];
          do {
            if ((r22 | 0) != 0) {
              if (r22 >>> 0 < HEAP32[1311497] >>> 0) {
                _abort();
              } else {
                HEAP32[r34 + 4] = r22;
                HEAP32[r22 + 24 >> 2] = r33;
                break;
              }
            }
          } while (0);
          r22 = HEAP32[r3 + (r6 + 5)];
          if ((r22 | 0) == 0) {
            break;
          }
          if (r22 >>> 0 < HEAP32[1311497] >>> 0) {
            _abort();
          } else {
            HEAP32[r34 + 5] = r22;
            HEAP32[r22 + 24 >> 2] = r33;
            break;
          }
        }
      } while (0);
      HEAP32[r17 + 1] = r30 | 1;
      HEAP32[(r30 >> 2) + r17] = r30;
      if ((r16 | 0) != (HEAP32[1311498] | 0)) {
        r38 = r30;
        break;
      }
      HEAP32[1311495] = r30;
      return;
    } else {
      HEAP32[r28 >> 2] = r29 & -2;
      HEAP32[r17 + 1] = r18 | 1;
      HEAP32[(r18 >> 2) + r17] = r18;
      r38 = r18;
    }
  } while (0);
  r18 = r38 >>> 3;
  if (r38 >>> 0 < 256) {
    r29 = r18 << 1;
    r28 = (r29 << 2) + 5246012 | 0;
    r33 = HEAP32[1311493];
    r34 = 1 << r18;
    do {
      if ((r33 & r34 | 0) == 0) {
        HEAP32[1311493] = r33 | r34;
        r39 = r28;
      } else {
        r18 = HEAP32[(r29 + 2 << 2) + 5246012 >> 2];
        if (r18 >>> 0 >= HEAP32[1311497] >>> 0) {
          r39 = r18;
          break;
        }
        _abort();
      }
    } while (0);
    HEAP32[(r29 + 2 << 2) + 5246012 >> 2] = r16;
    HEAP32[r39 + 12 >> 2] = r16;
    HEAP32[r17 + 2] = r39;
    HEAP32[r17 + 3] = r28;
    return;
  }
  r28 = r16;
  r39 = r38 >>> 8;
  do {
    if ((r39 | 0) == 0) {
      r40 = 0;
    } else {
      if (r38 >>> 0 > 16777215) {
        r40 = 31;
        break;
      }
      r29 = (r39 + 1048320 | 0) >>> 16 & 8;
      r34 = r39 << r29;
      r33 = (r34 + 520192 | 0) >>> 16 & 4;
      r18 = r34 << r33;
      r34 = (r18 + 245760 | 0) >>> 16 & 2;
      r6 = 14 - (r33 | r29 | r34) + (r18 << r34 >>> 15) | 0;
      r40 = r38 >>> ((r6 + 7 | 0) >>> 0) & 1 | r6 << 1;
    }
  } while (0);
  r39 = (r40 << 2) + 5246276 | 0;
  HEAP32[r17 + 7] = r40;
  HEAP32[r17 + 5] = 0;
  HEAP32[r17 + 4] = 0;
  r6 = HEAP32[1311494];
  r34 = 1 << r40;
  if ((r6 & r34 | 0) == 0) {
    HEAP32[1311494] = r6 | r34;
    HEAP32[r39 >> 2] = r28;
    HEAP32[r17 + 6] = r39;
    HEAP32[r17 + 3] = r16;
    HEAP32[r17 + 2] = r16;
    return;
  }
  if ((r40 | 0) == 31) {
    r41 = 0;
  } else {
    r41 = 25 - (r40 >>> 1) | 0;
  }
  r40 = r38 << r41;
  r41 = HEAP32[r39 >> 2];
  while (1) {
    if ((HEAP32[r41 + 4 >> 2] & -8 | 0) == (r38 | 0)) {
      break;
    }
    r42 = (r40 >>> 31 << 2) + r41 + 16 | 0;
    r39 = HEAP32[r42 >> 2];
    if ((r39 | 0) == 0) {
      r4 = 2008;
      break;
    } else {
      r40 = r40 << 1;
      r41 = r39;
    }
  }
  if (r4 == 2008) {
    if (r42 >>> 0 < HEAP32[1311497] >>> 0) {
      _abort();
    }
    HEAP32[r42 >> 2] = r28;
    HEAP32[r17 + 6] = r41;
    HEAP32[r17 + 3] = r16;
    HEAP32[r17 + 2] = r16;
    return;
  }
  r16 = r41 + 8 | 0;
  r42 = HEAP32[r16 >> 2];
  r4 = HEAP32[1311497];
  if (r41 >>> 0 < r4 >>> 0) {
    _abort();
  }
  if (r42 >>> 0 < r4 >>> 0) {
    _abort();
  }
  HEAP32[r42 + 12 >> 2] = r28;
  HEAP32[r16 >> 2] = r28;
  HEAP32[r17 + 2] = r42;
  HEAP32[r17 + 3] = r41;
  HEAP32[r17 + 6] = 0;
  return;
}
function _init_top(r1, r2) {
  var r3, r4, r5;
  r3 = r1;
  r4 = r1 + 8 | 0;
  if ((r4 & 7 | 0) == 0) {
    r5 = 0;
  } else {
    r5 = -r4 & 7;
  }
  r4 = r2 - r5 | 0;
  HEAP32[1311499] = r3 + r5 | 0;
  HEAP32[1311496] = r4;
  HEAP32[r5 + (r3 + 4) >> 2] = r4 | 1;
  HEAP32[r2 + (r3 + 4) >> 2] = 40;
  HEAP32[1311500] = HEAP32[1310726];
  return;
}
function _init_bins() {
  var r1, r2, r3;
  r1 = 0;
  while (1) {
    r2 = r1 << 1;
    r3 = (r2 << 2) + 5246012 | 0;
    HEAP32[(r2 + 3 << 2) + 5246012 >> 2] = r3;
    HEAP32[(r2 + 2 << 2) + 5246012 >> 2] = r3;
    r3 = r1 + 1 | 0;
    if ((r3 | 0) == 32) {
      break;
    } else {
      r1 = r3;
    }
  }
  return;
}
function _mmap_alloc() {}
function _prepend_alloc(r1, r2, r3) {
  var r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15, r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31, r32, r33, r34, r35, r36, r37, r38, r39, r40;
  r4 = r2 >> 2;
  r5 = r1 >> 2;
  r6 = 0;
  r7 = r1 + 8 | 0;
  if ((r7 & 7 | 0) == 0) {
    r8 = 0;
  } else {
    r8 = -r7 & 7;
  }
  r7 = r2 + 8 | 0;
  if ((r7 & 7 | 0) == 0) {
    r9 = 0, r10 = r9 >> 2;
  } else {
    r9 = -r7 & 7, r10 = r9 >> 2;
  }
  r7 = r2 + r9 | 0;
  r11 = r7;
  r12 = r8 + r3 | 0, r13 = r12 >> 2;
  r14 = r1 + r12 | 0;
  r12 = r14;
  r15 = r7 - (r1 + r8) - r3 | 0;
  HEAP32[(r8 + 4 >> 2) + r5] = r3 | 3;
  if ((r11 | 0) == (HEAP32[1311499] | 0)) {
    r3 = HEAP32[1311496] + r15 | 0;
    HEAP32[1311496] = r3;
    HEAP32[1311499] = r12;
    HEAP32[r13 + (r5 + 1)] = r3 | 1;
    r16 = r8 | 8;
    r17 = r1 + r16 | 0;
    return r17;
  }
  if ((r11 | 0) == (HEAP32[1311498] | 0)) {
    r3 = HEAP32[1311495] + r15 | 0;
    HEAP32[1311495] = r3;
    HEAP32[1311498] = r12;
    HEAP32[r13 + (r5 + 1)] = r3 | 1;
    HEAP32[(r3 >> 2) + r5 + r13] = r3;
    r16 = r8 | 8;
    r17 = r1 + r16 | 0;
    return r17;
  }
  r3 = HEAP32[r10 + (r4 + 1)];
  if ((r3 & 3 | 0) == 1) {
    r18 = r3 & -8;
    r19 = r3 >>> 3;
    L2758 : do {
      if (r3 >>> 0 < 256) {
        r20 = HEAP32[((r9 | 8) >> 2) + r4];
        r21 = HEAP32[r10 + (r4 + 3)];
        r22 = (r19 << 3) + 5246012 | 0;
        do {
          if ((r20 | 0) != (r22 | 0)) {
            if (r20 >>> 0 < HEAP32[1311497] >>> 0) {
              _abort();
            }
            if ((HEAP32[r20 + 12 >> 2] | 0) == (r11 | 0)) {
              break;
            }
            _abort();
          }
        } while (0);
        if ((r21 | 0) == (r20 | 0)) {
          HEAP32[1311493] = HEAP32[1311493] & (1 << r19 ^ -1);
          break;
        }
        do {
          if ((r21 | 0) != (r22 | 0)) {
            if (r21 >>> 0 < HEAP32[1311497] >>> 0) {
              _abort();
            }
            if ((HEAP32[r21 + 8 >> 2] | 0) == (r11 | 0)) {
              break;
            }
            _abort();
          }
        } while (0);
        HEAP32[r20 + 12 >> 2] = r21;
        HEAP32[r21 + 8 >> 2] = r20;
      } else {
        r22 = r7;
        r23 = HEAP32[((r9 | 24) >> 2) + r4];
        r24 = HEAP32[r10 + (r4 + 3)];
        L2778 : do {
          if ((r24 | 0) == (r22 | 0)) {
            r25 = r9 | 16;
            r26 = r25 + (r2 + 4) | 0;
            r27 = HEAP32[r26 >> 2];
            do {
              if ((r27 | 0) == 0) {
                r28 = r2 + r25 | 0;
                r29 = HEAP32[r28 >> 2];
                if ((r29 | 0) == 0) {
                  r30 = 0, r31 = r30 >> 2;
                  break L2778;
                } else {
                  r32 = r29;
                  r33 = r28;
                  break;
                }
              } else {
                r32 = r27;
                r33 = r26;
              }
            } while (0);
            while (1) {
              r26 = r32 + 20 | 0;
              if ((HEAP32[r26 >> 2] | 0) == 0) {
                r27 = r32 + 16 | 0;
                if ((HEAP32[r27 >> 2] | 0) == 0) {
                  break;
                } else {
                  r34 = r27;
                }
              } else {
                r34 = r26;
              }
              r32 = HEAP32[r34 >> 2];
              r33 = r34;
            }
            if (r33 >>> 0 < HEAP32[1311497] >>> 0) {
              _abort();
            } else {
              HEAP32[r33 >> 2] = 0;
              r30 = r32, r31 = r30 >> 2;
              break;
            }
          } else {
            r26 = HEAP32[((r9 | 8) >> 2) + r4];
            if (r26 >>> 0 < HEAP32[1311497] >>> 0) {
              _abort();
            }
            r27 = r26 + 12 | 0;
            if ((HEAP32[r27 >> 2] | 0) != (r22 | 0)) {
              _abort();
            }
            r25 = r24 + 8 | 0;
            if ((HEAP32[r25 >> 2] | 0) == (r22 | 0)) {
              HEAP32[r27 >> 2] = r24;
              HEAP32[r25 >> 2] = r26;
              r30 = r24, r31 = r30 >> 2;
              break;
            } else {
              _abort();
            }
          }
        } while (0);
        if ((r23 | 0) == 0) {
          break;
        }
        r24 = r9 + (r2 + 28) | 0;
        r20 = (HEAP32[r24 >> 2] << 2) + 5246276 | 0;
        do {
          if ((r22 | 0) == (HEAP32[r20 >> 2] | 0)) {
            HEAP32[r20 >> 2] = r30;
            if ((r30 | 0) != 0) {
              break;
            }
            HEAP32[1311494] = HEAP32[1311494] & (1 << HEAP32[r24 >> 2] ^ -1);
            break L2758;
          } else {
            if (r23 >>> 0 < HEAP32[1311497] >>> 0) {
              _abort();
            }
            r21 = r23 + 16 | 0;
            if ((HEAP32[r21 >> 2] | 0) == (r22 | 0)) {
              HEAP32[r21 >> 2] = r30;
            } else {
              HEAP32[r23 + 20 >> 2] = r30;
            }
            if ((r30 | 0) == 0) {
              break L2758;
            }
          }
        } while (0);
        if (r30 >>> 0 < HEAP32[1311497] >>> 0) {
          _abort();
        }
        HEAP32[r31 + 6] = r23;
        r22 = r9 | 16;
        r24 = HEAP32[(r22 >> 2) + r4];
        do {
          if ((r24 | 0) != 0) {
            if (r24 >>> 0 < HEAP32[1311497] >>> 0) {
              _abort();
            } else {
              HEAP32[r31 + 4] = r24;
              HEAP32[r24 + 24 >> 2] = r30;
              break;
            }
          }
        } while (0);
        r24 = HEAP32[(r22 + 4 >> 2) + r4];
        if ((r24 | 0) == 0) {
          break;
        }
        if (r24 >>> 0 < HEAP32[1311497] >>> 0) {
          _abort();
        } else {
          HEAP32[r31 + 5] = r24;
          HEAP32[r24 + 24 >> 2] = r30;
          break;
        }
      }
    } while (0);
    r35 = r2 + (r18 | r9) | 0;
    r36 = r18 + r15 | 0;
  } else {
    r35 = r11;
    r36 = r15;
  }
  r15 = r35 + 4 | 0;
  HEAP32[r15 >> 2] = HEAP32[r15 >> 2] & -2;
  HEAP32[r13 + (r5 + 1)] = r36 | 1;
  HEAP32[(r36 >> 2) + r5 + r13] = r36;
  r15 = r36 >>> 3;
  if (r36 >>> 0 < 256) {
    r35 = r15 << 1;
    r11 = (r35 << 2) + 5246012 | 0;
    r18 = HEAP32[1311493];
    r9 = 1 << r15;
    do {
      if ((r18 & r9 | 0) == 0) {
        HEAP32[1311493] = r18 | r9;
        r37 = r11;
      } else {
        r15 = HEAP32[(r35 + 2 << 2) + 5246012 >> 2];
        if (r15 >>> 0 >= HEAP32[1311497] >>> 0) {
          r37 = r15;
          break;
        }
        _abort();
      }
    } while (0);
    HEAP32[(r35 + 2 << 2) + 5246012 >> 2] = r12;
    HEAP32[r37 + 12 >> 2] = r12;
    HEAP32[r13 + (r5 + 2)] = r37;
    HEAP32[r13 + (r5 + 3)] = r11;
    r16 = r8 | 8;
    r17 = r1 + r16 | 0;
    return r17;
  }
  r11 = r14;
  r14 = r36 >>> 8;
  do {
    if ((r14 | 0) == 0) {
      r38 = 0;
    } else {
      if (r36 >>> 0 > 16777215) {
        r38 = 31;
        break;
      }
      r37 = (r14 + 1048320 | 0) >>> 16 & 8;
      r12 = r14 << r37;
      r35 = (r12 + 520192 | 0) >>> 16 & 4;
      r9 = r12 << r35;
      r12 = (r9 + 245760 | 0) >>> 16 & 2;
      r18 = 14 - (r35 | r37 | r12) + (r9 << r12 >>> 15) | 0;
      r38 = r36 >>> ((r18 + 7 | 0) >>> 0) & 1 | r18 << 1;
    }
  } while (0);
  r14 = (r38 << 2) + 5246276 | 0;
  HEAP32[r13 + (r5 + 7)] = r38;
  HEAP32[r13 + (r5 + 5)] = 0;
  HEAP32[r13 + (r5 + 4)] = 0;
  r18 = HEAP32[1311494];
  r12 = 1 << r38;
  if ((r18 & r12 | 0) == 0) {
    HEAP32[1311494] = r18 | r12;
    HEAP32[r14 >> 2] = r11;
    HEAP32[r13 + (r5 + 6)] = r14;
    HEAP32[r13 + (r5 + 3)] = r11;
    HEAP32[r13 + (r5 + 2)] = r11;
    r16 = r8 | 8;
    r17 = r1 + r16 | 0;
    return r17;
  }
  if ((r38 | 0) == 31) {
    r39 = 0;
  } else {
    r39 = 25 - (r38 >>> 1) | 0;
  }
  r38 = r36 << r39;
  r39 = HEAP32[r14 >> 2];
  while (1) {
    if ((HEAP32[r39 + 4 >> 2] & -8 | 0) == (r36 | 0)) {
      break;
    }
    r40 = (r38 >>> 31 << 2) + r39 + 16 | 0;
    r14 = HEAP32[r40 >> 2];
    if ((r14 | 0) == 0) {
      r6 = 2122;
      break;
    } else {
      r38 = r38 << 1;
      r39 = r14;
    }
  }
  if (r6 == 2122) {
    if (r40 >>> 0 < HEAP32[1311497] >>> 0) {
      _abort();
    }
    HEAP32[r40 >> 2] = r11;
    HEAP32[r13 + (r5 + 6)] = r39;
    HEAP32[r13 + (r5 + 3)] = r11;
    HEAP32[r13 + (r5 + 2)] = r11;
    r16 = r8 | 8;
    r17 = r1 + r16 | 0;
    return r17;
  }
  r40 = r39 + 8 | 0;
  r6 = HEAP32[r40 >> 2];
  r38 = HEAP32[1311497];
  if (r39 >>> 0 < r38 >>> 0) {
    _abort();
  }
  if (r6 >>> 0 < r38 >>> 0) {
    _abort();
  }
  HEAP32[r6 + 12 >> 2] = r11;
  HEAP32[r40 >> 2] = r11;
  HEAP32[r13 + (r5 + 2)] = r6;
  HEAP32[r13 + (r5 + 3)] = r39;
  HEAP32[r13 + (r5 + 6)] = 0;
  r16 = r8 | 8;
  r17 = r1 + r16 | 0;
  return r17;
}
function _add_segment(r1, r2) {
  var r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15;
  r3 = 0;
  r4 = HEAP32[1311499], r5 = r4 >> 2;
  r6 = r4;
  r7 = _segment_holding(r6);
  r8 = HEAP32[r7 >> 2];
  r9 = HEAP32[r7 + 4 >> 2];
  r7 = r8 + r9 | 0;
  r10 = r8 + (r9 - 39) | 0;
  if ((r10 & 7 | 0) == 0) {
    r11 = 0;
  } else {
    r11 = -r10 & 7;
  }
  r10 = r8 + (r9 - 47) + r11 | 0;
  r11 = r10 >>> 0 < (r4 + 16 | 0) >>> 0 ? r6 : r10;
  r10 = r11 + 8 | 0, r9 = r10 >> 2;
  _init_top(r1, r2 - 40 | 0);
  HEAP32[r11 + 4 >> 2] = 27;
  HEAP32[r9] = HEAP32[1311605];
  HEAP32[r9 + 1] = HEAP32[1311606];
  HEAP32[r9 + 2] = HEAP32[1311607];
  HEAP32[r9 + 3] = HEAP32[1311608];
  HEAP32[1311605] = r1;
  HEAP32[1311606] = r2;
  HEAP32[1311608] = 0;
  HEAP32[1311607] = r10;
  r10 = r11 + 28 | 0;
  HEAP32[r10 >> 2] = 7;
  L2871 : do {
    if ((r11 + 32 | 0) >>> 0 < r7 >>> 0) {
      r2 = r10;
      while (1) {
        r1 = r2 + 4 | 0;
        HEAP32[r1 >> 2] = 7;
        if ((r2 + 8 | 0) >>> 0 < r7 >>> 0) {
          r2 = r1;
        } else {
          break L2871;
        }
      }
    }
  } while (0);
  if ((r11 | 0) == (r6 | 0)) {
    return;
  }
  r7 = r11 - r4 | 0;
  r11 = r7 + (r6 + 4) | 0;
  HEAP32[r11 >> 2] = HEAP32[r11 >> 2] & -2;
  HEAP32[r5 + 1] = r7 | 1;
  HEAP32[r6 + r7 >> 2] = r7;
  r6 = r7 >>> 3;
  if (r7 >>> 0 < 256) {
    r11 = r6 << 1;
    r10 = (r11 << 2) + 5246012 | 0;
    r2 = HEAP32[1311493];
    r1 = 1 << r6;
    do {
      if ((r2 & r1 | 0) == 0) {
        HEAP32[1311493] = r2 | r1;
        r12 = r10;
      } else {
        r6 = HEAP32[(r11 + 2 << 2) + 5246012 >> 2];
        if (r6 >>> 0 >= HEAP32[1311497] >>> 0) {
          r12 = r6;
          break;
        }
        _abort();
      }
    } while (0);
    HEAP32[(r11 + 2 << 2) + 5246012 >> 2] = r4;
    HEAP32[r12 + 12 >> 2] = r4;
    HEAP32[r5 + 2] = r12;
    HEAP32[r5 + 3] = r10;
    return;
  }
  r10 = r4;
  r12 = r7 >>> 8;
  do {
    if ((r12 | 0) == 0) {
      r13 = 0;
    } else {
      if (r7 >>> 0 > 16777215) {
        r13 = 31;
        break;
      }
      r11 = (r12 + 1048320 | 0) >>> 16 & 8;
      r1 = r12 << r11;
      r2 = (r1 + 520192 | 0) >>> 16 & 4;
      r6 = r1 << r2;
      r1 = (r6 + 245760 | 0) >>> 16 & 2;
      r9 = 14 - (r2 | r11 | r1) + (r6 << r1 >>> 15) | 0;
      r13 = r7 >>> ((r9 + 7 | 0) >>> 0) & 1 | r9 << 1;
    }
  } while (0);
  r12 = (r13 << 2) + 5246276 | 0;
  HEAP32[r5 + 7] = r13;
  HEAP32[r5 + 5] = 0;
  HEAP32[r5 + 4] = 0;
  r9 = HEAP32[1311494];
  r1 = 1 << r13;
  if ((r9 & r1 | 0) == 0) {
    HEAP32[1311494] = r9 | r1;
    HEAP32[r12 >> 2] = r10;
    HEAP32[r5 + 6] = r12;
    HEAP32[r5 + 3] = r4;
    HEAP32[r5 + 2] = r4;
    return;
  }
  if ((r13 | 0) == 31) {
    r14 = 0;
  } else {
    r14 = 25 - (r13 >>> 1) | 0;
  }
  r13 = r7 << r14;
  r14 = HEAP32[r12 >> 2];
  while (1) {
    if ((HEAP32[r14 + 4 >> 2] & -8 | 0) == (r7 | 0)) {
      break;
    }
    r15 = (r13 >>> 31 << 2) + r14 + 16 | 0;
    r12 = HEAP32[r15 >> 2];
    if ((r12 | 0) == 0) {
      r3 = 2166;
      break;
    } else {
      r13 = r13 << 1;
      r14 = r12;
    }
  }
  if (r3 == 2166) {
    if (r15 >>> 0 < HEAP32[1311497] >>> 0) {
      _abort();
    }
    HEAP32[r15 >> 2] = r10;
    HEAP32[r5 + 6] = r14;
    HEAP32[r5 + 3] = r4;
    HEAP32[r5 + 2] = r4;
    return;
  }
  r4 = r14 + 8 | 0;
  r15 = HEAP32[r4 >> 2];
  r3 = HEAP32[1311497];
  if (r14 >>> 0 < r3 >>> 0) {
    _abort();
  }
  if (r15 >>> 0 < r3 >>> 0) {
    _abort();
  }
  HEAP32[r15 + 12 >> 2] = r10;
  HEAP32[r4 >> 2] = r10;
  HEAP32[r5 + 2] = r15;
  HEAP32[r5 + 3] = r14;
  HEAP32[r5 + 6] = 0;
  return;
}
function __ZNKSt9bad_alloc4whatEv(r1) {
  return 5244708;
}
function __ZNKSt20bad_array_new_length4whatEv(r1) {
  return 5245508;
}
function __ZSt15get_new_handlerv() {
  return tempValue = HEAP32[1311762], HEAP32[1311762] = tempValue, tempValue;
}
function __ZSt15set_new_handlerPFvvE(r1) {
  return tempValue = HEAP32[1311762], HEAP32[1311762] = r1, tempValue;
}
function __ZNSt9bad_allocC2Ev(r1) {
  HEAP32[r1 >> 2] = 5246936;
  return;
}
function __ZNSt9bad_allocC1Ev(r1) {
  __ZNSt9bad_allocC2Ev(r1);
  return;
}
function __ZNSt9bad_allocD1Ev(r1) {
  __ZNSt9bad_allocD2Ev(r1);
  return;
}
function __ZdlPv(r1) {
  if ((r1 | 0) == 0) {
    return;
  }
  _free(r1);
  return;
}
function __ZdlPvRKSt9nothrow_t(r1, r2) {
  __ZdlPv(r1);
  return;
}
function __ZdaPv(r1) {
  __ZdlPv(r1);
  return;
}
function __ZdaPvRKSt9nothrow_t(r1, r2) {
  __ZdaPv(r1);
  return;
}
function __ZNSt9bad_allocD0Ev(r1) {
  __ZNSt9bad_allocD1Ev(r1);
  __ZdlPv(r1);
  return;
}
function __ZNSt9bad_allocD2Ev(r1) {
  return;
}
function __ZNSt20bad_array_new_lengthC1Ev(r1) {
  __ZNSt20bad_array_new_lengthC2Ev(r1);
  return;
}
function __ZNSt20bad_array_new_lengthC2Ev(r1) {
  __ZNSt9bad_allocC2Ev(r1 | 0);
  HEAP32[r1 >> 2] = 5246960;
  return;
}
function __ZNSt20bad_array_new_lengthD0Ev(r1) {
  __ZNSt20bad_array_new_lengthD1Ev(r1);
  __ZdlPv(r1);
  return;
}
function __ZNSt20bad_array_new_lengthD1Ev(r1) {
  __ZNSt20bad_array_new_lengthD2Ev(r1);
  return;
}
function __ZNSt20bad_array_new_lengthD2Ev(r1) {
  __ZNSt9bad_allocD2Ev(r1 | 0);
  return;
}
function __Znwj(r1) {
  var r2, r3, r4;
  r2 = 0;
  r3 = (r1 | 0) == 0 ? 1 : r1;
  while (1) {
    r4 = _malloc(r3);
    if ((r4 | 0) != 0) {
      r2 = 2212;
      break;
    }
    r1 = __ZSt15get_new_handlerv();
    if ((r1 | 0) == 0) {
      break;
    }
    FUNCTION_TABLE[r1]();
  }
  if (r2 == 2212) {
    return r4;
  }
  r4 = ___cxa_allocate_exception(4);
  __ZNSt9bad_allocC1Ev(r4);
  ___cxa_throw(r4, 5247020, 4);
}
function __ZnwjRKSt9nothrow_t(r1, r2) {
  return __Znwj(r1);
}
function __Znaj(r1) {
  return __Znwj(r1);
}
function __ZnajRKSt9nothrow_t(r1, r2) {
  return __Znaj(r1);
}
function __ZSt17__throw_bad_allocv() {
  var r1;
  r1 = ___cxa_allocate_exception(4);
  __ZNSt9bad_allocC1Ev(r1);
  ___cxa_throw(r1, 5247020, 4);
}





// Warning: printing of i64 values may be slightly rounded! No deep i64 math used, so precise i64 code not included
var i64Math = null;

// === Auto-generated postamble setup entry stuff ===

Module.callMain = function callMain(args) {
  var argc = args.length+1;
  function pad() {
    for (var i = 0; i < 4-1; i++) {
      argv.push(0);
    }
  }
  var argv = [allocate(intArrayFromString("/bin/this.program"), 'i8', ALLOC_STATIC) ];
  pad();
  for (var i = 0; i < argc-1; i = i + 1) {
    argv.push(allocate(intArrayFromString(args[i]), 'i8', ALLOC_STATIC));
    pad();
  }
  argv.push(0);
  argv = allocate(argv, 'i32', ALLOC_STATIC);


  var ret;

  ret = Module['_main'](argc, argv, 0);


  return ret;
}




function run(args) {
  args = args || Module['arguments'];

  if (runDependencies > 0) {
    Module.printErr('run() called, but dependencies remain, so not running');
    return 0;
  }

  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    var toRun = Module['preRun'];
    Module['preRun'] = [];
    for (var i = toRun.length-1; i >= 0; i--) {
      toRun[i]();
    }
    if (runDependencies > 0) {
      // a preRun added a dependency, run will be called later
      return 0;
    }
  }

  function doRun() {
    var ret = 0;
    calledRun = true;
    if (Module['_main']) {
      preMain();
      ret = Module.callMain(args);
      if (!Module['noExitRuntime']) {
        exitRuntime();
      }
    }
    if (Module['postRun']) {
      if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
      while (Module['postRun'].length > 0) {
        Module['postRun'].pop()();
      }
    }
    return ret;
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      doRun();
    }, 1);
    return 0;
  } else {
    return doRun();
  }
}
Module['run'] = Module.run = run;

// {{PRE_RUN_ADDITIONS}}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}

initRuntime();

var shouldRunNow = true;
if (Module['noInitialRun']) {
  shouldRunNow = false;
}

if (shouldRunNow) {
  var ret = run();
}

// {{POST_RUN_ADDITIONS}}






  // {{MODULE_ADDITIONS}}





